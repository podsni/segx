// Auto-generated by tools/generate-embedded-scripts.ts. Do not edit manually.
export const embeddedScripts: { path: string; content: string }[] = [
  {
    "path": "tes.sh",
    "content": "#!/bin/bash\n\n# ---------------------------\n# Konfigurasi pengguna\n# ---------------------------\nSSH_KEY=\"$HOME/.ssh/bitwarden_localan\"\nSSH_ALIAS=\"github-localan\"\nGITHUB_USER=\"localan\"\nGITHUB_EMAIL=\"localso@proton.me\"\nSSH_CONFIG_FILE=\"$HOME/.ssh/config\"\n\necho \"==========[ SETUP GITHUB SSH ]==========\"\necho \"Akun GitHub : $GITHUB_USER\"\necho \"SSH Key     : $SSH_KEY\"\necho \"Alias Host  : $SSH_ALIAS\"\necho \"========================================\"\n\n# 1. Tambah SSH config jika belum ada\nif [ ! -f \"$SSH_CONFIG_FILE\" ]; then\n  touch \"$SSH_CONFIG_FILE\"\n  chmod 600 \"$SSH_CONFIG_FILE\"\nfi\n\nif ! grep -q \"$SSH_ALIAS\" \"$SSH_CONFIG_FILE\"; then\n  echo \"[*] Menambahkan alias SSH ke $SSH_CONFIG_FILE...\"\n  cat <<EOF >> \"$SSH_CONFIG_FILE\"\n\n# GitHub SSH config for $GITHUB_USER\nHost $SSH_ALIAS\n  HostName github.com\n  User git\n  IdentityFile $SSH_KEY\n  IdentitiesOnly yes\nEOF\nelse\n  echo \"[=] SSH config '$SSH_ALIAS' sudah ada, dilewati.\"\nfi\n\n# 2. Perbaiki permission key\nchmod 600 \"$SSH_KEY\"\n\n# 3. Cek koneksi SSH (langsung tampilkan hasil)\necho \"\"\necho \"[*] Menguji koneksi SSH ke GitHub...\"\necho \"    ssh -T $SSH_ALIAS\"\necho \"----------------------------------------\"\nssh -T $SSH_ALIAS\necho \"----------------------------------------\"\n\n# 4. Konfigurasi Git global\necho \"\"\necho \"[*] Mengatur Git global user & email...\"\ngit config --global user.name \"$GITHUB_USER\"\ngit config --global user.email \"$GITHUB_EMAIL\"\n\n# 5. Tampilkan hasil konfigurasi Git\necho \"[*] Konfigurasi Git saat ini:\"\ngit config --global --list\n\necho \"\"\necho \"��� Setup selesai!\"\necho \"��� Gunakan ini untuk clone repo:\"\necho \"    git clone git@$SSH_ALIAS:$GITHUB_USER/<repo>.git\"\n\n"
  },
  {
    "path": "vm-test/vps-check.sh",
    "content": "#!/usr/bin/env bash\n# vps-check.sh — sederhana dan aman untuk tes VPS\n# Penggunaan:\n#   bash vps-check.sh --all\n#   bash vps-check.sh --sys --cpu --disk --net --ports\n# Opsi:\n#   --all | -a        : Jalankan semua tes\n#   --sys             : Info sistem\n#   --cpu             : Benchmark CPU (gunakan sysbench jika ada)\n#   --disk            : Tes disk I/O (dd)\n#   --net             : Tes jaringan (IP publik, ping, download via curl, speedtest jika ada)\n#   --ports           : Cek konektivitas keluar port umum\n#   --size=MB         : Ukuran file tes disk (default 256)\n#   --install         : Coba install utilitas opsional (sysbench, speedtest-cli, traceroute) jika tidak ada\n#   --no-color        : Nonaktifkan warna\n#   --help | -h       : Bantuan\n\nCOLOR=1\nfor arg in \"$@\"; do [[ \"$arg\" == \"--no-color\" ]] && COLOR=0; done\nif [[ $COLOR -eq 1 ]]; then\n  BOLD=\"\\033[1m\"; DIM=\"\\033[2m\"; RED=\"\\033[31m\"; GREEN=\"\\033[32m\"; YELLOW=\"\\033[33m\"; CYAN=\"\\033[36m\"; NC=\"\\033[0m\"\nelse\n  BOLD=\"\"; DIM=\"\"; RED=\"\"; GREEN=\"\"; YELLOW=\"\"; CYAN=\"\"; NC=\"\"\nfi\n\nheader() { echo -e \"${BOLD}$1${NC}\"; }\ninfo()   { echo -e \"${CYAN}$1${NC}\"; }\nok()     { echo -e \"${GREEN}$1${NC}\"; }\nwarn()   { echo -e \"${YELLOW}$1${NC}\"; }\nerr()    { echo -e \"${RED}$1${NC}\" 1>&2; }\n\nHAS() { command -v \"$1\" >/dev/null 2>&1; }\n\nALLOW_INSTALL=0\nDISK_SIZE_MB=256\nDO_SYS=0; DO_CPU=0; DO_DISK=0; DO_NET=0; DO_PORTS=0; RUN_ALL=0\n\nif [[ $# -eq 0 ]]; then RUN_ALL=1; fi\n\nfor arg in \"$@\"; do\n  case \"$arg\" in\n    --all|-a) RUN_ALL=1 ;;\n    --sys) DO_SYS=1 ;;\n    --cpu) DO_CPU=1 ;;\n    --disk) DO_DISK=1 ;;\n    --net) DO_NET=1 ;;\n    --ports) DO_PORTS=1 ;;\n    --install) ALLOW_INSTALL=1 ;;\n    --size=*) DISK_SIZE_MB=\"${arg#*=}\";;\n    --help|-h)\n      sed -n '2,50p' \"$0\"; exit 0;;\n    --no-color) ;; # handled earlier\n    *) warn \"Opsi tidak dikenal: $arg\";;\n  esac\ndone\n\nif [[ $RUN_ALL -eq 1 ]]; then DO_SYS=1; DO_CPU=1; DO_DISK=1; DO_NET=1; DO_PORTS=1; fi\n\ndetect_pkg() {\n  if HAS apt-get; then echo \"apt\"; return; fi\n  if HAS dnf; then echo \"dnf\"; return; fi\n  if HAS yum; then echo \"yum\"; return; fi\n  if HAS pacman; then echo \"pacman\"; return; fi\n  echo \"\"\n}\n\nensure_pkg() {\n  local name=\"$1\"; local aptname=\"${2:-$1}\"\n  if HAS \"$name\"; then return 0; fi\n  [[ $ALLOW_INSTALL -eq 0 ]] && return 1\n  local mgr; mgr=$(detect_pkg)\n  [[ -z \"$mgr\" ]] && return 1\n  info \"Menginstall $aptname (butuh sudo) ...\"\n  case \"$mgr\" in\n    apt) sudo apt-get update -y && sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \"$aptname\" ;;\n    dnf) sudo dnf install -y \"$aptname\" ;;\n    yum) sudo yum install -y \"$aptname\" ;;\n    pacman) sudo pacman -Sy --noconfirm \"$aptname\" ;;\n  esac\n  HAS \"$name\"\n}\n\nhr() { echo -e \"${DIM}----------------------------------------------------------------${NC}\"; }\n\nsys_info() {\n  header \"[1] Info Sistem\"\n  hr\n  echo \"Tanggal        : $(date -Is)\"\n  echo \"Uptime         : $(uptime -p 2>/dev/null || true)\"\n  echo \"Kernel         : $(uname -r)\"\n  echo \"Arsitektur     : $(uname -m)\"\n  echo \"Hostname       : $(hostname)\"\n  if HAS hostnamectl; then echo \"OS             : $(hostnamectl 2>/dev/null | sed -n 's/.*Operating System: //p')\"; fi\n  if HAS systemd-detect-virt; then echo \"Virtualisasi   : $(systemd-detect-virt 2>/dev/null || echo 'unknown')\"; fi\n  if HAS lscpu; then echo \"CPU            : $(lscpu | sed -n 's/^Model name:\\\\s*//p' | head -1)\"; fi\n  echo \"vCPU           : $(nproc 2>/dev/null || echo '?')\"\n  echo \"Memori         :\"; free -h || true\n  echo \"Disk           :\"; df -hT --total | sed 's/^/  /'\n  if HAS lsblk; then echo \"Block Devices  :\"; lsblk -o NAME,SIZE,ROTA,TYPE,MOUNTPOINTS | sed 's/^/  /'; fi\n  hr\n}\n\ncpu_bench() {\n  header \"[2] Benchmark CPU\"\n  hr\n  if HAS sysbench || ensure_pkg sysbench; then\n    local threads seconds\n    threads=$(nproc)\n    seconds=10\n    info \"Menjalankan sysbench CPU ${seconds}s dengan ${threads} thread...\"\n    sysbench cpu --threads=\"$threads\" --time=\"$seconds\" run | sed 's/^/  /'\n  else\n    warn \"sysbench tidak tersedia. Jalankan dengan --install untuk memasang.\"\n  fi\n  hr\n}\n\ndisk_io() {\n  header \"[3] Tes Disk I/O (dd)\"\n  hr\n  local tmpfile count\n  count=\"$DISK_SIZE_MB\"\n  tmpfile=\"$(mktemp /tmp/vps_io.XXXXXX)\"\n  info \"Menulis ${DISK_SIZE_MB} MB ke $tmpfile ...\"\n  dd if=/dev/zero of=\"$tmpfile\" bs=1M count=\"$count\" conv=fdatasync status=progress 2>&1 | tail -1\n  info \"Membaca kembali ${DISK_SIZE_MB} MB ...\"\n  dd if=\"$tmpfile\" of=/dev/null bs=1M status=progress 2>&1 | tail -1\n  rm -f \"$tmpfile\"\n  hr\n}\n\nnet_tests() {\n  header \"[4] Tes Jaringan\"\n  hr\n  echo \"IP Publik v4   : $(curl -4 -s --max-time 5 https://ifconfig.co 2>/dev/null || echo '-')\"\n  echo \"IP Publik v6   : $(curl -6 -s --max-time 5 https://ifconfig.co 2>/dev/null || echo '-')\"\n  echo\n  info \"Ping (ICMP) ke 1.1.1.1 dan 8.8.8.8 (4 paket)...\"\n  if HAS ping; then\n    ping -c 4 -W 2 1.1.1.1 | sed 's/^/  /'\n    ping -c 4 -W 2 8.8.8.8 | sed 's/^/  /'\n  else\n    warn \"ping tidak tersedia.\"\n  fi\n  echo\n  if HAS traceroute || ensure_pkg traceroute; then\n    info \"Traceroute singkat (maks 10 hop) ke 1.1.1.1...\"\n    traceroute -m 10 -q 1 1.1.1.1 | sed 's/^/  /'\n  else\n    warn \"traceroute tidak tersedia.\"\n  fi\n  echo\n  if HAS speedtest || HAS speedtest-cli || ensure_pkg speedtest-cli; then\n    local stbin\n    stbin=\"$(command -v speedtest || command -v speedtest-cli)\"\n    info \"Speedtest (server otomatis)...\"\n    \"$stbin\" --secure --accept-license --accept-gdpr 2>/dev/null | sed 's/^/  /'\n  else\n    warn \"speedtest-cli tidak tersedia. Pakai --install atau lihat tes unduh curl di bawah.\"\n  fi\n  echo\n  info \"Tes unduh via curl (ke beberapa region, 100MB file):\"\n  local urls=(\n    \"https://speed.hetzner.de/100MB.bin\"\n    \"https://mirror.sg.gs/100MB.bin\"\n    \"https://speedtest.tele2.net/100MB.zip\"\n    \"https://cachefly.cachefly.net/100mb.test\"\n  )\n  for u in \"${urls[@]}\"; do\n    printf \"%s\\n\" \"  URL: $u\"\n    # keluarkan ke /dev/null, tampilkan kecepatan rata-rata MB/s dan waktu\n    curl -L --fail --silent --output /dev/null --write-out \"    Kecepatan: %{speed_download} B/s  Waktu: %{time_total}s  Resolusi IP: %{remote_ip}\\n\" \"$u\" \\\n      | awk '{\n        bytes=$3; time=$6; ip=$9;\n        mbs=(bytes/1048576);\n        printf \"    Kecepatan: %.2f MB/s (%.2f Mbps) | Waktu: %s s | IP: %s\\n\", mbs, mbs*8, time, ip\n      }' || printf \"    Gagal mengunduh.\\n\"\n  done\n  hr\n}\n\nport_checks() {\n  header \"[5] Cek Port Keluar\"\n  hr\n  # gunakan bash /dev/tcp dengan timeout\n  check_port() {\n    local host=\"$1\" port=\"$2\" label=\"$3\"\n    timeout 3 bash -c \">/dev/tcp/$host/$port\" 2>/dev/null\n    if [[ $? -eq 0 ]]; then\n      ok \"  OK  - $label ($host:$port) dapat dijangkau\"\n    else\n      warn \"  FAIL- $label ($host:$port) tidak bisa dijangkau\"\n    fi\n  }\n  check_port 1.1.1.1 53  \"DNS (UDP/TCP 53) — TCP check\"\n  check_port 8.8.8.8 53  \"DNS (UDP/TCP 53) — TCP check\"\n  check_port google.com 80  \"HTTP 80\"\n  check_port google.com 443 \"HTTPS 443\"\n  check_port github.com 443 \"GitHub 443\"\n  check_port ssh.github.com 443 \"SSH over 443\"\n  check_port github.com 22  \"SSH 22\"\n  hr\n}\n\nmain() {\n  [[ $DO_SYS -eq 1 ]] && sys_info\n  [[ $DO_CPU -eq 1 ]] && cpu_bench\n  [[ $DO_DISK -eq 1 ]] && disk_io\n  [[ $DO_NET -eq 1 ]] && net_tests\n  [[ $DO_PORTS -eq 1 ]] && port_checks\n  info \"Selesai.\"\n}\n\nmain"
  },
  {
    "path": "vm-test/harden-server.sh",
    "content": "#!/usr/bin/env bash\n\n# harden-server.sh — Baseline hardening untuk Debian/Ubuntu (idempotent, non-interaktif)\n#\n# Fitur:\n# - Deteksi OS (Debian/Ubuntu) & apt\n# - Update, upgrade, dan aktifkan unattended-upgrades (reboot otomatis jam 03:30)\n# - Firewall UFW (default deny incoming; allow OpenSSH, 80/tcp, 443/tcp)\n# - SSH hardening (PermitRootLogin no; MaxAuthTries 4; X11Forwarding no; PasswordAuthentication no jika ada authorized_keys)\n# - Fail2ban (jail sshd dasar)\n# - Sysctl hardening konservatif\n# - NTP (systemd-timesyncd)\n# - Verifikasi akhir\n#\n# Penggunaan (disarankan uji dulu via audit):\n#   bash /home/hades/vm-test/vps-sec-check.sh --all --no-color | cat\n#   sudo bash /home/hades/vm-test/harden-server.sh\n#\nset -euo pipefail\n\nlog_info()  { printf \"\\033[36m[INFO]\\033[0m %s\\n\" \"$*\"; }\nlog_warn()  { printf \"\\033[33m[WARN]\\033[0m %s\\n\" \"$*\"; }\nlog_ok()    { printf \"\\033[32m[ OK ]\\033[0m %s\\n\" \"$*\"; }\nlog_crit()  { printf \"\\033[31m[CRIT]\\033[0m %s\\n\" \"$*\"; }\n\nrequire_root_or_sudo() {\n  if [[ $(id -u) -eq 0 ]]; then\n    SUDO=\"\"\n  else\n    if command -v sudo >/dev/null 2>&1; then\n      SUDO=\"sudo\"\n    else\n      log_crit \"Skrip butuh hak root. Install sudo atau jalankan sebagai root.\"\n      exit 1\n    fi\n  fi\n}\n\ndetect_os() {\n  if [[ -r /etc/os-release ]]; then\n    # shellcheck disable=SC1091\n    . /etc/os-release\n    OS_ID=${ID:-}\n    OS_LIKE=${ID_LIKE:-}\n  else\n    OS_ID=\"\"; OS_LIKE=\"\"\n  fi\n  if ! command -v apt-get >/dev/null 2>&1; then\n    log_crit \"apt-get tidak ditemukan. Skrip ini ditujukan untuk Debian/Ubuntu.\"\n    exit 1\n  fi\n  case \"$OS_ID\" in\n    ubuntu|debian) : ;; # ok\n    *)\n      if [[ \"$OS_LIKE\" == *debian* ]]; then\n        :\n      else\n        log_warn \"OS tidak terdeteksi sebagai Debian/Ubuntu. Melanjutkan dengan asumsi kompatibel apt.\"\n      fi\n      ;;\n  esac\n  log_ok \"OS: ${PRETTY_NAME:-$OS_ID} (apt)\"\n}\n\napt_update_upgrade() {\n  log_info \"Update & upgrade paket (non-interaktif) ...\"\n  $SUDO env DEBIAN_FRONTEND=noninteractive apt-get update -y\n  $SUDO env DEBIAN_FRONTEND=noninteractive apt-get upgrade -y\n}\n\nensure_pkgs() {\n  local pkgs=(\"$@\")\n  log_info \"Memastikan paket terpasang: ${pkgs[*]}\"\n  $SUDO env DEBIAN_FRONTEND=noninteractive apt-get install -y \"${pkgs[@]}\"\n}\n\nbackup_file() {\n  local f=\"$1\"\n  if [[ -f \"$f\" ]]; then\n    local bak=\"${f}.$(date +%F-%H%M%S).bak\"\n    $SUDO cp -a \"$f\" \"$bak\"\n    log_ok \"Backup: $bak\"\n  fi\n}\n\nconfigure_unattended_upgrades() {\n  log_info \"Mengaktifkan unattended-upgrades ...\"\n  ensure_pkgs unattended-upgrades apt-listchanges update-notifier-common\n  # aktifkan unattended upgrades via dpkg-reconfigure\n  $SUDO dpkg-reconfigure -f noninteractive unattended-upgrades || true\n  # jadwal dan reboot otomatis\n  local cfg=\"/etc/apt/apt.conf.d/20auto-upgrades\"\n  backup_file \"$cfg\"\n  $SUDO bash -lc 'cat > /etc/apt/apt.conf.d/20auto-upgrades <<EOF\nAPT::Periodic::Update-Package-Lists \"1\";\nAPT::Periodic::Unattended-Upgrade \"1\";\nUnattended-Upgrade::Automatic-Reboot \"true\";\nUnattended-Upgrade::Automatic-Reboot-Time \"03:30\";\nEOF'\n  log_ok \"Unattended upgrades dikonfigurasi\"\n}\n\nconfigure_ufw() {\n  log_info \"Mengkonfigurasi UFW ...\"\n  ensure_pkgs ufw\n  # Kebijakan dasar\n  $SUDO ufw --force reset >/dev/null 2>&1 || true\n  $SUDO ufw default deny incoming\n  $SUDO ufw default allow outgoing\n  # Izinkan layanan umum\n  $SUDO ufw allow OpenSSH\n  $SUDO ufw allow 80,443/tcp\n  # Aktifkan tanpa prompt\n  $SUDO ufw --force enable\n  log_ok \"UFW aktif dengan kebijakan minimal\"\n}\n\nconfigure_ssh_hardening() {\n  log_info \"SSH hardening ...\"\n  ensure_pkgs openssh-server\n  local cfg=\"/etc/ssh/sshd_config\"\n  backup_file \"$cfg\"\n  # Set nilai default yang aman\n  $SUDO bash -lc 'cfg=/etc/ssh/sshd_config;\n    if grep -qE \"^#?PermitRootLogin\" \"$cfg\"; then sed -ri \"s/^#?PermitRootLogin.*/PermitRootLogin no/\" \"$cfg\"; else echo \"PermitRootLogin no\" | tee -a \"$cfg\" >/dev/null; fi\n    if grep -qE \"^#?MaxAuthTries\" \"$cfg\"; then sed -ri \"s/^#?MaxAuthTries.*/MaxAuthTries 4/\" \"$cfg\"; else echo \"MaxAuthTries 4\" | tee -a \"$cfg\" >/dev/null; fi\n    if grep -qE \"^#?X11Forwarding\" \"$cfg\"; then sed -ri \"s/^#?X11Forwarding.*/X11Forwarding no/\" \"$cfg\"; else echo \"X11Forwarding no\" | tee -a \"$cfg\" >/dev/null; fi'\n\n  # Nonaktifkan password auth hanya jika ditemukan authorized_keys non-kosong\n  local have_keys=0\n  if [[ -s /root/.ssh/authorized_keys ]]; then have_keys=1; fi\n  # Cari pada seluruh home user\n  while IFS=: read -r user _ uid _ _ home shell; do\n    [[ \"$uid\" -ge 1000 ]] || continue\n    [[ -d \"$home/.ssh\" && -s \"$home/.ssh/authorized_keys\" ]] && have_keys=1\n  done < /etc/passwd\n\n  if [[ $have_keys -eq 1 ]]; then\n    log_info \"Authorized keys terdeteksi — menonaktifkan PasswordAuthentication.\"\n    $SUDO bash -lc 'cfg=/etc/ssh/sshd_config; if grep -qE \"^#?PasswordAuthentication\" \"$cfg\"; then sed -ri \"s/^#?PasswordAuthentication.*/PasswordAuthentication no/\" \"$cfg\"; else echo \"PasswordAuthentication no\" | tee -a \"$cfg\" >/dev/null; fi'\n  else\n    log_warn \"Tidak menemukan authorized_keys. PasswordAuthentication tetap diaktifkan untuk mencegah lockout.\"\n  fi\n\n  # Validasi & restart\n  if $SUDO sshd -t 2>/dev/null; then\n    $SUDO systemctl restart sshd || $SUDO systemctl restart ssh || true\n    log_ok \"Konfigurasi SSH diterapkan\"\n  else\n    log_crit \"Konfigurasi SSH tidak valid. Mengembalikan dari backup.\"\n    $SUDO cp -a \"$cfg\".bak \"$cfg\" || true\n    exit 1\n  fi\n}\n\nconfigure_fail2ban() {\n  log_info \"Mengkonfigurasi fail2ban ...\"\n  ensure_pkgs fail2ban\n  local jail=\"/etc/fail2ban/jail.local\"\n  backup_file \"$jail\"\n  $SUDO bash -lc 'cat > /etc/fail2ban/jail.local <<EOF\n[sshd]\nenabled = true\nport = ssh\nfilter = sshd\nmaxretry = 5\nfindtime = 10m\nbantime = 1h\nbanaction = ufw\nEOF'\n  $SUDO systemctl enable --now fail2ban\n  log_ok \"fail2ban aktif\"\n}\n\nconfigure_sysctl() {\n  log_info \"Menerapkan sysctl hardening ...\"\n  local f=\"/etc/sysctl.d/99-vibeops.conf\"\n  backup_file \"$f\"\n  $SUDO bash -lc 'cat > /etc/sysctl.d/99-vibeops.conf <<EOF\nnet.ipv4.ip_forward=0\nnet.ipv4.conf.all.accept_source_route=0\nnet.ipv4.conf.all.send_redirects=0\nnet.ipv4.icmp_echo_ignore_broadcasts=1\nnet.ipv4.tcp_syncookies=1\nnet.ipv4.conf.all.rp_filter=1\nnet.ipv6.conf.all.accept_ra=0\nEOF'\n  $SUDO sysctl --system >/dev/null\n  log_ok \"sysctl diterapkan\"\n}\n\nenable_timesync() {\n  log_info \"Memastikan sinkronisasi waktu aktif ...\"\n  $SUDO systemctl enable --now systemd-timesyncd || true\n}\n\nverify_summary() {\n  echo\n  log_info \"Verifikasi ringkas:\"\n  $SUDO ufw status verbose | sed 's/^/[UFW] /' || true\n  $SUDO fail2ban-client status 2>/dev/null | sed 's/^/[F2B] /' || true\n  $SUDO fail2ban-client status sshd 2>/dev/null | sed 's/^/[F2B] /' || true\n  bash /home/hades/vm-test/vps-sec-check.sh --all --no-color | sed 's/^/[AUDIT] /' || true\n}\n\nmain() {\n  require_root_or_sudo\n  detect_os\n  apt_update_upgrade\n  configure_unattended_upgrades\n  configure_ufw\n  configure_ssh_hardening\n  configure_fail2ban\n  configure_sysctl\n  enable_timesync\n  verify_summary\n  log_ok \"Hardening selesai.\"\n}\n\nmain \"$@\"\n\n\n"
  },
  {
    "path": "vm-test/aktif-otp.sh",
    "content": "#!/usr/bin/env bash\n\n# aktif-otp.sh — Aktif/nonaktif OTP (TOTP) untuk SSH + tampilkan QR/URI (Ubuntu/Debian)\n#\n# Fitur:\n# - Mode OTP: off | optional | required\n# - Generate OTP secret untuk user (non-interaktif)\n# - Tampilkan OTP (secret + otpauth URI) dan QR di terminal (butuh qrencode)\n# - Status ringkas (PAM OTP & sshd -T)\n# - Mode interaktif (menu)\n#\n# Catatan:\n# - Menggunakan skrip utama: /home/hades/vm-test/ssh-config.sh untuk penerapan kebijakan secara konsisten\n# - Paket yang dibutuhkan: libpam-google-authenticator, qrencode (akan dipasang otomatis bila perlu)\n\nset -euo pipefail\n\nSSHCFG=\"/home/hades/vm-test/ssh-config.sh\"\nSUDO=\"\"\nif [[ $(id -u) -ne 0 ]]; then\n  if command -v sudo >/dev/null 2>&1; then SUDO=\"sudo\"; fi\nfi\n\nlog_info(){ printf \"\\033[36m[INFO]\\033[0m %s\\n\" \"$*\"; }\nlog_ok(){   printf \"\\033[32m[ OK ]\\033[0m %s\\n\" \"$*\"; }\nlog_warn(){ printf \"\\033[33m[WARN]\\033[0m %s\\n\" \"$*\"; }\nlog_err(){  printf \"\\033[31m[ERR ]\\033[0m %s\\n\" \"$*\"; }\n\nbackup_file(){\n  local f=\"$1\"\n  if [[ -f \"$f\" ]]; then\n    $SUDO cp -a \"$f\" \"$f.$(date +%F-%H%M%S).bak\"\n  fi\n}\n\nensure_pkg(){\n  local pkg\n  for pkg in \"$@\"; do\n    if command -v apt-get >/dev/null 2>&1; then\n      $SUDO env DEBIAN_FRONTEND=noninteractive apt-get update -y >/dev/null 2>&1 || true\n      $SUDO env DEBIAN_FRONTEND=noninteractive apt-get install -y \"$pkg\" >/dev/null 2>&1 || true\n    fi\n  done\n}\n\nget_home(){ getent passwd \"$1\" | awk -F: '{print $6}'; }\n\nensure_user_secret(){\n  # $1 = username; generates ~/.google_authenticator if missing\n  local user=\"$1\" home\n  home=$(get_home \"$user\")\n  [[ -z \"$home\" ]] && { log_err \"User $user tidak ditemukan\"; return 1; }\n  if [[ ! -s \"$home/.google_authenticator\" ]]; then\n    ensure_pkg libpam-google-authenticator\n    log_info \"Membuat secret OTP baru untuk $user ...\"\n    $SUDO -u \"$user\" -H google-authenticator -t -d -f -r 3 -R 30 -w 3 >/dev/null 2>&1 || true\n  fi\n  [[ -s \"$home/.google_authenticator\" ]]\n}\n\nget_secret(){\n  local user=\"$1\"\n  local home; home=$(get_home \"$user\")\n  [[ -z \"$home\" ]] && return 1\n  [[ -s \"$home/.google_authenticator\" ]] || return 1\n  head -n1 \"$home/.google_authenticator\" 2>/dev/null || true\n}\n\nprint_uri(){\n  local user=\"$1\"\n  ensure_user_secret \"$user\" || return 1\n  local secret; secret=$(get_secret \"$user\")\n  if [[ -z \"$secret\" ]]; then\n    log_warn \"Secret OTP untuk $user tidak ditemukan.\"\n    return 1\n  fi\n  local host; host=$(hostname)\n  local uri=\"otpauth://totp/${user}@${host}?secret=${secret}&issuer=${host}&digits=6&period=30\"\n  echo \"$secret\"\n  echo \"$uri\"\n}\n\ncurrent_code(){\n  local user=\"$1\"\n  local secret; secret=$(get_secret \"$user\")\n  if [[ -z \"$secret\" ]]; then\n    log_warn \"Secret OTP untuk $user tidak ditemukan.\"\n    return 1\n  fi\n  if ! command -v oathtool >/dev/null 2>&1; then\n    log_warn \"oathtool tidak terpasang; mencoba memasang...\"; ensure_pkg oathtool\n  fi\n  if command -v oathtool >/dev/null 2>&1; then\n    oathtool --totp -b \"$secret\"\n  else\n    log_err \"Tidak bisa menghasilkan kode TOTP (oathtool tidak tersedia).\"\n    return 1\n  fi\n}\n\nshow_qr(){\n  local user=\"$1\"\n  local secret uri\n  mapfile -t __arr < <(print_uri \"$user\") || { log_warn \"Gagal mengambil secret/URI untuk $user\"; return 1; }\n  secret=\"${__arr[0]:-}\"\n  uri=\"${__arr[1]:-}\"\n  [[ -z \"$secret\" || -z \"$uri\" ]] && { log_warn \"Secret/URI tidak ditemukan untuk $user\"; return 1; }\n  if command -v qrencode >/dev/null 2>&1; then\n    echo\n    echo \"QR (scan di aplikasi Authenticator):\"\n    echo \"$uri\" | qrencode -t ANSIUTF8\n    echo\n  else\n    log_warn \"qrencode tidak terpasang; mencoba memasang...\"; ensure_pkg qrencode\n    if command -v qrencode >/dev/null 2>&1; then\n      echo \"$uri\" | qrencode -t ANSIUTF8\n    else\n      log_warn \"Gagal memasang qrencode. Menyimpan PNG ke /tmp.\"\n      local png=\"/tmp/otp-${user}.png\"\n      if command -v base32 >/dev/null 2>&1; then :; fi\n      echo \"$uri\" | sed 's/.*/&/;q' >\"${png%.png}.uri.txt\"\n      log_info \"Simpan URI di: ${png%.png}.uri.txt (gunakan generator QR di perangkat lain)\"\n    fi\n  fi\n  # Tampilkan kode TOTP saat ini jika memungkinkan\n  local code\n  code=$(current_code \"$user\" 2>/dev/null || true)\n  if [[ -n \"$code\" ]]; then\n    echo \"Kode TOTP saat ini: $code (berlaku ~30 detik)\"\n  fi\n}\n\napply_mode(){\n  local mode=\"$1\" user_gen=\"${2:-}\"\n  case \"$mode\" in\n    off|optional|required) : ;;\n    *) log_err \"Mode tidak valid: $mode (gunakan: off|optional|required)\"; exit 1 ;;\n  esac\n  if [[ -n \"$user_gen\" ]]; then\n    $SUDO bash \"$SSHCFG\" --otp \"$mode\" --otp-user \"$user_gen\"\n  else\n    $SUDO bash \"$SSHCFG\" --otp \"$mode\"\n  fi\n}\n\nstatus(){\n  echo \"Status OTP & SSH (ringkas):\"\n  if grep -q 'pam_google_authenticator\\.so' /etc/pam.d/sshd 2>/dev/null; then\n    echo \"  OTP (PAM): ENABLED\"\n  else\n    echo \"  OTP (PAM): DISABLED\"\n  fi\n  if command -v sshd >/dev/null 2>&1; then\n    sshd -T 2>/dev/null | awk 'BEGIN{IGNORECASE=1} $1~/^(passwordauthentication|kbdinteractiveauthentication|authenticationmethods|port|permitrootlogin)$/ {printf \"  %-28s : %s\\n\", toupper($1), $2}'\n  fi\n}\n\napply_mfa_profile(){ # enable described MFA profile\n  # PAM: comment out @include common-auth and add pam_google_authenticator\n  local pam=\"/etc/pam.d/sshd\"\n  backup_file \"$pam\"\n  ensure_pkg libpam-google-authenticator\n  if grep -qE '^@include\\s+common-auth' \"$pam\"; then\n    $SUDO sed -ri 's/^@include\\s+common-auth/# @include common-auth (disabled for MFA)/' \"$pam\"\n  fi\n  if grep -q 'pam_google_authenticator\\.so' \"$pam\"; then\n    $SUDO sed -ri 's|^[[:space:]]*auth[[:space:]]+required[[:space:]]+pam_google_authenticator\\.so.*|auth required pam_google_authenticator.so|' \"$pam\"\n  else\n    $SUDO sed -i '1i auth required pam_google_authenticator.so' \"$pam\"\n  fi\n\n  # SSHD: enforce UsePAM, ChallengeResponse, and AuthenticationMethods per spec\n  local dropin=\"/etc/ssh/sshd_config.d/zz-vibeops-auth.conf\"\n  backup_file \"$dropin\"\n  # Ensure main config disables password auth to avoid precedence issues\n  if command -v bash >/dev/null 2>&1; then\n    $SUDO bash \"/home/hades/vm-test/ssh-config.sh\" --password off >/dev/null 2>&1 || true\n  fi\n  $SUDO bash -lc \"cat > '$dropin' <<'EOF'\n# Managed by VibeOps (MFA profile)\nChallengeResponseAuthentication yes\nUsePAM yes\nPasswordAuthentication no\nPubkeyAuthentication yes\nAuthenticationMethods publickey,keyboard-interactive:pam\nEOF\"\n  $SUDO systemctl restart ssh || $SUDO systemctl restart sshd || true\n}\n\ndisable_mfa_profile(){\n  local pam=\"/etc/pam.d/sshd\"\n  backup_file \"$pam\"\n  # Uncomment common-auth if commented by us\n  $SUDO sed -ri 's/^#\\s*@include\\s+common-auth/@include common-auth/' \"$pam\" || true\n  # Remove google_authenticator line\n  $SUDO sed -ri '/pam_google_authenticator\\.so/d' \"$pam\" || true\n  # Relax sshd drop-in to default optional OTP off\n  local dropin=\"/etc/ssh/sshd_config.d/zz-vibeops-auth.conf\"\n  backup_file \"$dropin\"\n  $SUDO bash -lc \"cat > '$dropin' <<'EOF'\n# Managed by VibeOps (MFA disabled)\nChallengeResponseAuthentication no\nUsePAM yes\nPasswordAuthentication yes\nPubkeyAuthentication yes\nAuthenticationMethods any\nEOF\"\n  $SUDO systemctl restart ssh || $SUDO systemctl restart sshd || true\n}\n\ninteractive(){\n  while true; do\n    clear || true\n    echo \"=== OTP / 2FA (TOTP) Menu ===\"\n    status\n    echo\n    echo \"Pilih aksi:\"\n    echo \"  1) OTP required (kunci + OTP wajib)\"\n    echo \"  2) OTP optional (kunci saja ATAU kunci + OTP)\"\n    echo \"  3) Matikan OTP\"\n    echo \"  4) Generate OTP untuk user + tampilkan QR & kode\"\n    echo \"  5) Tampilkan QR & kode untuk user (tanpa generate)\"\n    echo \"  6) Tampilkan kode TOTP saat ini untuk user\"\n    echo \"  7) Terapkan MFA profile (sesuai panduan)\"\n    echo \"  8) Nonaktifkan MFA profile\"\n    echo \"  9) Status\"\n    echo \"  0) Keluar\"\n    echo\n    read -r -p \"Pilihan [0-6]: \" ch || true\n    case \"${ch:-}\" in\n      1) read -r -p \"User (enter lewati generate): \" u || true; apply_mode required \"${u:-}\"; [[ -n \"${u:-}\" ]] && show_qr \"$u\"; read -r -p \"Enter...\" _ ;;\n      2) read -r -p \"User (enter lewati generate): \" u || true; apply_mode optional \"${u:-}\"; [[ -n \"${u:-}\" ]] && show_qr \"$u\"; read -r -p \"Enter...\" _ ;;\n      3) apply_mode off; read -r -p \"Enter...\" _ ;;\n    4) read -r -p \"User: \" u || true; [[ -z \"${u:-}\" ]] && { echo \"User kosong\"; read -r -p \"Enter...\" _; continue; }; ensure_user_secret \"$u\" || true; show_qr \"$u\"; read -r -p \"Enter...\" _ ;;\n      5) read -r -p \"User: \" u || true; [[ -z \"${u:-}\" ]] && { echo \"User kosong\"; read -r -p \"Enter...\" _; continue; }; show_qr \"$u\"; read -r -p \"Enter...\" _ ;;\n      6) read -r -p \"User: \" u || true; [[ -z \"${u:-}\" ]] && { echo \"User kosong\"; read -r -p \"Enter...\" _; continue; }; ensure_pkg oathtool; code=$(current_code \"$u\" || true); [[ -n \"$code\" ]] && echo \"Kode TOTP: $code\" || echo \"Gagal menghasilkan kode\"; read -r -p \"Enter...\" _ ;;\n      7) apply_mfa_profile; status; read -r -p \"Enter...\" _ ;;\n      8) disable_mfa_profile; status; read -r -p \"Enter...\" _ ;;\n      9) status; read -r -p \"Enter...\" _ ;;\n      0) break ;;\n      *) echo \"Pilihan tidak dikenal\"; sleep 0.7 ;;\n    esac\n  done\n}\n\nMODE=\"\"\nUSER_GEN=\"\"\nSHOWQR_USER=\"\"\nSHOWURI_USER=\"\"\nDO_STATUS=0\nDO_INTERACTIVE=0\n\nwhile [[ $# -gt 0 ]]; do\n  case \"$1\" in\n    --mode) MODE=\"$2\"; shift 2 ;;\n    --user) USER_GEN=\"$2\"; shift 2 ;;\n    --show-qr) SHOWQR_USER=\"$2\"; shift 2 ;;\n    --show-uri) SHOWURI_USER=\"$2\"; shift 2 ;;\n    --status) DO_STATUS=1; shift ;;\n    --interactive) DO_INTERACTIVE=1; shift ;;\n    -h|--help)\n      grep -E '^# ' \"$0\" | sed 's/^# //'; exit 0 ;;\n    *) log_warn \"Argumen tidak dikenal: $1\"; shift ;;\n  esac\ndone\n\nif [[ $DO_INTERACTIVE -eq 1 ]]; then\n  interactive; exit 0\nfi\n\n[[ -n \"$MODE\" ]] && apply_mode \"$MODE\" \"${USER_GEN:-}\"\n[[ -n \"$SHOWQR_USER\" ]] && show_qr \"$SHOWQR_USER\"\n[[ -n \"$SHOWURI_USER\" ]] && print_uri \"$SHOWURI_USER\"\n[[ $DO_STATUS -eq 1 ]] && status\n\nif [[ -z \"${MODE}${SHOWQR_USER}${SHOWURI_USER}\" && $DO_STATUS -eq 0 ]]; then\n  log_info \"Tidak ada aksi. Gunakan --interactive untuk menu.\"\nfi\n\n\n"
  },
  {
    "path": "setupOS/omakub.sh",
    "content": "#!/usr/bin/env bash\n#Omakub is only tested on fresh installations of Ubuntu 24.04 and 25.04. If you already have an installation, use a different version, or even a different distribution, you'll be on your own.)\nset -euo pipefail\n\nURL=\"https://omakub.org/install\"\n\n# Simpan sementara file sebelum eval (supaya bisa diperiksa kalau mau)\nTMP_FILE=$(mktemp)\nwget -qO- \"$TMP_FILE\" \"$URL\"\n\necho \"[INFO] Script berhasil diunduh ke $TMP_FILE\"\necho \"[INFO] Menjalankan script...\"\n\n# Jalankan script\neval \"$(cat \"$TMP_FILE\")\"\n\n# Hapus file sementara\nrm -f \"$TMP_FILE\"\n\n"
  },
  {
    "path": "setupOS/omarchy.sh",
    "content": "#!/usr/bin/env bash\n# Arch Linux using the tiling window manager Hyprland.\nwget -qO- https://omarchy.org/install | bash\n\n"
  },
  {
    "path": "vm-test/README.md",
    "content": "## VPS Hardening (Debian/Ubuntu)\n\nSkrip ini mengamankan server Debian/Ubuntu dengan langkah baseline yang aman, non-interaktif, dan idempotent.\n\n### Fitur\n- Deteksi OS (Debian/Ubuntu + apt)\n- Update & upgrade + aktifkan unattended-upgrades (reboot otomatis 03:30)\n- UFW: default deny incoming; allow OpenSSH + 80/tcp + 443/tcp\n- SSH hardening: PermitRootLogin no, MaxAuthTries 4, X11Forwarding no, auto nonaktif PasswordAuthentication bila ada authorized_keys\n- Fail2ban (jail sshd, banaction=ufw)\n- Sysctl hardening konservatif\n- NTP via systemd-timesyncd\n- Verifikasi akhir + audit\n\n### Prasyarat\n- Akses sudo/root ke server\n- Kunci SSH sudah diunggah ke user Anda (`~/.ssh/authorized_keys`) agar login password bisa dimatikan dengan aman (skrip akan cek otomatis; jika tidak ada, password login dibiarkan aktif agar tidak lockout)\n\n### Audit (opsional, rekomendasi)\nJalankan audit keamanan read-only:\n\n```bash\nbash /home/hades/vm-test/vps-sec-check.sh --all --no-color | cat\n```\n\n### Eksekusi hardening\n\n```bash\nchmod +x /home/hades/vm-test/harden-server.sh\nsudo /home/hades/vm-test/harden-server.sh\n```\n\nSkrip ini aman untuk dijalankan berulang kali (idempotent).\n\n### Verifikasi cepat\n- UFW:\n  ```bash\n  sudo ufw status verbose | cat\n  ```\n- Fail2ban (semua jail dan sshd):\n  ```bash\n  sudo fail2ban-client status | cat\n  sudo fail2ban-client status sshd | cat\n  ```\n- Audit ulang:\n  ```bash\n  bash /home/hades/vm-test/vps-sec-check.sh --all --no-color | cat\n  ```\n\n### Kustomisasi umum\n- Buka port tambahan (contoh 5432 dan 8080):\n  ```bash\n  sudo ufw allow 5432/tcp\n  sudo ufw allow 8080/tcp\n  ```\n- Atur kebijakan Fail2ban (durasi ban, dll) di `/etc/fail2ban/jail.local`:\n  ```ini\n  [sshd]\n  enabled = true\n  port = ssh\n  filter = sshd\n  maxretry = 5\n  findtime = 10m\n  bantime = 1h\n  banaction = ufw\n  ```\n  Terapkan ulang: `sudo fail2ban-client reload`\n- Jadwal & reboot unattended-upgrades di `/etc/apt/apt.conf.d/20auto-upgrades`:\n  ```\n  APT::Periodic::Update-Package-Lists \"1\";\n  APT::Periodic::Unattended-Upgrade \"1\";\n  Unattended-Upgrade::Automatic-Reboot \"true\";\n  Unattended-Upgrade::Automatic-Reboot-Time \"03:30\";\n  ```\n\n### Rollback cepat\n- SSH config dibackup saat skrip jalan, contoh:\n  - `/etc/ssh/sshd_config.YYYY-MM-DD-HHMMSS.bak`\n  Untuk mengembalikan:\n  ```bash\n  sudo cp -a /etc/ssh/sshd_config.YYYY-MM-DD-HHMMSS.bak /etc/ssh/sshd_config\n  sudo systemctl restart ssh || sudo systemctl restart sshd\n  ```\n- UFW dapat dinonaktifkan sementara:\n  ```bash\n  sudo ufw disable\n  ```\n\n### Catatan\n- Pada Ubuntu, nama unit layanan biasanya `ssh` (bukan `sshd`). Skrip sudah menangani hal ini otomatis.\n- Skrip akan mematikan password login hanya jika ditemukan kunci SSH agar Anda tidak terkunci dari server.\n- Beberapa layanan mungkin restart saat upgrade; ini normal.\n\n### Diagnostik berguna\n- Port yang listen: `ss -tulpen | cat`\n- Log Fail2ban: `sudo tail -n 200 /var/log/fail2ban.log`\n- Status layanan: `systemctl status <svc> | cat`\n- Log layanan: `sudo journalctl -u <svc> -n 100 --no-pager | cat`\n\n\n\n"
  },
  {
    "path": "vm-test/vps-securty.sh",
    "content": "#!/usr/bin/env bash\n\n# vps-securty.sh — Menu interaktif untuk audit & hardening VPS (Ubuntu/Debian)\n#\n# Fitur:\n# - Audit keamanan (read-only)\n# - Cek kapabilitas VPS (CPU, disk, network)\n# - Baseline hardening (unattended-upgrades, UFW, SSH hardening, fail2ban, sysctl)\n# - Konfigurasi SSH/OTP (wizard interaktif)\n# - Toggle password login (on/off)\n# - Manajemen UFW: buka port, lihat status\n# - Status Fail2ban\n# - Ringkasan konfigurasi SSH efektif\n#\n# Catatan: Aksi yang mengubah sistem membutuhkan sudo. Semua perintah idempotent.\n\nset -euo pipefail\n\nBASE=\"/home/hades/vm-test\"\nAUDIT_SCRIPT=\"$BASE/vps-sec-check.sh\"\nCHECK_SCRIPT=\"$BASE/vps-check.sh\"\nHARDEN_SCRIPT=\"$BASE/harden-server.sh\"\nSSHCFG_SCRIPT=\"$BASE/ssh-config.sh\"\nAKTIF_OTP_SCRIPT=\"$BASE/aktif-otp.sh\"\n\nCOLOR=1\nif [[ -t 1 ]]; then :; else COLOR=0; fi\nif [[ ${NO_COLOR:-0} -eq 1 ]]; then COLOR=0; fi\nif [[ $COLOR -eq 1 ]]; then\n  BOLD=\"\\033[1m\"; DIM=\"\\033[2m\"; RED=\"\\033[31m\"; GREEN=\"\\033[32m\"; YELLOW=\"\\033[33m\"; CYAN=\"\\033[36m\"; NC=\"\\033[0m\"\nelse\n  BOLD=\"\"; DIM=\"\"; RED=\"\"; GREEN=\"\"; YELLOW=\"\"; CYAN=\"\"; NC=\"\"\nfi\n\nSUDO=\"\"\nif [[ $(id -u) -ne 0 ]]; then\n  if command -v sudo >/dev/null 2>&1; then SUDO=\"sudo\"; fi\nfi\n\nheader() {\n  clear || true\n  echo -e \"${BOLD}${CYAN}┌──────────────────────────────────────────────────────────────┐${NC}\"\n  echo -e \"${BOLD}${CYAN}│${NC}           ${BOLD}VPS Security Menu — VibeOps${NC}                 ${BOLD}${CYAN}│${NC}\"\n  echo -e \"${BOLD}${CYAN}└──────────────────────────────────────────────────────────────┘${NC}\"\n  echo -e \"${DIM}OS: $(. /etc/os-release 2>/dev/null; echo ${PRETTY_NAME:-unknown})  Kernel: $(uname -r)  Host: $(hostname)${NC}\"\n  echo\n}\n\nok()   { echo -e \"${GREEN}[ OK ]${NC} $*\"; }\nwarn() { echo -e \"${YELLOW}[WARN]${NC} $*\"; }\nerr()  { echo -e \"${RED}[ERR ]${NC} $*\"; }\ninfo() { echo -e \"${CYAN}[INFO]${NC} $*\"; }\n\npause() { echo; read -r -p \"Tekan Enter untuk kembali ke menu...\" _ || true; }\n\nneed_file() {\n  local f=\"$1\" label=\"$2\"\n  [[ -x \"$f\" || -f \"$f\" ]] || { err \"$label tidak ditemukan: $f\"; return 1; }\n}\n\nrun_audit() {\n  header\n  info \"Menjalankan audit keamanan (read-only)...\"\n  need_file \"$AUDIT_SCRIPT\" \"Audit script\" || { pause; return; }\n  bash \"$AUDIT_SCRIPT\" --all --no-color | sed 's/^/  /'\n  pause\n}\n\nrun_vps_check() {\n  header\n  info \"Menjalankan cek kapabilitas VPS...\"\n  need_file \"$CHECK_SCRIPT\" \"VPS check script\" || { pause; return; }\n  bash \"$CHECK_SCRIPT\" --all --no-color | sed 's/^/  /'\n  pause\n}\n\nrun_hardening() {\n  header\n  info \"Baseline hardening akan mengaktifkan: unattended-upgrades, UFW, SSH hardening, fail2ban, sysctl\"\n  read -r -p \"Lanjutkan? (Y/n): \" ans || true; ans=${ans:-Y}\n  [[ \"$ans\" =~ ^[Yy]$ ]] || { warn \"Dibatalkan.\"; pause; return; }\n  need_file \"$HARDEN_SCRIPT\" \"Hardening script\" || { pause; return; }\n  $SUDO bash \"$HARDEN_SCRIPT\" | sed 's/^/  /'\n  pause\n}\n\nrun_ssh_wizard() {\n  header\n  info \"Membuka wizard konfigurasi SSH/OTP...\"\n  need_file \"$SSHCFG_SCRIPT\" \"SSH config script\" || { pause; return; }\n  $SUDO bash \"$SSHCFG_SCRIPT\" --interactive\n  pause\n}\n\ntoggle_password() {\n  header\n  echo \"Mode password login:\"\n  echo \"  1) Matikan password (disarankan)\"\n  echo \"  2) Aktifkan password (darurat)\"\n  echo\n  read -r -p \"Pilih [1-2]: \" c || true\n  case \"$c\" in\n    1)\n      need_file \"$SSHCFG_SCRIPT\" \"SSH config script\" || { pause; return; }\n      $SUDO bash \"$SSHCFG_SCRIPT\" --otp optional --password off | sed 's/^/  /'\n      ;;\n    2)\n      need_file \"$SSHCFG_SCRIPT\" \"SSH config script\" || { pause; return; }\n      $SUDO bash \"$SSHCFG_SCRIPT\" --otp off --password on | sed 's/^/  /'\n      warn \"PERINGATAN: Password login aktif. Pertimbangkan OTP required untuk keamanan ekstra.\"\n      ;;\n    *) warn \"Tidak ada perubahan.\" ;;\n  esac\n  pause\n}\n\nopen_ufw_port() {\n  header\n  info \"Buka port di UFW (contoh: 5432/tcp atau 8080)\"\n  read -r -p \"Masukkan port (format: 80 atau 8080/tcp): \" p || true\n  [[ -z \"${p:-}\" ]] && { warn \"Tidak ada input.\"; pause; return; }\n  $SUDO ufw allow \"$p\" && ok \"UFW: allow $p\" || err \"Gagal menambah aturan UFW\"\n  pause\n}\n\nshow_ufw_status() {\n  header\n  info \"Status UFW:\"\n  $SUDO ufw status verbose | sed 's/^/  /' || true\n  pause\n}\n\nshow_fail2ban_status() {\n  header\n  info \"Status Fail2ban:\"\n  if command -v fail2ban-client >/dev/null 2>&1; then\n    $SUDO fail2ban-client status | sed 's/^/  /'\n    echo\n    $SUDO fail2ban-client status sshd 2>/dev/null | sed 's/^/  /' || true\n  else\n    warn \"fail2ban tidak terpasang. Jalankan hardening untuk memasang.\"\n  fi\n  pause\n}\n\nshow_sshd_summary() {\n  header\n  info \"Ringkasan konfigurasi SSH efektif:\"\n  if command -v sshd >/dev/null 2>&1; then\n    sshd -T 2>/dev/null | awk 'BEGIN{IGNORECASE=1} $1~/^(port|permitrootlogin|passwordauthentication|pubkeyauthentication|maxauthtries|x11forwarding|kbdinteractiveauthentication|authenticationmethods)$/ {printf \"  %-30s : %s\\n\", toupper($1), $2}'\n    if grep -q 'pam_google_authenticator\\.so' /etc/pam.d/sshd 2>/dev/null; then\n      echo \"  OTP (PAM)                     : ENABLED\"\n    else\n      echo \"  OTP (PAM)                     : DISABLED\"\n    fi\n  else\n    warn \"sshd tidak ditemukan.\"\n  fi\n  pause\n}\n\notp_menu() {\n  header\n  info \"Membuka OTP/2FA manager (QR + setup) ...\"\n  need_file \"$AKTIF_OTP_SCRIPT\" \"OTP manager\" || { pause; return; }\n  $SUDO bash \"$AKTIF_OTP_SCRIPT\" --interactive\n}\n\nmain_menu() {\n  while true; do\n    header\n    echo -e \"${BOLD}Pilih aksi:${NC}\"\n    echo \"  1) Audit keamanan (read-only)\"\n    echo \"  2) Cek VPS (CPU/Disk/Net)\"\n    echo \"  3) Baseline hardening (otomatis)\"\n    echo \"  4) Konfigurasi SSH/OTP (wizard)\"\n    echo \"  5) Toggle password login (on/off)\"\n    echo \"  6) UFW: buka port\"\n    echo \"  7) UFW: status\"\n    echo \"  8) Fail2ban: status\"\n    echo \"  9) SSH: ringkasan konfigurasi\"\n    echo \" 10) SSH: OTP/2FA (menu)\"\n    echo \"  0) Keluar\"\n    echo\n    read -r -p \"Pilihan [0-9]: \" choice || true\n    case \"${choice:-}\" in\n      1) run_audit ;;\n      2) run_vps_check ;;\n      3) run_hardening ;;\n      4) run_ssh_wizard ;;\n      5) toggle_password ;;\n      6) open_ufw_port ;;\n      7) show_ufw_status ;;\n      8) show_fail2ban_status ;;\n      9) show_sshd_summary ;;\n      10) otp_menu ;;\n      0) echo; ok \"Selesai.\"; exit 0 ;;\n      *) warn \"Pilihan tidak dikenal.\"; sleep 0.8 ;;\n    esac\n  done\n}\n\nmain_menu\n\n\n"
  },
  {
    "path": "vm-test/ssh-config.sh",
    "content": "#!/usr/bin/env bash\n\n# ssh-config.sh — SSH hardening, nonaktif password login, dan opsional OTP (aman & idempotent)\n#\n# Fitur:\n# - Backup otomatis sshd_config dengan timestamp\n# - Set: PermitRootLogin no, PubkeyAuthentication yes, PasswordAuthentication no, MaxAuthTries 4, X11Forwarding no\n# - Opsi set port SSH\n# - Tambah public key ke user tertentu dengan permission yang benar\n# - Validasi konfigurasi (sshd -t) lalu restart service (ssh/sshd)\n# - Opsional update UFW untuk port SSH yang dipilih\n# - Mode interaktif: bantu input port, kunci publik, dan OTP (TOTP) opsional\n# - Ringkasan konfigurasi efektif sshd dan daftar kunci yang terdeteksi\n# - Validasi format public key, dukungan input dari file, dan mode dry-run\n#\n# Penggunaan:\n#   sudo bash /home/hades/vm-test/ssh-config.sh --force --port 22\n#   sudo bash /home/hades/vm-test/ssh-config.sh --user hades --pubkey \"ssh-ed25519 AAAA...\"\n#   sudo bash /home/hades/vm-test/ssh-config.sh --user hades --pubkey \"ssh-ed25519 AAAA...\" --port 2222 --allow-ufw\n#   sudo bash /home/hades/vm-test/ssh-config.sh --otp optional|required\n#   sudo bash /home/hades/vm-test/ssh-config.sh --interactive\n#   sudo bash /home/hades/vm-test/ssh-config.sh --summary\n#   sudo bash /home/hades/vm-test/ssh-config.sh --dry-run --user hades --pubkey-file /path/key.pub --port 2222 --otp optional\n#\n# Catatan:\n# - Default: skrip HANYA menonaktifkan password bila minimal satu authorized_keys ditemukan.\n# - Gunakan --force untuk memaksa nonaktif password meski belum ada authorized_keys (BERISIKO LOCKOUT!).\n\nset -euo pipefail\n\nlog_info() { printf \"\\033[36m[INFO]\\033[0m %s\\n\" \"$*\"; }\nlog_ok()   { printf \"\\033[32m[ OK ]\\033[0m %s\\n\" \"$*\"; }\nlog_warn() { printf \"\\033[33m[WARN]\\033[0m %s\\n\" \"$*\"; }\nlog_err()  { printf \"\\033[31m[ERR ]\\033[0m %s\\n\" \"$*\"; }\n\nSUDO=\"\"\nrequire_root_or_sudo() {\n  if [[ $(id -u) -eq 0 ]]; then\n    SUDO=\"\"\n  else\n    if command -v sudo >/dev/null 2>&1; then\n      SUDO=\"sudo\"\n    else\n      log_err \"Butuh hak root/sudo. Jalankan sebagai root atau install sudo.\"\n      exit 1\n    fi\n  fi\n}\n\nprint_keys_from_file() {\n  local file=\"$1\" label=\"$2\"\n  [[ -s \"$file\" ]] || return 0\n  while IFS= read -r line; do\n    [[ -z \"$line\" ]] && continue\n    local type b64 comment prefix\n    type=$(echo \"$line\" | awk '{print $1}')\n    b64=$(echo \"$line\" | awk '{print $2}')\n    comment=$(echo \"$line\" | cut -d' ' -f3-)\n    prefix=$(echo \"$b64\" | cut -c1-16)\n    echo \"  - ${label}: [$type] ${comment:-no-comment} (${prefix}...)\"\n  done < \"$file\"\n}\n\nprint_existing_keys() {\n  echo \"Kunci SSH yang terdeteksi (authorized_keys*):\"\n  local listed=0\n  # Cari semua file authorized_keys* non-kosong di /home/*/.ssh dan /root/.ssh\n  while IFS= read -r f; do\n    # Tentukan label user dari path\n    local user label\n    case \"$f\" in\n      /root/*) label=\"root\" ;;\n      /home/*) user=$(echo \"$f\" | awk -F/ '{print $3}'); label=\"$user\" ;;\n      *) label=\"unknown\" ;;\n    esac\n    print_keys_from_file \"$f\" \"$label\"\n    listed=1\n  done < <(find /home /root -maxdepth 3 -type f -name 'authorized_keys*' -size +0c 2>/dev/null)\n  [[ $listed -eq 0 ]] && echo \"  (tidak ditemukan)\"\n}\n\nensure_pkg() {\n  if command -v apt-get >/dev/null 2>&1; then\n    $SUDO env DEBIAN_FRONTEND=noninteractive apt-get update -y >/dev/null 2>&1 || true\n    $SUDO env DEBIAN_FRONTEND=noninteractive apt-get install -y \"$1\" >/dev/null 2>&1 || true\n  fi\n}\n\nprompt() { # $1=message $2=default\n  local msg=\"$1\" def=\"${2:-}\"\n  if [[ -n \"$def\" ]]; then\n    read -r -p \"$msg [$def]: \" ans || true\n    echo \"${ans:-$def}\"\n  else\n    read -r -p \"$msg: \" ans || true\n    echo \"$ans\"\n  fi\n}\n\nconfirm() { # returns 0 if yes\n  local msg=\"$1\"; local def=\"${2:-y}\"\n  local prompt_char=\"y/N\"; [[ \"$def\" == \"y\" ]] && prompt_char=\"Y/n\"\n  read -r -p \"$msg ($prompt_char): \" ans || true\n  ans=${ans:-$def}\n  [[ \"$ans\" == \"y\" || \"$ans\" == \"Y\" ]]\n}\n\nbackup_file() {\n  local f=\"$1\"\n  if [[ -f \"$f\" ]]; then\n    local bak=\"${f}.$(date +%F-%H%M%S).bak\"\n    $SUDO cp -a \"$f\" \"$bak\"\n    log_ok \"Backup: $bak\"\n  fi\n}\n\nhave_any_authorized_keys() {\n  local any\n  any=$(find /home /root -maxdepth 3 -type f -name 'authorized_keys*' -size +0c 2>/dev/null | head -n1 || true)\n  if [[ -n \"$any\" ]]; then echo 1; else echo 0; fi\n}\n\nadd_pubkey() {\n  local user=\"$1\"; shift\n  local pubkey=\"$1\"\n  if ! is_valid_pubkey \"$pubkey\"; then\n    log_err \"Public key tidak valid. Harus diawali ssh-ed25519/ssh-rsa/ecdsa-sha2-* dan berisi data base64.\"\n    exit 1\n  fi\n  local home\n  home=$(getent passwd \"$user\" | awk -F: '{print $6}')\n  if [[ -z \"$home\" || ! -d \"$home\" ]]; then\n    log_err \"Home untuk user '$user' tidak ditemukan\"; exit 1\n  fi\n  $SUDO mkdir -p \"$home/.ssh\"\n  $SUDO sh -c \"umask 077 && touch '$home/.ssh/authorized_keys'\"\n  if $SUDO grep -qxF \"$pubkey\" \"$home/.ssh/authorized_keys\" 2>/dev/null; then\n    log_info \"Public key sudah ada untuk $user\"\n  else\n    echo \"$pubkey\" | $SUDO tee -a \"$home/.ssh/authorized_keys\" >/dev/null\n    log_ok \"Public key ditambahkan ke $user\"\n  fi\n  $SUDO chown -R \"$user\":\"$user\" \"$home/.ssh\"\n  $SUDO chmod 700 \"$home/.ssh\"\n  $SUDO chmod 600 \"$home/.ssh/authorized_keys\"\n}\n\nset_sshd_option() {\n  local key=\"$1\"; shift\n  local value=\"$1\"; shift\n  local cfg=\"/etc/ssh/sshd_config\"\n  if $SUDO grep -qE \"^#?${key}([[:space:]]+|=)\" \"$cfg\"; then\n    $SUDO sed -ri \"s~^#?${key}([[:space:]]+|=).*~${key} ${value}~\" \"$cfg\"\n  else\n    printf \"\\n%s %s\\n\" \"$key\" \"$value\" | $SUDO tee -a \"$cfg\" >/dev/null\n  fi\n}\n\nrestart_ssh_service() {\n  if $SUDO sshd -t 2>/dev/null; then\n    $SUDO systemctl restart sshd 2>/dev/null || $SUDO systemctl restart ssh 2>/dev/null || true\n    log_ok \"SSH service direstart\"\n  else\n    log_err \"Konfigurasi SSH invalid (sshd -t gagal). Lihat backup lalu perbaiki.\"\n    exit 1\n  fi\n}\n\nallow_ufw_port() {\n  local port=\"$1\"\n  if command -v ufw >/dev/null 2>&1; then\n    $SUDO ufw allow \"$port\"/tcp >/dev/null 2>&1 || true\n    log_ok \"UFW diizinkan untuk port $port/tcp\"\n  fi\n}\n\nlimit_ufw_ssh() {\n  if command -v ufw >/dev/null 2>&1; then\n    $SUDO ufw limit OpenSSH >/dev/null 2>&1 || true\n    log_ok \"UFW rate-limit untuk OpenSSH diaktifkan\"\n  fi\n}\n\nis_valid_pubkey() {\n  local key=\"$1\"\n  [[ \"$key\" =~ ^(ssh\\-ed25519|ssh\\-rsa|ecdsa\\-sha2\\-nistp(256|384|521))\\s+[A-Za-z0-9\\+/=]+(\\s+.*)?$ ]]\n}\n\nread_pubkey_from_file() {\n  local path=\"$1\"\n  if [[ ! -r \"$path\" ]]; then\n    log_err \"File tidak dapat dibaca: $path\"; exit 1\n  fi\n  awk 'NF {print; exit}' \"$path\"\n}\n\nprint_effective_summary() {\n  echo \"Ringkasan konfigurasi sshd (efektif):\"\n  if command -v sshd >/dev/null 2>&1; then\n    sshd -T 2>/dev/null | awk 'BEGIN{IGNORECASE=1} $1~/^(port|permitrootlogin|passwordauthentication|pubkeyauthentication|maxauthtries|x11forwarding|kbdinteractiveauthentication|authenticationmethods)$/ {print \"  \" toupper($1) \": \" $2}'\n  else\n    echo \"  (sshd tidak ditemukan di PATH)\"\n  fi\n}\n\nconfigure_otp() { # $1 mode: off|optional|required, $2 user (optional)\n  local mode=\"$1\"; local user_for_otp=\"${2:-}\"\n  local pam_sshd=\"/etc/pam.d/sshd\"\n  case \"$mode\" in\n    off)\n      # Hapus baris pam_google_authenticator jika ada\n      if [[ -f \"$pam_sshd\" ]]; then\n        backup_file \"$pam_sshd\"\n        $SUDO sed -i '/pam_google_authenticator\\.so/d' \"$pam_sshd\"\n      fi\n      # Nonaktifkan KbdInteractive jika tidak diperlukan oleh hal lain\n      set_sshd_option KbdInteractiveAuthentication no\n      # Hapus AuthenticationMethods jika kita yang set sebelumnya\n      if $SUDO grep -qE '^AuthenticationMethods ' /etc/ssh/sshd_config 2>/dev/null; then\n        $SUDO sed -ri 's/^AuthenticationMethods .*/# AuthenticationMethods cleared/' /etc/ssh/sshd_config || true\n      fi\n      log_ok \"OTP dimatikan\"\n      return 0\n      ;;\n    optional|required)\n      ensure_pkg libpam-google-authenticator\n      backup_file \"$pam_sshd\"\n      local pam_line=\"auth required pam_google_authenticator.so\"\n      [[ \"$mode\" == \"optional\" ]] && pam_line=\"${pam_line} nullok\"\n      if $SUDO grep -q 'pam_google_authenticator.so' \"$pam_sshd\" 2>/dev/null; then\n        $SUDO sed -ri \"s|^[[:space:]]*auth[[:space:]]+required[[:space:]]+pam_google_authenticator\\.so.*|${pam_line}|\" \"$pam_sshd\" || true\n      else\n        # sisipkan di baris pertama\n        $SUDO sed -i \"1i ${pam_line}\" \"$pam_sshd\"\n      fi\n      set_sshd_option UsePAM yes\n      set_sshd_option KbdInteractiveAuthentication yes\n      if [[ \"$mode\" == \"required\" ]]; then\n        # Wajibkan 2FA: butuh publickey + OTP via PAM\n        set_sshd_option AuthenticationMethods \"publickey,keyboard-interactive:pam\"\n      else\n        # Optional: izinkan publickey saja ATAU publickey + OTP (tanpa password)\n        set_sshd_option AuthenticationMethods \"publickey publickey,keyboard-interactive:pam\"\n      fi\n\n      # Buat secret OTP untuk user bila diminta\n      if [[ -n \"$user_for_otp\" ]]; then\n        if getent passwd \"$user_for_otp\" >/dev/null; then\n          log_info \"Membuat konfigurasi TOTP untuk user $user_for_otp ...\"\n          ensure_pkg libpam-google-authenticator\n          # Non-interaktif: time-based, disallow multiple-use, rate limit 3/30s, window 3, non-confirm\n          $SUDO -u \"$user_for_otp\" -H google-authenticator -t -d -f -r 3 -R 30 -w 3 >/dev/null 2>&1 || true\n          local home\n          home=$(getent passwd \"$user_for_otp\" | awk -F: '{print $6}')\n          if [[ -s \"$home/.google_authenticator\" ]]; then\n            local secret uri\n            secret=$(head -n1 \"$home/.google_authenticator\" 2>/dev/null || true)\n            # Buat otpauth:// URI (tanpa issuer untuk kesederhanaan); user isi host\n            uri=\"otpauth://totp/${user_for_otp}@$(hostname)?secret=${secret}&digits=6&period=30\"\n            log_ok \"OTP secret untuk $user_for_otp: $secret\"\n            echo \"$uri\" | sed 's/^/[OTP-URI] /'\n          else\n            log_warn \"Tidak dapat membuat file ~/.google_authenticator untuk $user_for_otp.\"\n          fi\n        else\n          log_warn \"User $user_for_otp tidak ditemukan, lewati pembuatan OTP.\"\n        fi\n      fi\n      log_ok \"OTP ${mode} dikonfigurasi\"\n      ;;\n    *) log_err \"Mode OTP tidak dikenal: $mode\"; exit 1 ;;\n  esac\n}\n\n# Ensure a deterministic drop-in that enforces auth policy early in Include order\nwrite_sshd_dropin() {\n  # Args: $1=otp_mode(off|optional|required) $2=password_mode(on|off|\"\")\n  local otp_mode=\"$1\"; local pw_mode=\"${2:-}\"\n  # Use a highest precedence drop-in to override others\n  local dropin=\"/etc/ssh/sshd_config.d/zz-vibeops-auth.conf\"\n  backup_file \"$dropin\"\n  local pwline=\"PasswordAuthentication no\"\n  local kbd=\"KbdInteractiveAuthentication no\"\n  local authm=\"\"\n  case \"$otp_mode\" in\n    required)\n      kbd=\"KbdInteractiveAuthentication yes\"\n      authm='AuthenticationMethods publickey,keyboard-interactive:pam'\n      ;;\n    optional)\n      kbd=\"KbdInteractiveAuthentication yes\"\n      authm='AuthenticationMethods publickey publickey,keyboard-interactive:pam'\n      ;;\n    off)\n      : ;;\n  esac\n  if [[ \"$pw_mode\" == \"on\" ]]; then\n    pwline=\"PasswordAuthentication yes\"\n    # Allow passwords; do not force AuthenticationMethods combos\n    authm=\"\"\n    # If OTP is off, keep keyboard-interactive off; otherwise leave as set\n    [[ \"$otp_mode\" == \"off\" ]] && kbd=\"KbdInteractiveAuthentication no\"\n  elif [[ \"$pw_mode\" == \"off\" ]]; then\n    pwline=\"PasswordAuthentication no\"\n  fi\n  $SUDO bash -lc \"cat > '$dropin' <<EOF\n# Managed by VibeOps (auth policy)\n$pwline\n$kbd\nChallengeResponseAuthentication no\nUsePAM yes\nPubkeyAuthentication yes\nPermitRootLogin no\nMaxAuthTries 4\nX11Forwarding no\n$authm\nEOF\"\n}\n\n# Remove conflicting VibeOps drop-ins and any AuthenticationMethods across configs\npurge_conflicting_dropins() {\n  local f\n  for f in /etc/ssh/sshd_config.d/00-vibeops-auth.conf /etc/ssh/sshd_config.d/99-vibeops-auth.conf /etc/ssh/sshd_config.d/99-vibeops-hardening.conf; do\n    if [[ -f \"$f\" ]]; then\n      backup_file \"$f\"\n      $SUDO rm -f \"$f\"\n    fi\n  done\n}\n\nclean_auth_methods_globally() {\n  local f\n  for f in /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf; do\n    [[ -f \"$f\" ]] || continue\n    if grep -qE '^[[:space:]]*AuthenticationMethods[[:space:]]' \"$f\" 2>/dev/null; then\n      backup_file \"$f\"\n      $SUDO sed -ri 's/^[[:space:]]*AuthenticationMethods.*/# AuthenticationMethods removed by VibeOps/' \"$f\"\n    fi\n  done\n}\n\n# Arg parsing\nPORT=\"\"\nFORCE_DISABLE_PW=0\nTARGET_USER=\"\"\nTARGET_PUBKEY=\"\"\nALLOW_UFW=0\nOTP_MODE=\"off\" # off|optional|required\nINTERACTIVE=0\nLIST_KEYS=0\nSUMMARY_ONLY=0\nDRY_RUN=0\nPUBKEY_FILE=\"\"\nPASSWORD_MODE=\"\" # on|off|empty (no override)\nOTP_USER=\"\"\nOTP_STATUS_ONLY=0\nSHOW_OTP_USER=\"\"\n\nwhile [[ $# -gt 0 ]]; do\n  case \"$1\" in\n    --port)\n      PORT=\"$2\"; shift 2 ;;\n    --force)\n      FORCE_DISABLE_PW=1; shift ;;\n    --user)\n      TARGET_USER=\"$2\"; shift 2 ;;\n    --pubkey)\n      TARGET_PUBKEY=\"$2\"; shift 2 ;;\n    --allow-ufw)\n      ALLOW_UFW=1; shift ;;\n    --otp)\n      OTP_MODE=\"$2\"; shift 2 ;;\n    --interactive)\n      INTERACTIVE=1; shift ;;\n    --list-keys)\n      LIST_KEYS=1; shift ;;\n    --summary)\n      SUMMARY_ONLY=1; shift ;;\n    --dry-run)\n      DRY_RUN=1; shift ;;\n    --pubkey-file)\n      PUBKEY_FILE=\"$2\"; shift 2 ;;\n    --password)\n      PASSWORD_MODE=\"$2\"; shift 2 ;;\n    --otp-user)\n      OTP_USER=\"$2\"; shift 2 ;;\n    --otp-status)\n      OTP_STATUS_ONLY=1; shift ;;\n    --show-otp)\n      SHOW_OTP_USER=\"$2\"; shift 2 ;;\n    -h|--help)\n      grep -E '^# ' \"$0\" | sed 's/^# //'; exit 0 ;;\n    *) log_warn \"Argumen tidak dikenali: $1\"; shift ;;\n  esac\ndone\n\nrequire_root_or_sudo\nensure_pkg openssh-server\n\n# Summary only\nif [[ $SUMMARY_ONLY -eq 1 ]]; then\n  print_existing_keys\n  echo\n  print_effective_summary\n  # OTP status quick check\n  if grep -q 'pam_google_authenticator\\.so' /etc/pam.d/sshd 2>/dev/null; then\n    echo \"  OTP (PAM): ENABLED\"\n  else\n    echo \"  OTP (PAM): DISABLED\"\n  fi\n  exit 0\nfi\n\n# Interactive wizard\nif [[ $INTERACTIVE -eq 1 ]]; then\n  echo \"-- Mode interaktif --\"\n  echo\nprint_existing_keys\necho\necho \"Rekomendasi: tambahkan minimal satu public key sebelum mematikan password login.\"\necho \"Anda dapat menempelkan key langsung atau memilih file .pub yang sudah ada.\"\n  if confirm \"Tambah public key sekarang?\" y; then\n    TARGET_USER=$(prompt \"Username\" \"hades\")\n    if confirm \"Ambil dari file .pub?\" n; then\n      PUBKEY_FILE=$(prompt \"Path file public key\" \"\")\n      [[ -n \"$PUBKEY_FILE\" ]] && TARGET_PUBKEY=$(read_pubkey_from_file \"$PUBKEY_FILE\")\n    else\n      TARGET_PUBKEY=$(prompt \"Tempel public key (ssh-ed25519/ssh-rsa/ecdsa-sha2-*)\" \"\")\n    fi\n    if ! is_valid_pubkey \"${TARGET_PUBKEY:-}\"; then\n      log_err \"Public key tidak valid. Ulangi dengan key yang benar.\"; exit 1\n    fi\n  fi\n  if confirm \"Ganti port SSH? (disarankan hanya jika Anda sudah mengizinkan port baru di firewall)\" n; then\n    PORT=$(prompt \"Port SSH\" \"22\")\n  else\n    PORT=\"\"\n  fi\n  echo \"Aktifkan OTP (TOTP) untuk SSH? Pilih: 0=off, 1=optional (nullok), 2=required\"\n  sel=$(prompt \"Pilihan\" \"1\")\n  case \"$sel\" in\n    0) OTP_MODE=\"off\" ;;\n    1) OTP_MODE=\"optional\" ;;\n    2) OTP_MODE=\"required\" ;;\n    *) OTP_MODE=\"optional\" ;;\n  esac\n  if [[ \"$OTP_MODE\" != \"off\" ]] && confirm \"Generate OTP untuk user tertentu sekarang? (siapkan aplikasi Authenticator)\" y; then\n    TARGET_USER=${TARGET_USER:-$(prompt \"Username untuk OTP\" \"hades\")}\n  fi\n  if confirm \"Izinkan port di UFW (jika diubah)?\" y; then\n    ALLOW_UFW=1\n  fi\n  if [[ -z \"$PORT\" || \"$PORT\" == \"22\" ]]; then\n    confirm \"Aktifkan rate-limit UFW untuk OpenSSH? (mengurangi brute-force)\" y && limit_ufw_ssh || true\n  fi\nfi\n\nif [[ $LIST_KEYS -eq 1 ]]; then\n  print_existing_keys\nfi\n\nif [[ -n \"$PUBKEY_FILE\" && -z \"$TARGET_PUBKEY\" ]]; then\n  TARGET_PUBKEY=$(read_pubkey_from_file \"$PUBKEY_FILE\")\nfi\n\nif [[ -n \"$TARGET_USER\" && -n \"$TARGET_PUBKEY\" ]]; then\n  log_info \"Menambahkan public key untuk user $TARGET_USER ...\"\n  add_pubkey \"$TARGET_USER\" \"$TARGET_PUBKEY\"\nfi\n\nlocal_have_keys=$(have_any_authorized_keys)\nif [[ $local_have_keys -eq 0 && $FORCE_DISABLE_PW -eq 0 ]]; then\n  log_warn \"Tidak ada authorized_keys terdeteksi. Gunakan --user/--pubkey untuk menambahkan, atau --force untuk menonaktifkan password (BERISIKO).\"\nfi\n\nCFG=\"/etc/ssh/sshd_config\"\nbackup_file \"$CFG\"\n\n# Set opsi aman\nset_sshd_option PermitRootLogin no\nset_sshd_option PubkeyAuthentication yes\nset_sshd_option MaxAuthTries 4\nset_sshd_option X11Forwarding no\nset_sshd_option ChallengeResponseAuthentication no\nset_sshd_option UsePAM yes\n\n# Port jika diminta\nif [[ -n \"$PORT\" ]]; then\n  set_sshd_option Port \"$PORT\"\nfi\n\n# PasswordAuthentication\nif [[ -n \"$PASSWORD_MODE\" ]]; then\n  if [[ \"$PASSWORD_MODE\" == \"on\" ]]; then\n    set_sshd_option PasswordAuthentication yes\n    log_ok \"PasswordAuthentication enabled (ON)\"\n  else\n    set_sshd_option PasswordAuthentication no\n    log_ok \"PasswordAuthentication disabled (OFF)\"\n  fi\nelse\n  if [[ $local_have_keys -eq 1 || $FORCE_DISABLE_PW -eq 1 ]]; then\n    set_sshd_option PasswordAuthentication no\n    log_ok \"PasswordAuthentication disabled\"\n  else\n    log_warn \"PasswordAuthentication tetap AKTIF (untuk mencegah lockout). Tambahkan key lalu jalankan ulang skrip dengan --force.\"\n  fi\nfi\n\n# OTP configuration if requested\nconfigure_otp \"$OTP_MODE\" \"${TARGET_USER:-}\"\n\n# Enforce via highest precedence drop-in and purge conflicting settings\npurge_conflicting_dropins\nclean_auth_methods_globally\nwrite_sshd_dropin \"$OTP_MODE\" \"$PASSWORD_MODE\"\n\n# Dry-run exit before applying restart\nif [[ $DRY_RUN -eq 1 ]]; then\n  echo\n  log_info \"Dry-run: perubahan konfigurasi telah disiapkan tetapi layanan tidak direstart.\"\n  print_effective_summary\n  exit 0\nfi\n\nrestart_ssh_service\n\nif [[ -n \"$PORT\" && $ALLOW_UFW -eq 1 ]]; then\n  allow_ufw_port \"$PORT\"\nfi\n\nlog_info \"Konfigurasi efektif (ringkas):\"\nsshd -T 2>/dev/null | sed -n 's/^\\(port\\|permitrootlogin\\|passwordauthentication\\|pubkeyauthentication\\|maxauthtries\\|x11forwarding\\|kbdinteractiveauthentication\\|authenticationmethods\\) /\\U&/p' | sort\necho\nif [[ -n \"$SHOW_OTP_USER\" ]]; then\n  home=$(getent passwd \"$SHOW_OTP_USER\" | awk -F: '{print $6}')\n  if [[ -s \"$home/.google_authenticator\" ]]; then\n    secret=$(head -n1 \"$home/.google_authenticator\" 2>/dev/null || true)\n    echo \"OTP untuk $SHOW_OTP_USER: $secret\"\n    echo \"otpauth://totp/${SHOW_OTP_USER}@$(hostname)?secret=${secret}&digits=6&period=30\"\n  else\n    echo \"OTP untuk $SHOW_OTP_USER tidak ditemukan.\"\n  fi\nfi\necho \"Tips berikutnya:\"\necho \"- Pastikan Anda bisa login via kunci SSH sebelum memutus sesi saat ini.\"\necho \"- Simpan backup: /etc/ssh/sshd_config.*.bak untuk rollback cepat.\"\necho \"- Lihat docs: /home/hades/vm-test/docs/ssh-config.md\"\n\nlog_ok \"Selesai.\"\n\n\n"
  },
  {
    "path": "vm-test/vps-sec-check.sh",
    "content": "#!/usr/bin/env bash\n# vps-sec-check.sh — Audit keamanan VPS cepat dan komprehensif (read-only, non-intrusif)\n#\n# Penggunaan:\n#   bash vps-sec-check.sh --all\n# Opsi:\n#   --all | -a        : Jalankan semua cek\n#   --install         : Coba install utilitas opsional (tanpa interaksi)\n#   --no-color        : Nonaktifkan warna\n#   --help | -h       : Bantuan singkat\n#\n# Catatan:\n# - Skrip TIDAK mengubah konfigurasi. Semua cek bersifat baca saja.\n# - Beberapa cek memerlukan utilitas opsional (sshd, ss, getenforce, apparmor_status, dll).\n#   Gunakan --install untuk mencoba memasang bila belum ada.\n\nset -u\n\nCOLOR=1\nfor arg in \"$@\"; do [[ \"$arg\" == \"--no-color\" ]] && COLOR=0; done\nif [[ $COLOR -eq 1 ]]; then\n  BOLD=\"\\033[1m\"; DIM=\"\\033[2m\"; RED=\"\\033[31m\"; GREEN=\"\\033[32m\"; YELLOW=\"\\033[33m\"; CYAN=\"\\033[36m\"; NC=\"\\033[0m\"\nelse\n  BOLD=\"\"; DIM=\"\"; RED=\"\"; GREEN=\"\"; YELLOW=\"\"; CYAN=\"\"; NC=\"\"\nfi\n\nheader() { echo -e \"${BOLD}$1${NC}\"; }\ninfo()   { echo -e \"${CYAN}$1${NC}\"; }\nok()     { echo -e \"${GREEN}$1${NC}\"; }\nwarn()   { echo -e \"${YELLOW}$1${NC}\"; }\ncrit()   { echo -e \"${RED}$1${NC}\"; }\n\nHAS() { command -v \"$1\" >/dev/null 2>&1; }\n\nALLOW_INSTALL=0\nDO_ALL=0\n\nif [[ $# -eq 0 ]]; then DO_ALL=1; fi\n\nfor arg in \"$@\"; do\n  case \"$arg\" in\n    --all|-a) DO_ALL=1 ;;\n    --install) ALLOW_INSTALL=1 ;;\n    --help|-h)\n      sed -n '2,60p' \"$0\"; exit 0;;\n    --no-color) ;; # handled above\n    *) warn \"Opsi tidak dikenal: $arg\" ;;\n  esac\ndone\n\ndetect_pkg() {\n  if HAS apt-get; then echo apt; return; fi\n  if HAS dnf; then echo dnf; return; fi\n  if HAS yum; then echo yum; return; fi\n  if HAS pacman; then echo pacman; return; fi\n  echo \"\"\n}\n\nensure_pkg() {\n  local bin=\"$1\"; local pkg=\"${2:-$1}\"\n  if HAS \"$bin\"; then return 0; fi\n  [[ $ALLOW_INSTALL -eq 0 ]] && return 1\n  local mgr; mgr=$(detect_pkg)\n  [[ -z \"$mgr\" ]] && return 1\n  info \"Menginstall $pkg (butuh sudo) ...\"\n  case \"$mgr\" in\n    apt) sudo apt-get update -y && sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \"$pkg\" ;;\n    dnf) sudo dnf install -y \"$pkg\" ;;\n    yum) sudo yum install -y \"$pkg\" ;;\n    pacman) sudo pacman -Sy --noconfirm \"$pkg\" ;;\n  esac\n  HAS \"$bin\"\n}\n\nhr() { echo -e \"${DIM}------------------------------------------------------------------------${NC}\"; }\n\n# Koleksi temuan untuk ringkasan\nISSUES_CRIT=()\nISSUES_WARN=()\nadd_crit() { ISSUES_CRIT+=(\"$1\"); crit \"[CRIT] $1\"; }\nadd_warn() { ISSUES_WARN+=(\"$1\"); warn \"[WARN] $1\"; }\n\nsection_system() {\n  header \"[1] Informasi Sistem\"\n  hr\n  echo \"Tanggal          : $(date -Is)\"\n  echo \"Hostname         : $(hostname)\"\n  if [[ -r /etc/os-release ]]; then\n    . /etc/os-release\n    echo \"OS               : ${PRETTY_NAME:-unknown}\"\n  else\n    echo \"OS               : $(uname -s)\"\n  fi\n  echo \"Kernel           : $(uname -r)\"\n  echo \"Arsitektur       : $(uname -m)\"\n  if HAS systemd-detect-virt; then\n    echo \"Virtualisasi     : $(systemd-detect-virt 2>/dev/null || echo unknown)\"\n  fi\n  echo \"Uptime           : $(uptime -p 2>/dev/null || true)\"\n  hr\n}\n\nsection_updates() {\n  header \"[2] Status Pembaruan Keamanan\"\n  hr\n  local mgr; mgr=$(detect_pkg)\n  case \"$mgr\" in\n    apt)\n      if HAS apt; then\n        local upg security_count all_count\n        upg=$(apt list --upgradable 2>/dev/null | grep -v \"Listing...\" || true)\n        all_count=$(echo \"$upg\" | sed '/^$/d' | wc -l | tr -d ' ')\n        security_count=$(echo \"$upg\" | grep -i security | wc -l | tr -d ' ')\n        echo \"Paket dapat diupgrade: $all_count (keamanan: $security_count)\"\n        if [[ \"$all_count\" -gt 0 ]]; then add_warn \"Ada paket yang belum diupgrade ($all_count).\"; fi\n        if [[ \"$security_count\" -gt 0 ]]; then add_crit \"Ada pembaruan keamanan yang tertunda ($security_count).\"; fi\n      fi\n      ;;\n    dnf|yum)\n      if HAS yum || HAS dnf; then\n        local count\n        count=$( (yum check-update -q || dnf check-update -q || true) | sed -n '/^Obsoleting/,$d; /^[A-Za-z0-9].*\\.[a-z]/p' | wc -l | tr -d ' ')\n        echo \"Paket dapat diupgrade: $count\"\n        [[ \"$count\" -gt 0 ]] && add_warn \"Ada paket yang belum diupgrade ($count).\"\n      fi\n      ;;\n    pacman)\n      if HAS checkupdates; then\n        local count\n        count=$(checkupdates 2>/dev/null | wc -l | tr -d ' ')\n        echo \"Paket dapat diupgrade: $count\"\n        [[ \"$count\" -gt 0 ]] && add_warn \"Ada paket yang belum diupgrade ($count).\"\n      else\n        warn \"checkupdates tidak tersedia (pacman-contrib).\"\n      fi\n      ;;\n    *)\n      warn \"Manajer paket tidak dikenali; lewati.\"\n      ;;\n  esac\n  hr\n}\n\nsection_firewall() {\n  header \"[3] Firewall\"\n  hr\n  local any=0\n  if HAS ufw; then\n    any=1\n    echo \"UFW status:\"\n    ufw status verbose 2>/dev/null | sed 's/^/  /'\n    ufw status | grep -qi inactive && add_warn \"UFW tidak aktif.\"\n  fi\n  if HAS firewall-cmd; then\n    any=1\n    echo \"firewalld: $(firewall-cmd --state 2>/dev/null || echo unknown)\"\n    firewall-cmd --list-all 2>/dev/null | sed 's/^/  /'\n  fi\n  if HAS iptables; then\n    any=1\n    echo \"iptables (filter):\"\n    iptables -S 2>/dev/null | sed 's/^/  /'\n  fi\n  if [[ $any -eq 0 ]]; then\n    add_warn \"Tidak ada firewall terdeteksi (ufw/firewalld/iptables). Pertimbangkan mengaktifkan firewall.\"\n  fi\n  hr\n}\n\nsection_ssh() {\n  header \"[4] Konfigurasi SSHD\"\n  hr\n  local has_sshd=0\n  if HAS sshd || ensure_pkg ssh; then has_sshd=1; fi\n\n  if [[ $has_sshd -eq 1 ]]; then\n    local cfg\n    cfg=$( (sshd -T 2>/dev/null) || true )\n    if [[ -n \"$cfg\" ]]; then\n      echo \"$cfg\" | sed 's/^/  /' | head -n 20 >/dev/null # quiet linter; real check below\n      local port prl paw pka maxtry x11\n      port=$(echo \"$cfg\" | sed -n 's/^port //p' | head -1)\n      prl=$(echo \"$cfg\" | sed -n 's/^permitrootlogin //p' | head -1)\n      paw=$(echo \"$cfg\" | sed -n 's/^passwordauthentication //p' | head -1)\n      pka=$(echo \"$cfg\" | sed -n 's/^pubkeyauthentication //p' | head -1)\n      maxtry=$(echo \"$cfg\" | sed -n 's/^maxauthtries //p' | head -1)\n      x11=$(echo \"$cfg\" | sed -n 's/^x11forwarding //p' | head -1)\n      echo \"Port                 : ${port:-unknown}\"\n      echo \"PermitRootLogin      : ${prl:-unknown}\"\n      echo \"PasswordAuthentication: ${paw:-unknown}\"\n      echo \"PubkeyAuthentication : ${pka:-unknown}\"\n      echo \"MaxAuthTries         : ${maxtry:-unknown}\"\n      echo \"X11Forwarding        : ${x11:-unknown}\"\n      [[ \"${prl,,}\" == \"yes\" ]] && add_crit \"PermitRootLogin yes (disarankan nonaktif).\"\n      [[ \"${paw,,}\" == \"yes\" ]] && add_warn \"PasswordAuthentication yes (disarankan pakai kunci).\"\n      [[ -n \"$maxtry\" && \"$maxtry\" -gt 6 ]] && add_warn \"MaxAuthTries terlalu tinggi ($maxtry).\"\n      [[ \"${x11,,}\" == \"yes\" ]] && add_warn \"X11Forwarding aktif (nonaktif jika tidak perlu).\"\n      [[ -n \"$port\" && \"$port\" == \"22\" ]] && warn \"SSH di port default 22 (opsional ubah).\"\n    else\n      warn \"Tidak bisa membaca konfigurasi efektif dengan 'sshd -T'.\"\n    fi\n  else\n    warn \"sshd tidak ditemukan.\"\n  fi\n  hr\n}\n\nsection_listen() {\n  header \"[5] Layanan Mendengarkan (Open Ports)\"\n  hr\n  if HAS ss || ensure_pkg iproute2 iproute2; then\n    ss -tulpen 2>/dev/null | sed 's/^/  /'\n    local wide\n    wide=$(ss -tulpen 2>/dev/null | awk '$1 ~ /LISTEN|UNCONN/ {print $5}' | grep -E \"(^|\\[::\\]|0.0.0.0):\" || true)\n    if [[ -n \"$wide\" ]]; then\n      add_warn \"Ada layanan listen pada semua interface (0.0.0.0/[::]). Pastikan memang diperlukan.\"\n    fi\n  else\n    warn \"Perintah ss tidak tersedia.\"\n  fi\n  hr\n}\n\nsection_fail2ban() {\n  header \"[6] Proteksi Brute-force (fail2ban)\"\n  hr\n  if HAS fail2ban-client; then\n    fail2ban-client status 2>/dev/null | sed 's/^/  /'\n  else\n    warn \"fail2ban tidak terpasang.\"\n  fi\n  hr\n}\n\nsection_authlog() {\n  header \"[7] Aktivitas Login Mencurigakan (auth log)\"\n  hr\n  local file=\"\"\n  if [[ -r /var/log/auth.log ]]; then file=/var/log/auth.log; fi\n  if [[ -z \"$file\" && -r /var/log/secure ]]; then file=/var/log/secure; fi\n  if [[ -z \"$file\" ]]; then warn \"auth.log/secure tidak dapat dibaca.\"; hr; return; fi\n  echo \"Sumber data: $file\"\n  local fails top\n  fails=$(grep -E \"Failed password|Invalid user|authentication failure\" \"$file\" 2>/dev/null | tail -n 200 || true)\n  if [[ -n \"$fails\" ]]; then\n    echo \"$fails\" | tail -n 5 | sed 's/^/  ... /'\n    top=$(echo \"$fails\" | grep -oE \"from ([0-9]{1,3}\\.){3}[0-9]{1,3}\" | awk '{print $2}' | sort | uniq -c | sort -nr | head -5)\n    if [[ -n \"$top\" ]]; then\n      echo \"IP gagal tersering (recent):\"\n      echo \"$top\" | sed 's/^/  /'\n      add_warn \"Terdeteksi percobaan brute-force SSH pada log.\"\n    fi\n  else\n    ok \"Tidak ada entri gagal login terbaru yang mencolok.\"\n  fi\n  hr\n}\n\nsection_users() {\n  header \"[8] Akun & Privilege\"\n  hr\n  echo \"Akun UID 0:\"\n  awk -F: '($3==0){print \"  \"$1\" : \"$7}' /etc/passwd\n  local uid0_count\n  uid0_count=$(awk -F: '($3==0){print $1}' /etc/passwd | wc -l | tr -d ' ')\n  [[ \"$uid0_count\" -gt 1 ]] && add_warn \"Lebih dari satu akun dengan UID 0.\"\n\n  echo \"Akun login interaktif (shell bukan nologin/false):\"\n  awk -F: '($7!~/nologin|false/){printf \"  %-20s %s\\n\", $1,$7}' /etc/passwd | sed 's/^/ /'\n\n  echo \"Grup sudo/wheel/admin:\"\n  for g in sudo wheel admin; do getent group \"$g\" 2>/dev/null; done | sed 's/^/  /'\n\n  echo \"Sudoers NOPASSWD:\"\n  grep -R \"NOPASSWD\" /etc/sudoers /etc/sudoers.d 2>/dev/null | sed 's/^/  /' || true\n  grep -R \"NOPASSWD\" /etc/sudoers /etc/sudoers.d >/dev/null 2>&1 && add_warn \"Ada aturan sudo NOPASSWD.\"\n  hr\n}\n\nsection_filesystems() {\n  header \"[9] Keamanan Filesystem\"\n  hr\n  if HAS findmnt; then\n    for m in / /tmp /var/tmp /home; do\n      if mountpoint -q \"$m\"; then\n        local opt\n        opt=$(findmnt -no OPTIONS \"$m\" 2>/dev/null)\n        printf \"Mount %s: %s\\n\" \"$m\" \"$opt\"\n        [[ \"$m\" =~ /tmp && \"$opt\" != *noexec* ]] && add_warn \"/tmp tanpa noexec.\"\n        [[ \"$opt\" != *nodev* ]] && warn \"$m tanpa nodev.\"\n        [[ \"$opt\" != *nosuid* ]] && warn \"$m tanpa nosuid.\"\n      fi\n    done\n  else\n    warn \"findmnt tidak tersedia.\"\n  fi\n  echo \"Direktori world-writable berisiko (subset):\"\n  for d in /tmp /var/tmp; do\n    echo \"  $d:\"\n    find \"$d\" -xdev -type d -perm -0002 -printf '    %p\\n' 2>/dev/null | head -n 10\n  done\n  hr\n}\n\nsection_sysctl() {\n  header \"[10] Hardening Kernel (sysctl)\"\n  hr\n  read_k() { sysctl -n \"$1\" 2>/dev/null || echo \"?\"; }\n  check_val() {\n    local key=\"$1\" expected=\"$2\" desc=\"$3\"\n    local v; v=$(read_k \"$key\")\n    printf \"%-40s : %s (disarankan: %s)\\n\" \"$key\" \"$v\" \"$expected\"\n    [[ \"$v\" == \"$expected\" ]] || add_warn \"$desc -> $key=$v (disarankan $expected)\"\n  }\n  check_val net.ipv4.ip_forward 0 \"IP forward IPv4 nonaktif kecuali router\"\n  check_val net.ipv4.conf.all.accept_source_route 0 \"Tolak source routing\"\n  check_val net.ipv4.conf.all.send_redirects 0 \"Tolak ICMP redirects\"\n  check_val net.ipv4.icmp_echo_ignore_broadcasts 1 \"Abaikan ICMP broadcast\"\n  check_val net.ipv4.tcp_syncookies 1 \"Aktifkan TCP SYN cookies\"\n  check_val net.ipv4.conf.all.rp_filter 1 \"Aktifkan reverse path filtering\"\n  if sysctl -a 2>/dev/null | grep -q net.ipv6; then\n    check_val net.ipv6.conf.all.accept_ra 0 \"Tolak Router Advertisements (server)\"\n  fi\n  hr\n}\n\nsection_mandatory_access() {\n  header \"[11] Mandatory Access Control (SELinux/AppArmor)\"\n  hr\n  local any=0\n  if HAS getenforce; then\n    any=1\n    echo \"SELinux: $(getenforce 2>/dev/null)\"\n  fi\n  if HAS sestatus; then\n    any=1\n    sestatus 2>/dev/null | sed 's/^/  /'\n  fi\n  if HAS apparmor_status; then\n    any=1\n    apparmor_status 2>/dev/null | sed 's/^/  /'\n  fi\n  if [[ $any -eq 0 ]]; then\n    warn \"SELinux/AppArmor tidak terdeteksi atau nonaktif.\"\n  fi\n  hr\n}\n\nsection_time_sync() {\n  header \"[12] Sinkronisasi Waktu\"\n  hr\n  local ok_any=0\n  if HAS timedatectl; then\n    timedatectl 2>/dev/null | sed 's/^/  /'\n  fi\n  if systemctl is-active --quiet systemd-timesyncd 2>/dev/null; then ok_any=1; echo \"systemd-timesyncd aktif\"; fi\n  if systemctl is-active --quiet chronyd 2>/dev/null; then ok_any=1; echo \"chronyd aktif\"; fi\n  if systemctl is-active --quiet ntp 2>/dev/null; then ok_any=1; echo \"ntpd aktif\"; fi\n  [[ $ok_any -eq 0 ]] && add_warn \"Layanan sinkronisasi waktu tidak terdeteksi aktif.\"\n  hr\n}\n\nsection_docker() {\n  header \"[13] Docker & Kontainer\"\n  hr\n  if HAS docker; then\n    docker info 2>/dev/null | sed -n '1,10p' | sed 's/^/  /'\n    echo \"Kontainer berjalan (ringkas):\"\n    docker ps --format '  {{.Names}} -> {{.Ports}}' 2>/dev/null || true\n    if [[ -S /var/run/docker.sock ]]; then\n      local perm owner\n      perm=$(stat -c %a /var/run/docker.sock 2>/dev/null || echo '?')\n      owner=$(stat -c %U:%G /var/run/docker.sock 2>/dev/null || echo '?')\n      echo \"docker.sock: $owner perm $perm\"\n      [[ \"$perm\" -gt 660 ]] && add_warn \"Permission docker.sock longgar ($perm).\"\n    fi\n  else\n    info \"Docker tidak terpasang.\"\n  fi\n  hr\n}\n\nsection_services_autostart() {\n  header \"[14] Layanan Otomatis (Enabled)\"\n  hr\n  if HAS systemctl; then\n    systemctl list-unit-files --type=service --state=enabled 2>/dev/null | sed 's/^/  /'\n  else\n    warn \"systemctl tidak tersedia.\"\n  fi\n  hr\n}\n\nsummary_report() {\n  header \"Ringkasan Temuan\"\n  hr\n  echo \"Kritis : ${#ISSUES_CRIT[@]}\"\n  for i in \"${ISSUES_CRIT[@]}\"; do echo \"  - $i\"; done\n  echo \"Peringatan : ${#ISSUES_WARN[@]}\"\n  for i in \"${ISSUES_WARN[@]}\"; do echo \"  - $i\"; done\n\n  echo\n  if [[ ${#ISSUES_CRIT[@]} -eq 0 && ${#ISSUES_WARN[@]} -eq 0 ]]; then\n    ok \"Tidak ada temuan berarti. VPS Anda tampak terkonfigurasi cukup aman.\"\n  else\n    warn \"Tinjau rekomendasi di atas untuk meningkatkan keamanan.\"\n  fi\n}\n\nmain() {\n  section_system\n  section_updates\n  section_firewall\n  section_ssh\n  section_listen\n  section_fail2ban\n  section_authlog\n  section_users\n  section_filesystems\n  section_sysctl\n  section_mandatory_access\n  section_time_sync\n  section_docker\n  section_services_autostart\n  summary_report\n}\n\nmain\n\n\n"
  },
  {
    "path": "password-generator/pass-generator.sh",
    "content": "#!/bin/bash\n\necho \"=== 🔐 Keyfile & Password Generator Interaktif ===\"\n\n# === Pilihan utama ===\necho \"Pilih opsi:\"\necho \"1) Buat Keyfile\"\necho \"2) Buat Password\"\necho \"3) Keduanya\"\nread -rp \"Masukkan pilihan [1/2/3]: \" mode\n\n# ======== 🔑 Fungsi: Generate Keyfile ========\ngenerate_keyfile() {\n  echo \"\"\n  echo \"=== 🛠️ Membuat Keyfile ===\"\n  read -rp \"📁 Lokasi folder keyfile (default: ~/.vault-keys): \" input_folder\n  KEYDIR=\"${input_folder:-$HOME/.vault-keys}\"\n\n  read -rp \"📄 Nama file keyfile (default: argon.key): \" input_name\n  KEYNAME=\"${input_name:-argon.key}\"\n\n  read -rp \"🔢 Ukuran keyfile dalam byte (default: 64): \" input_size\n  KEYSIZE=\"${input_size:-64}\"\n\n  KEYFILE=\"$KEYDIR/$KEYNAME\"\n  echo \"\"\n  echo \"📌 Keyfile akan dibuat di: $KEYFILE\"\n  echo \"📦 Ukuran: $KEYSIZE byte\"\n  read -rp \"Lanjutkan? (y/n): \" confirm\n  [[ \"$confirm\" != \"y\" ]] && echo \"❌ Dibatalkan.\" && return\n\n  mkdir -p \"$KEYDIR\"\n\n  if [[ -f \"$KEYFILE\" ]]; then\n    read -rp \"⚠️ File sudah ada. Overwrite? (y/n): \" overwrite\n    [[ \"$overwrite\" != \"y\" ]] && echo \"❌ Tidak jadi menimpa file yang ada.\" && return\n  fi\n\n  openssl rand -out \"$KEYFILE\" \"$KEYSIZE\"\n  chmod 600 \"$KEYFILE\"\n  echo \"✅ Keyfile berhasil dibuat!\"\n  ls -lh \"$KEYFILE\"\n}\n\n# ======== 🔐 Fungsi: Generate Password ========\ngenerate_password() {\n  echo \"\"\n  echo \"=== 🛠️ Membuat Password ===\"\n  read -rp \"🔢 Panjang password (default: 32): \" pass_len\n  pass_len=\"${pass_len:-32}\"\n\n  read -rp \"Gunakan simbol? (y/n, default: y): \" use_symbols\n  use_symbols=\"${use_symbols:-y}\"\n\n  if [[ \"$use_symbols\" == \"y\" ]]; then\n    charset='A-Za-z0-9!@#$%^&*()_+'\n  else\n    charset='A-Za-z0-9'\n  fi\n\n  PASSWORD=$(< /dev/urandom tr -dc \"$charset\" | head -c\"$pass_len\")\n\n  echo \"\"\n  echo \"🔐 Password kamu:\"\n  echo \"$PASSWORD\"\n  echo \"\"\n\n  read -rp \"Simpan ke file? (y/n): \" save_pw\n  if [[ \"$save_pw\" == \"y\" ]]; then\n    read -rp \"📄 Nama file (default: password.txt): \" pwfile\n    pwfile=\"${pwfile:-password.txt}\"\n    echo \"$PASSWORD\" > \"$pwfile\"\n    chmod 600 \"$pwfile\"\n    echo \"✅ Disimpan ke $pwfile\"\n  fi\n}\n\n# ======== Jalankan Sesuai Pilihan ========\ncase \"$mode\" in\n  1)\n    generate_keyfile\n    ;;\n  2)\n    generate_password\n    ;;\n  3)\n    generate_keyfile\n    generate_password\n    ;;\n  *)\n    echo \"❌ Pilihan tidak valid.\"\n    ;;\nesac\n"
  },
  {
    "path": "dev-tools/tmux-install.sh",
    "content": "#!/bin/bash\n# ===================================================================================\n# Skrip Instalasi Cerdas untuk Tmux, TPM, dan Konfigurasi Kustom.\n#\n# FITUR:\n# - Cek dependensi (tmux, git, zsh) & hanya instal yang belum ada.\n# - Output berwarna dan informatif untuk setiap langkah.\n# - Backup otomatis konfigurasi lama.\n# - Menggunakan persis konfigurasi .tmux.conf yang Anda berikan.\n# ===================================================================================\n\n# Hentikan eksekusi jika terjadi error\nset -e\n\n# Definisi Warna untuk output\nGREEN='\\033[1;32m'\nYELLOW='\\033[1;33m'\nBLUE='\\033[1;34m'\nNC='\\033[0m' # No Color\n\n# --- LANGKAH 1: PENGECEKAN & INSTALASI DEPENDENSI ---\necho -e \"${BLUE}▶️  Langkah 1: Memeriksa dependensi...${NC}\"\n\n# Deteksi Package Manager\nif command -v apt-get &> /dev/null; then\n    INSTALL_CMD=\"sudo apt-get install -y\"\n    PKG_MANAGER=\"apt\"\nelif command -v dnf &> /dev/null; then\n    INSTALL_CMD=\"sudo dnf install -y\"\n    PKG_MANAGER=\"dnf\"\nelif command -v pacman &> /dev/null; then\n    INSTALL_CMD=\"sudo pacman -S --noconfirm\"\n    PKG_MANAGER=\"pacman\"\nelse\n    echo -e \"\\033[1;31mError: Package manager tidak didukung (hanya apt, dnf, pacman).\\033[0m\"\n    exit 1\nfi\n\nREQUIRED_PKGS=\"tmux git zsh\"\nPACKAGES_TO_INSTALL=\"\"\n\nfor pkg in $REQUIRED_PKGS; do\n    if ! command -v $pkg &> /dev/null; then\n        echo -e \"${YELLOW}  - $pkg belum terinstal. Menambahkan ke daftar instalasi.${NC}\"\n        PACKAGES_TO_INSTALL+=\"$pkg \"\n    else\n        echo -e \"${GREEN}  ✅ $pkg sudah terinstal.${NC}\"\n    fi\ndone\n\nif [ -n \"$PACKAGES_TO_INSTALL\" ]; then\n    echo -e \"${BLUE}Menginstal paket yang dibutuhkan: $PACKAGES_TO_INSTALL...${NC}\"\n    $INSTALL_CMD $PACKAGES_TO_INSTALL\n    echo -e \"${GREEN}Instalasi dependensi selesai.${NC}\"\nelse\n    echo -e \"${GREEN}Semua dependensi sudah terpenuhi.${NC}\"\nfi\n\n# --- LANGKAH 2: INSTALASI TMUX PLUGIN MANAGER (TPM) ---\necho -e \"\\n${BLUE}▶️  Langkah 2: Memeriksa Tmux Plugin Manager (TPM)...${NC}\"\nTPM_DIR=\"$HOME/.tmux/plugins/tpm\"\n\nif [ -d \"$TPM_DIR\" ]; then\n    echo -e \"${GREEN}  ✅ TPM sudah terinstal di $TPM_DIR${NC}\"\nelse\n    echo -e \"${YELLOW}  - TPM belum ada. Menginstal...${NC}\"\n    git clone https://github.com/tmux-plugins/tpm \"$TPM_DIR\"\n    echo -e \"${GREEN}  ✅ TPM berhasil diinstal.${NC}\"\nfi\n\n# --- LANGKAH 3: MEMBUAT FILE KONFIGURASI .tmux.conf ---\necho -e \"\\n${BLUE}▶️  Langkah 3: Menyiapkan file konfigurasi ~/.tmux.conf...${NC}\"\nTMUX_CONF=\"$HOME/.tmux.conf\"\n\n# Backup konfigurasi yang sudah ada\nif [ -f \"$TMUX_CONF\" ]; then\n    echo -e \"${YELLOW}⚠️  File .tmux.conf sudah ada. Membuat backup ke ~/.tmux.conf.bak.$(date +%F-%T)${NC}\"\n    mv \"$TMUX_CONF\" \"$TMUX_CONF.bak.$(date +%F-%T)\"\nfi\n\n# Membuat file .tmux.conf baru dengan konten yang Anda berikan\n# Menggunakan \"EOL\" untuk memastikan konten disalin persis seperti aslinya\ncat > \"$TMUX_CONF\" << \"EOL\"\n# Konfigurasi Kustom\nunbind C-b\nset -g prefix `\n\nset -g base-index 1\nset -g pane-base-index 1\n\nbind-key ` last-window\nbind-key e send-prefix\nset -g mouse on\n\nset -g status-position bottom\nset -g status-bg colour234\nset -g status-fg colour137\nset -g status-left ''\nset -g status-right '#[fg=colour233,bg=colour241,bold] %d/%m #[fg=colour233,bg=colour245,bold] %H:%M:%S '\nset -g status-right-length 50\nset -g status-left-length 20\nsetw -g mode-keys vi\nsetw -g mouse on\n\nsetw -g window-status-current-format ' #I#[fg=colour250]:#[fg=colour255]#W#[fg=colour50]#F '\nsetw -g window-status-format ' #I#[fg=colour237]:#[fg=colour250]#W#[fg=colour244]#F '\n\nset-option -g history-limit 5000\n\n\n# Daftar Plugins\nset -g @plugin 'tmux-plugins/tpm'\nset -g @plugin 'tmux-plugins/tmux-sensible'\nset -g @plugin 'tmux-plugins/tmux-pain-control'\nset-option -g default-shell /bin/zsh\n\n\n# Pastikan selalu dibaris bawah\nrun -b '~/.tmux/plugins/tpm/tpm'\nEOL\n\necho -e \"${GREEN}  ✅ File ~/.tmux.conf berhasil dibuat dengan konfigurasi Anda.${NC}\"\n\n# --- SELESAI ---\necho -e \"\\n${GREEN}✨ Instalasi Selesai! ✨${NC}\"\necho \"------------------------------------------------------------------\"\necho -e \"Langkah terakhir yang SANGAT PENTING:\"\necho \"\"\necho -e \"1. Buka tmux dengan mengetikkan: ${YELLOW}tmux${NC}\"\necho \"\"\necho -e \"2. Di dalam sesi tmux, instal plugin dengan menekan:\"\necho -e \"   ${YELLOW}Prefix + I${NC} (Tekan tombol \\` lalu lepas, kemudian tekan I kapital)\"\necho \"\"\necho -e \"INGAT: ${YELLOW}Prefix${NC} Anda sekarang adalah tombol backtick ( \\` ), bukan Ctrl+b.\"\necho \"------------------------------------------------------------------\"\n"
  },
  {
    "path": "dev-tools/zsh-tmux.sh",
    "content": "#!/bin/bash\n# ===================================================================================\n#         SKRIP INSTALASI LENGKAP: Tmux + Oh My Zsh + Konfigurasi\n#\n# FITUR:\n# - Menginstal Tmux & Oh My Zsh.\n# - Cek dependensi (tmux, git, zsh, curl) & hanya instal yang belum ada.\n# - Menginstal plugin Oh My Zsh (termasuk eksternal seperti auto-suggestions).\n# - Membuat file .tmux.conf dan .zshrc kustom secara otomatis.\n# - Output berwarna dan informatif untuk setiap langkah.\n# - Backup otomatis konfigurasi lama.\n# ===================================================================================\n\n# Hentikan eksekusi jika terjadi error\nset -e\n\n# Definisi Warna untuk output\nGREEN='\\033[1;32m'\nYELLOW='\\033[1;33m'\nBLUE='\\033[1;34m'\nNC='\\033[0m' # No Color\n\necho -e \"${BLUE}=====================================================${NC}\"\necho -e \"${BLUE}  Memulai Setup Terminal Lengkap (Tmux + Oh My Zsh)  ${NC}\"\necho -e \"${BLUE}=====================================================${NC}\"\n\n\n# --- LANGKAH 1: PENGECEKAN & INSTALASI DEPENDENSI ---\necho -e \"\\n${BLUE}▶️  Langkah 1: Memeriksa dependensi utama...${NC}\"\n\nif command -v apt-get &> /dev/null; then\n    INSTALL_CMD=\"sudo apt-get install -y\"\nelif command -v dnf &> /dev/null; then\n    INSTALL_CMD=\"sudo dnf install -y\"\nelif command -v pacman &> /dev/null; then\n    INSTALL_CMD=\"sudo pacman -S --noconfirm\"\nelse\n    echo -e \"\\033[1;31mError: Package manager tidak didukung (hanya apt, dnf, pacman).\\033[0m\"\n    exit 1\nfi\n\nREQUIRED_PKGS=\"tmux git zsh curl\"\nPACKAGES_TO_INSTALL=\"\"\nfor pkg in $REQUIRED_PKGS; do\n    if ! command -v $pkg &> /dev/null; then\n        PACKAGES_TO_INSTALL+=\"$pkg \"\n    else\n        echo -e \"${GREEN}  ✅ $pkg sudah terinstal.${NC}\"\n    fi\ndone\n\nif [ -n \"$PACKAGES_TO_INSTALL\" ]; then\n    echo -e \"${YELLOW}Menginstal paket yang dibutuhkan: $PACKAGES_TO_INSTALL...${NC}\"\n    $INSTALL_CMD $PACKAGES_TO_INSTALL\nelse\n    echo -e \"${GREEN}Semua dependensi utama sudah terpenuhi.${NC}\"\nfi\n\n\n# --- LANGKAH 2: SETUP TMUX (TPM & Konfigurasi) ---\necho -e \"\\n${BLUE}▶️  Langkah 2: Menyiapkan Tmux...${NC}\"\n\n# Instalasi TPM\nTPM_DIR=\"$HOME/.tmux/plugins/tpm\"\nif [ -d \"$TPM_DIR\" ]; then\n    echo -e \"${GREEN}  ✅ Tmux Plugin Manager (TPM) sudah ada.${NC}\"\nelse\n    echo -e \"${YELLOW}  - Menginstal TPM...${NC}\"\n    git clone https://github.com/tmux-plugins/tpm \"$TPM_DIR\"\nfi\n\n# Konfigurasi .tmux.conf\nTMUX_CONF=\"$HOME/.tmux.conf\"\nif [ -f \"$TMUX_CONF\" ]; then\n    echo -e \"${YELLOW}⚠️  File .tmux.conf lama ditemukan. Membuat backup...${NC}\"\n    mv \"$TMUX_CONF\" \"$TMUX_CONF.bak.$(date +%F-%T)\"\nfi\necho -e \"${BLUE}  - Membuat file .tmux.conf baru...${NC}\"\ncat > \"$TMUX_CONF\" << \"EOL\"\nunbind C-b\nset -g prefix `\nset -g base-index 1\nset -g pane-base-index 1\nbind-key ` last-window\nbind-key e send-prefix\nset -g mouse on\nset -g status-position bottom\nset -g status-bg colour234\nset -g status-fg colour137\nset -g status-left ''\nset -g status-right '#[fg=colour233,bg=colour241,bold] %d/%m #[fg=colour233,bg=colour245,bold] %H:%M:%S '\nset -g status-right-length 50\nset -g status-left-length 20\nsetw -g mode-keys vi\nsetw -g mouse on\nsetw -g window-status-current-format ' #I#[fg=colour250]:#[fg=colour255]#W#[fg=colour50]#F '\nsetw -g window-status-format ' #I#[fg=colour237]:#[fg=colour250]#W#[fg=colour244]#F '\nset-option -g history-limit 5000\nset -g @plugin 'tmux-plugins/tpm'\nset -g @plugin 'tmux-plugins/tmux-sensible'\nset -g @plugin 'tmux-plugins/tmux-pain-control'\nset-option -g default-shell /bin/zsh\nrun -b '~/.tmux/plugins/tpm/tpm'\nEOL\n\n\n# --- LANGKAH 3: SETUP OH MY ZSH & PLUGINS ---\necho -e \"\\n${BLUE}▶️  Langkah 3: Menyiapkan Oh My Zsh...${NC}\"\n\n# Instalasi Oh My Zsh\nif [ -d \"$HOME/.oh-my-zsh\" ]; then\n    echo -e \"${GREEN}  ✅ Oh My Zsh sudah terinstal.${NC}\"\nelse\n    echo -e \"${YELLOW}  - Menginstal Oh My Zsh...${NC}\"\n    # Menggunakan flag --unattended agar skrip tidak berhenti\n    sh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" \"\" --unattended\nfi\n\n# Instalasi Plugin Eksternal Oh My Zsh\nZSH_CUSTOM_PLUGINS_DIR=\"$HOME/.oh-my-zsh/custom/plugins\"\necho -e \"${BLUE}  - Menginstal plugin kustom Oh My Zsh...${NC}\"\n# zsh-autosuggestions\nif [ ! -d \"${ZSH_CUSTOM_PLUGINS_DIR}/zsh-autosuggestions\" ]; then\n    git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM_PLUGINS_DIR}/zsh-autosuggestions\nelse\n    echo -e \"${GREEN}    ✅ Plugin zsh-autosuggestions sudah ada.${NC}\"\nfi\n# zsh-syntax-highlighting\nif [ ! -d \"${ZSH_CUSTOM_PLUGINS_DIR}/zsh-syntax-highlighting\" ]; then\n    git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM_PLUGINS_DIR}/zsh-syntax-highlighting\nelse\n    echo -e \"${GREEN}    ✅ Plugin zsh-syntax-highlighting sudah ada.${NC}\"\nfi\n\n# --- LANGKAH 4: MEMBUAT KONFIGURASI .zshrc ---\necho -e \"\\n${BLUE}▶️  Langkah 4: Membuat file konfigurasi .zshrc...${NC}\"\nZSHRC_FILE=\"$HOME/.zshrc\"\n\nif [ -f \"$ZSHRC_FILE\" ]; then\n    echo -e \"${YELLOW}⚠️  File .zshrc lama ditemukan. Membuat backup...${NC}\"\n    mv \"$ZSHRC_FILE\" \"$ZSHRC_FILE.bak.$(date +%F-%T)\"\nfi\necho -e \"${BLUE}  - Membuat file .zshrc baru dengan plugin pilihan Anda...${NC}\"\ncat > \"$ZSHRC_FILE\" << 'EOL'\n# Path ke instalasi Oh My Zsh Anda.\nexport ZSH=\"$HOME/.oh-my-zsh\"\n\n# Tema ZSH. \"robbyrussell\" adalah default, \"agnoster\" juga populer.\nZSH_THEME=\"robbyrussell\"\n\n# Daftar plugin yang akan dimuat.\n# Plugin kustom (non-bundel) harus di-clone secara manual.\n# Skrip ini sudah melakukannya untuk zsh-autosuggestions dan zsh-syntax-highlighting.\nplugins=(\n  git\n  zsh-autosuggestions\n  zsh-syntax-highlighting\n  sudo\n  vi-mode\n  z\n)\n\n# Memuat Oh My Zsh.\nsource $ZSH/oh-my-zsh.sh\n\n# User configuration\n# Contoh alias\nalias ls='ls --color=auto'\nalias grep='grep --color=auto'\nalias update='sudo apt update && sudo apt upgrade -y' # Ganti 'apt' jika perlu\n# Directories\nalias ..='cd ..'\nalias ...='cd ../..'\nalias ....='cd ../../..'\n\n# Key binding untuk vi-mode\nbindkey -v\nexport KEYTIMEOUT=1\n\n# shove: git add, commit with message, confirm before push\nshove() {\n  git add .\n  git commit -m \"$*\"\n  echo -n \"Push to origin? (y/n): \"\n  read confirm\n  if [[ \"$confirm\" =~ ^[Yy]$ ]]; then\n    git push origin\n  else\n    echo \"❌ Push cancelled.\"\n  fi\n}\n\n# shovenc: commit tanpa pesan, konfirmasi sebelum push\nshovenc() {\n  git add .\n  git commit --allow-empty-message -m \"\"\n  echo -n \"Push to origin? (y/n): \"\n  read confirm\n  if [[ \"$confirm\" =~ ^[Yy]$ ]]; then\n    git push origin\n  else\n    echo \"❌ Push cancelled.\"\n  fi\n}\n\nEOL\n\n# --- SELESAI ---\necho -e \"\\n\\n${GREEN}=====================================================${NC}\"\necho -e \"${GREEN}          ✨ SEMUA INSTALASI SELESAI! ✨          ${NC}\"\necho -e \"${GREEN}=====================================================${NC}\"\necho \"\"\necho -e \"Dua langkah terakhir yang ${YELLOW}WAJIB${NC} Anda lakukan:\"\necho \"\"\necho -e \"1. ${YELLOW}TUTUP dan BUKA KEMBALI TERMINAL ANDA${NC}.\"\necho \"   Ini penting agar Zsh menjadi shell default Anda dan semua pengaturan baru dimuat.\"\necho \"\"\necho -e \"2. Setelah terminal dibuka kembali (Anda akan melihat shell Zsh yang baru), ${YELLOW}JALANKAN TMUX${NC}:\"\necho \"   > tmux\"\necho \"\"\necho -e \"3. Di dalam sesi tmux, ${YELLOW}INSTAL PLUGIN TMUX${NC} dengan menekan:\"\necho -e \"   > Prefix + I (yaitu, tekan \\` lalu lepas, kemudian tekan I kapital)\"\necho \"\"\necho \"------------------------------------------------------------------\"\necho \"Nikmati terminal Anda yang baru dan lebih powerful!\"\necho \"------------------------------------------------------------------\"\n"
  },
  {
    "path": "dev-tools/connect-gh.sh",
    "content": "#!/bin/bash\n\n# =======================================\n# SETUP SSH untuk GitHub.com langsung\n# Menggunakan kunci ~/.ssh/bitwarden_localan\n# =======================================\n\nSSH_KEY=\"$HOME/.ssh/bitwarden_localan\"\nGITHUB_HOST=\"github.com\"\nGITHUB_USER=\"localan\"\nGITHUB_EMAIL=\"localso@proton.me\"\nSSH_CONFIG_FILE=\"$HOME/.ssh/config\"\n\necho \"==========[ SETUP SSH GITHUB.COM ]==========\"\necho \"SSH Key     : $SSH_KEY\"\necho \"GitHub Host : $GITHUB_HOST\"\necho \"============================================\"\n\n# 1. Tambahkan konfigurasi ke ~/.ssh/config\nif [ ! -f \"$SSH_CONFIG_FILE\" ]; then\n  touch \"$SSH_CONFIG_FILE\"\n  chmod 600 \"$SSH_CONFIG_FILE\"\nfi\n\nif ! grep -q \"Host $GITHUB_HOST\" \"$SSH_CONFIG_FILE\"; then\n  echo \"[*] Menambahkan konfigurasi SSH ke github.com...\"\n  cat <<EOF >> \"$SSH_CONFIG_FILE\"\n\n# Gunakan kunci bitwarden_localan untuk github.com\nHost $GITHUB_HOST\n  HostName github.com\n  User git\n  IdentityFile $SSH_KEY\n  IdentitiesOnly yes\nEOF\nelse\n  echo \"[=] Konfigurasi untuk github.com sudah ada, dilewati.\"\nfi\n\n# 2. Pastikan permission key benar\nchmod 600 \"$SSH_KEY\"\n\n# 3. Uji koneksi SSH ke github.com langsung\necho \"\"\necho \"[*] Menguji koneksi SSH ke GitHub...\"\necho \"    ssh -T git@github.com\"\necho \"----------------------------------------\"\nssh -T git@github.com\necho \"----------------------------------------\"\n\n# 4. Set Git global config\necho \"\"\necho \"[*] Mengatur Git global user/email...\"\ngit config --global user.name \"$GITHUB_USER\"\ngit config --global user.email \"$GITHUB_EMAIL\"\n\n# 5. Tampilkan Git config\necho \"[*] Git global config saat ini:\"\ngit config --global --list\n\n# 6. Contoh clone command\necho \"\"\necho \" Setup selesai!\"\necho \" Gunakan ini untuk clone repo:\"\necho \"    git clone git@github.com:$GITHUB_USER/<repo>.git\"\n\n"
  },
  {
    "path": "dev-tools/install-dev-tools.sh",
    "content": "#!/bin/bash\n\n# Skrip Instalasi Cerdas untuk Development Tools (fnm, Node, pnpm, Bun)\n# Versi: 1.6\n# Fitur:\n# - Deteksi otomatis & instalasi dependensi (curl, unzip).\n# - Melewatkan instalasi jika perangkat sudah ada.\n# - Konfigurasi shell otomatis (.bashrc/.zshrc).\n# - Metode instalasi fnm yang lebih aman untuk menghindari error.\n# - Memuat ulang shell secara otomatis di akhir untuk menerapkan perubahan.\n# - Output berwarna yang informatif.\n\n# Hentikan skrip jika terjadi kesalahan\nset -e\n\n# --- Definisi Variabel & Fungsi Bantuan ---\nC_RESET='\\033[0m'\nC_RED='\\033[0;31m'\nC_GREEN='\\033[0;32m'\nC_YELLOW='\\033[0;33m'\nC_BLUE='\\033[0;34m'\nC_BOLD='\\033[1m'\n\nprint_header() {\n    echo -e \"\\n${C_BOLD}${C_BLUE}===================================================${C_RESET}\"\n    echo -e \"${C_BOLD}${C_BLUE} $1${C_RESET}\"\n    echo -e \"${C_BOLD}${C_BLUE}===================================================${C_RESET}\"\n}\n\ncommand_exists() {\n    command -v \"$1\" >/dev/null 2>&1\n}\n\n# --- FUNGSI UTAMA ---\n\ncheck_dependencies() {\n    print_header \"Langkah 0: Memeriksa Dependensi Sistem\"\n    DEPS=(\"curl\" \"unzip\")\n    \n    for dep in \"${DEPS[@]}\"; do\n        if command_exists \"$dep\"; then\n            echo -e \"${C_GREEN}✅ Dependensi '$dep' sudah terinstal.${C_RESET}\"\n        else\n            echo -e \"${C_RED}❌ Dependensi '$dep' tidak ditemukan.${C_RESET}\"\n            \n            # Deteksi manajer paket dan coba instal\n            local PKG_MANAGER=\"\"\n            if command_exists apt-get; then PKG_MANAGER=\"apt-get\"; fi\n            if command_exists dnf; then PKG_MANAGER=\"dnf\"; fi\n            if command_exists yum; then PKG_MANAGER=\"yum\"; fi\n\n            if [ -n \"$PKG_MANAGER\" ]; then\n                echo -e \"${C_YELLOW}��� Mencoba menginstal '$dep' via '$PKG_MANAGER'... (Mungkin memerlukan password sudo)${C_RESET}\"\n                if [ \"$PKG_MANAGER\" = \"apt-get\" ]; then\n                    sudo apt-get update > /dev/null\n                    sudo apt-get install -y \"$dep\"\n                else\n                    sudo \"$PKG_MANAGER\" install -y \"$dep\"\n                fi\n                echo -e \"${C_GREEN}��� Dependensi '$dep' berhasil diinstal.${C_RESET}\"\n            else\n                echo -e \"${C_RED}⚠️ Manajer paket tidak dikenal. Harap instal '$dep' secara manual dan jalankan kembali skrip ini.${C_RESET}\"\n                exit 1\n            fi\n        fi\n    done\n}\n\ninstall_fnm_and_node() {\n    print_header \"Langkah 1: Instalasi fnm, Node.js & pnpm\"\n\n    # Instal fnm jika belum ada\n    if command_exists fnm; then\n        echo -e \"${C_GREEN}✅ fnm sudah terinstal. Melewati instalasi.${C_RESET}\"\n    else\n        echo -e \"${C_YELLOW}��� Menginstal fnm (Fast Node Manager)...${C_RESET}\"\n        # Metode instalasi yang lebih aman: unduh lalu jalankan.\n        curl -fsSL https://fnm.vercel.app/install -o fnm_install_script.sh\n        sh ./fnm_install_script.sh\n        rm ./fnm_install_script.sh\n        echo -e \"${C_GREEN}��� Instalasi fnm selesai.${C_RESET}\"\n    fi\n\n    # Menyiapkan lingkungan fnm untuk sesi ini\n    export PATH=\"$HOME/.local/share/fnm:$PATH\"\n    eval \"$(fnm env)\"\n\n    # Instal Node.js v22 jika belum ada\n    if fnm list | grep -q \"v22\"; then\n        echo -e \"${C_GREEN}✅ Node.js v22 sudah terinstal via fnm. Melewati instalasi.${C_RESET}\"\n    else\n        echo -e \"${C_YELLOW}��� Menginstal Node.js v22...${C_RESET}\"\n        fnm install 22\n    fi\n    \n    fnm use 22 > /dev/null\n    echo -e \"${C_YELLOW}��� Verifikasi versi Node.js...${C_RESET}\"\n    echo -e \"${C_GREEN}   -> $(node -v)${C_RESET}\"\n\n    # Aktifkan pnpm\n    echo -e \"${C_YELLOW}��� Mengaktifkan pnpm via corepack...${C_RESET}\"\n    corepack enable pnpm\n    echo -e \"${C_YELLOW}��� Verifikasi versi pnpm...${C_RESET}\"\n    echo -e \"${C_GREEN}   -> $(pnpm -v)${C_RESET}\"\n}\n\ninstall_bun() {\n    print_header \"Langkah 2: Instalasi Bun.js\"\n\n    # Instal Bun jika belum ada\n    if command_exists bun; then\n        echo -e \"${C_GREEN}✅ Bun sudah terinstal. Melewati instalasi.${C_RESET}\"\n    else\n        echo -e \"${C_YELLOW}��� Menginstal Bun.js...${C_RESET}\"\n        curl -fsSL https://bun.sh/install | bash\n        echo -e \"${C_GREEN}��� Instalasi Bun selesai.${C_RESET}\"\n    fi\n\n    # Menyiapkan lingkungan Bun untuk sesi ini\n    export PATH=\"$HOME/.bun/bin:$PATH\"\n    echo -e \"${C_YELLOW}��� Verifikasi versi Bun...${C_RESET}\"\n    echo -e \"${C_GREEN}   -> $(bun -v)${C_RESET}\"\n}\n\nconfigure_shell() {\n    print_header \"Langkah 3: Konfigurasi Shell Otomatis\"\n    \n    # Deteksi profil shell\n    local SHELL_PROFILE=\"\"\n    if [ -n \"$BASH_VERSION\" ]; then SHELL_PROFILE=\"$HOME/.bashrc\"; fi\n    if [ -n \"$ZSH_VERSION\" ]; then SHELL_PROFILE=\"$HOME/.zshrc\"; fi\n\n    if [ -z \"$SHELL_PROFILE\" ]; then\n        echo -e \"${C_YELLOW}⚠️ Tidak dapat mendeteksi file profil shell (.bashrc atau .zshrc). Harap konfigurasi PATH secara manual.${C_RESET}\"\n        return\n    fi\n    \n    echo -e \"File profil shell terdeteksi: ${C_BOLD}${SHELL_PROFILE}${C_RESET}\"\n\n    # Tambahkan konfigurasi fnm jika belum ada\n    if ! grep -q 'fnm env' \"$SHELL_PROFILE\"; then\n        echo -e \"${C_YELLOW}��� Menambahkan konfigurasi fnm ke ${SHELL_PROFILE}...${C_RESET}\"\n        echo -e '\\n# Konfigurasi untuk fnm (Fast Node Manager)\\nexport PATH=\"$HOME/.local/share/fnm:$PATH\"\\neval \"$(fnm env)\"' >> \"$SHELL_PROFILE\"\n    else\n        echo -e \"${C_GREEN}✅ Konfigurasi fnm sudah ada di ${SHELL_PROFILE}.${C_RESET}\"\n    fi\n\n    # Tambahkan konfigurasi Bun jika belum ada\n    if ! grep -q '.bun/bin' \"$SHELL_PROFILE\"; then\n        echo -e \"${C_YELLOW}��� Menambahkan konfigurasi Bun ke ${SHELL_PROFILE}...${C_RESET}\"\n        echo -e '\\n# Konfigurasi untuk Bun.js\\nexport PATH=\"$HOME/.bun/bin:$PATH\"' >> \"$SHELL_PROFILE\"\n    else\n        echo -e \"${C_GREEN}✅ Konfigurasi Bun sudah ada di ${SHELL_PROFILE}.${C_RESET}\"\n    fi\n}\n\n# --- EKSEKUSI SKRIP UTAMA ---\nmain() {\n    check_dependencies\n    install_fnm_and_node\n    install_bun\n    configure_shell\n\n    print_header \"��� Instalasi Selesai! ���\"\n    echo -e \"${C_GREEN}Semua alat pengembangan telah berhasil diinstal dan dikonfigurasi.${C_RESET}\"\n    \n    # --- Langkah Terakhir: Muat Ulang Shell ---\n    local CURRENT_SHELL_NAME=\"\"\n    local SHELL_PROFILE=\"\"\n    if [ -n \"$BASH_VERSION\" ]; then \n        CURRENT_SHELL_NAME=\"bash\"\n        SHELL_PROFILE=\"$HOME/.bashrc\"\n    fi\n    if [ -n \"$ZSH_VERSION\" ]; then \n        CURRENT_SHELL_NAME=\"zsh\"\n        SHELL_PROFILE=\"$HOME/.zshrc\"\n    fi\n    \n    if [ -n \"$CURRENT_SHELL_NAME\" ]; then\n        echo -e \"${C_YELLOW}��� PENTING: Shell akan dimuat ulang sekarang untuk menerapkan semua perubahan.${C_RESET}\"\n        echo -e \"${C_YELLOW}   Silakan tunggu...${C_RESET}\"\n        # 'exec' akan menggantikan proses skrip saat ini dengan shell baru,\n        # yang akan memuat file .bashrc/.zshrc yang telah diperbarui.\n        exec \"$CURRENT_SHELL_NAME\"\n    else\n        # Fallback jika shell tidak terdeteksi\n        echo -e \"${C_YELLOW}��� PENTING: Untuk menerapkan perubahan secara permanen, silakan BUKA TERMINAL BARU,\"\n        echo -e \"${C_YELLOW}   atau jalankan perintah berikut di terminal Anda saat ini:${C_RESET}\"\n        echo -e \"   ${C_BOLD}source ${SHELL_PROFILE:-\"$HOME/.bashrc atau $HOME/.zshrc\"}${C_RESET}\"\n    fi\n}\n\n# Jalankan fungsi utama\nmain\n\n"
  },
  {
    "path": "dev-tools/docker-install.sh",
    "content": "#!/bin/bash\n# needs-sudo\n\n# ==============================================================================\n# Skrip Instalasi Docker Otomatis untuk Distribusi Linux Populer\n# ==============================================================================\n\n# Periksa apakah skrip dijalankan sebagai root\nif [ \"$EUID\" -ne 0 ]; then\n  echo \"Harap jalankan skrip ini sebagai root atau menggunakan sudo.\"\n  exit 1\nfi\n\n# Fungsi untuk menginstal Docker di distribusi berbasis Debian (Ubuntu, Debian)\ninstall_docker_debian() {\n    echo \"--- Mendeteksi sistem berbasis Debian/Ubuntu ---\"\n    apt-get update\n    apt-get install -y ca-certificates curl gnupg\n    install -m 0755 -d /etc/apt/keyrings\n    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg\n    chmod a+r /etc/apt/keyrings/docker.gpg\n\n    echo \\\n      \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/$(. /etc/os-release && echo \"$ID\") \\\n      $(. /etc/os-release && echo \"$VERSION_CODENAME\") stable\" | \\\n      tee /etc/apt/sources.list.d/docker.list > /dev/null\n    \n    apt-get update\n    apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n    echo \"--- Instalasi Docker di $(. /etc/os-release && echo \"$PRETTY_NAME\") selesai ---\"\n}\n\n# Fungsi untuk menginstal Docker di distribusi berbasis RHEL (CentOS, Fedora)\ninstall_docker_rhel() {\n    echo \"--- Mendeteksi sistem berbasis CentOS/Fedora ---\"\n    dnf -y install dnf-plugins-core\n    dnf config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n    # Untuk Fedora, gunakan repo CentOS\n    if [ -f /etc/fedora-release ]; then\n        dnf config-manager --add-repo https://download.docker.com/linux/fedora/docker-ce.repo\n    fi\n    dnf install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n    systemctl start docker\n    systemctl enable docker\n    echo \"--- Instalasi Docker di $(. /etc/os-release && echo \"$PRETTY_NAME\") selesai ---\"\n}\n\n# --- Logika Utama Skrip ---\n\nif [ -f /etc/os-release ]; then\n    . /etc/os-release\n    OS=$ID\nelse\n    echo \"Tidak dapat mendeteksi distribusi Linux.\"\n    exit 1\nfi\n\ncase \"$OS\" in\n    ubuntu|debian)\n        install_docker_debian\n        ;;\n    centos|rhel|fedora)\n        install_docker_rhel\n        ;;\n    *)\n        echo \"Distribusi Linux '$OS' tidak didukung oleh skrip ini.\"\n        echo \"Silakan lihat dokumentasi resmi Docker untuk instruksi instalasi manual.\"\n        exit 1\n        ;;\nesac\n\n# Opsional: Menambahkan user saat ini ke grup docker agar bisa menjalankan docker tanpa sudo\n# Hati-hati: Ini memiliki implikasi keamanan. Logout dan login kembali diperlukan.\nread -p \"Apakah Anda ingin menambahkan user saat ini ke grup Docker agar tidak perlu 'sudo'? (y/n): \" add_user_to_group\nif [[ \"$add_user_to_group\" == \"y\" || \"$add_user_to_group\" == \"Y\" ]]; then\n    CURRENT_USER=$(logname)\n    usermod -aG docker $CURRENT_USER\n    echo \"User '$CURRENT_USER' telah ditambahkan ke grup docker.\"\n    echo \"Anda perlu logout dan login kembali agar perubahan ini efektif.\"\nfi\n\necho \"\"\necho \"✅ Instalasi Docker berhasil!\"\necho \"Verifikasi instalasi dengan menjalankan: docker run hello-world\"\n"
  },
  {
    "path": "ai-tools/README.md",
    "content": "# AI Tools Collection\n\nKoleksi script untuk menginstall berbagai AI development tools yang berguna untuk coding dan development.\n\n## 🛠️ Available AI Tools\n\n### 1. OpenCode AI\n- **Script**: `opencode.sh`\n- **Description**: AI-powered code editor and assistant\n- **Command**: `opencode`\n- **Website**: https://opencode.ai\n- **Installation**: `bash script/ai-tools/opencode.sh`\n\n### 2. OpenAI Codex\n- **Script**: `codex-install.sh`\n- **Description**: OpenAI's code generation and completion tool\n- **Command**: `codex`\n- **Website**: https://platform.openai.com\n- **Installation**: `bash script/ai-tools/codex-install.sh`\n- **API Key**: https://platform.openai.com/api-keys\n\n### 3. Google Gemini CLI\n- **Script**: `gemini-install.sh`\n- **Description**: Google's Gemini AI model CLI interface\n- **Command**: `gemini`\n- **Website**: https://aistudio.google.com\n- **Installation**: `bash script/ai-tools/gemini-install.sh`\n- **API Key**: https://aistudio.google.com/app/apikey\n\n### 4. Qwen Code CLI\n- **Script**: `qwen-install.sh`\n- **Description**: Qwen Code model for code generation and analysis\n- **Command**: `qwen-code`\n- **Website**: https://github.com/QwenLM/Qwen-Code\n- **Installation**: `bash script/ai-tools/qwen-install.sh`\n\n### 5. CodeRabbit CLI\n- **Script**: `coderabbit-install.sh`\n- **Description**: AI-powered code review and analysis tool\n- **Command**: `coderabbit`\n- **Website**: https://coderabbit.ai\n- **Installation**: `bash script/ai-tools/coderabbit-install.sh`\n\n### 6. Cursor AI Code Editor\n- **Script**: `cursor-install.sh`\n- **Description**: AI-powered code editor with intelligent assistance\n- **Command**: `cursor-agent` (CLI), `cursor` (GUI application)\n- **Website**: https://cursor.com\n- **Installation**: `bash script/ai-tools/cursor-install.sh`\n\n## 🚀 Quick Installation\n\n### Install All AI Tools\n```bash\nbash script/ai-tools/install-all-ai-tools.sh\n```\n\n### Install Individual Tools\n```bash\n# OpenCode AI\nbash script/ai-tools/opencode.sh\n\n# OpenAI Codex\nbash script/ai-tools/codex-install.sh\n\n# Google Gemini CLI\nbash script/ai-tools/gemini-install.sh\n\n# Qwen Code CLI\nbash script/ai-tools/qwen-install.sh\n\n# CodeRabbit CLI\nbash script/ai-tools/coderabbit-install.sh\n\n# Cursor AI Code Editor\nbash script/ai-tools/cursor-install.sh\n```\n\n### Auto-Refresh Environment\n```bash\n# Refresh all AI tools environment automatically\nbash script/ai-tools/ai-tools-refresh.sh\n```\n\n## 🧪 Testing\n\n### Test All Scripts\n```bash\nbash script/ai-tools/test-all-ai-tools.sh\n```\n\n### Test Individual Scripts\n```bash\nbash -n script/ai-tools/[script-name].sh\n```\n\n## 🔧 Troubleshooting\n\n### Auto-Refresh Environment\nIf any AI tools are not accessible after installation:\n```bash\nbash script/ai-tools/ai-tools-refresh.sh\n```\n\nThis script will:\n- ✅ Automatically detect your shell (bash/zsh)\n- ✅ Configure PATH for all AI tools\n- ✅ Refresh your shell environment\n- ✅ Verify all installations\n- ✅ Show usage examples\n\n### Common Issues\n\n1. **Command not found**: Restart terminal or run `source ~/.bashrc`\n2. **Permission denied**: Make script executable with `chmod +x script/ai-tools/[script-name].sh`\n3. **Node.js required**: Install Node.js first for npm-based tools\n4. **API key needed**: Configure API keys for tools that require authentication\n\n## 📋 Prerequisites\n\n- **Node.js** (for npm-based tools)\n- **npm** (comes with Node.js)\n- **curl** (for downloading installers)\n- **bash** (for running scripts)\n\n## 🔑 API Configuration\n\nMost AI tools require API keys for full functionality:\n\n1. **OpenAI Codex**: Get API key from https://platform.openai.com/api-keys\n2. **Google Gemini**: Get API key from https://aistudio.google.com/app/apikey\n3. **CodeRabbit**: Sign up at https://coderabbit.ai\n\n## 📚 Usage Examples\n\n### OpenCode AI\n```bash\nopencode                    # Start TUI\nopencode --help            # Show help\nopencode run 'hello world'  # Run with message\nopencode auth              # Manage credentials\n```\n\n### OpenAI Codex\n```bash\ncodex --version            # Check version\ncodex config              # Configure API key\ncodex                     # Start interactive mode\n```\n\n### Google Gemini CLI\n```bash\ngemini --version          # Check version\ngemini config             # Configure API key\ngemini                    # Start interactive mode\n```\n\n### Qwen Code CLI\n```bash\nqwen-code --version       # Check version\nqwen-code config          # Configure settings\nqwen-code                 # Start interactive mode\n```\n\n### CodeRabbit CLI\n```bash\ncoderabbit --version     # Check version\ncoderabbit auth          # Authenticate\ncoderabbit               # Start interactive mode\n```\n\n### Cursor AI Code Editor\n```bash\ncursor-agent --version  # Check version\ncursor-agent --help     # Show help\ncursor-agent            # Start Cursor Agent (CLI)\n# Note: Cursor GUI application launches from desktop\n```\n\n## 🎯 Features\n\n- ✅ **Error Handling**: All scripts use `set -euo pipefail`\n- ✅ **Installation Verification**: Automatic verification after installation\n- ✅ **PATH Configuration**: Automatic PATH setup where needed\n- ✅ **Prerequisites Check**: Validates required tools before installation\n- ✅ **Clear Feedback**: Detailed progress and error messages\n- ✅ **Idempotent**: Safe to run multiple times\n\n## 📝 Script Standards\n\nAll AI tools scripts follow these standards:\n\n1. **Error Handling**: `set -euo pipefail`\n2. **Prerequisites Check**: Validate required tools\n3. **Installation Verification**: Check if installation succeeded\n4. **Clear Output**: Informative messages with emojis\n5. **Next Steps**: Provide usage instructions\n6. **Error Recovery**: Graceful failure handling\n\n## 🤝 Contributing\n\nTo add new AI tools:\n\n1. Create new script in `script/ai-tools/`\n2. Follow existing script standards\n3. Add to `install-all-ai-tools.sh`\n4. Update this README\n5. Test with `test-all-ai-tools.sh`\n\n## 📄 License\n\nThis collection is part of the HADES Script Collection Management System.\n"
  },
  {
    "path": "ai-tools/test-all-ai-tools.sh",
    "content": "#!/usr/bin/env bash\n\n# Test All AI Tools Script\n# This script tests all AI tools installation scripts to ensure they work correctly\n# Compatible with both bash and zsh shells\n\n# Detect shell and set compatibility\nif [[ -n \"${ZSH_VERSION:-}\" ]]; then\n    # Zsh compatibility\n    setopt shwordsplit\n    setopt pipefail\n    setopt errexit\n    setopt nounset\nelse\n    # Bash compatibility\n    set -euo pipefail\nfi\n\necho \"🧪 Testing All AI Tools Installation Scripts\"\necho \"=============================================\"\necho \"\"\n\n# Colors for output\ndeclare -r C_RESET='\\033[0m'\ndeclare -r C_BOLD='\\033[1m'\ndeclare -r C_RED='\\033[0;31m'\ndeclare -r C_GREEN='\\033[0;32m'\ndeclare -r C_YELLOW='\\033[0;33m'\ndeclare -r C_BLUE='\\033[0;34m'\n\n# Test results\ndeclare -a PASSED_TESTS=()\ndeclare -a FAILED_TESTS=()\n\n# Function to test a script\ntest_script() {\n    local script_name=\"$1\"\n    local script_path=\"script/ai-tools/$script_name\"\n    \n    echo -e \"${C_BLUE}Testing $script_name...${C_RESET}\"\n    \n    # Check if script exists\n    if [[ ! -f \"$script_path\" ]]; then\n        echo -e \"${C_RED}❌ Script not found: $script_path${C_RESET}\"\n        FAILED_TESTS+=(\"$script_name (not found)\")\n        return 1\n    fi\n    \n    # Check if script is executable\n    if [[ ! -x \"$script_path\" ]]; then\n        echo -e \"${C_YELLOW}⚠️  Script not executable, making it executable...${C_RESET}\"\n        chmod +x \"$script_path\"\n    fi\n    \n    # Test syntax\n    if bash -n \"$script_path\"; then\n        echo -e \"${C_GREEN}✅ Syntax check passed${C_RESET}\"\n    else\n        echo -e \"${C_RED}❌ Syntax check failed${C_RESET}\"\n        FAILED_TESTS+=(\"$script_name (syntax error)\")\n        return 1\n    fi\n    \n    # Test if script has proper error handling\n    if grep -q \"set -euo pipefail\" \"$script_path\"; then\n        echo -e \"${C_GREEN}✅ Error handling configured${C_RESET}\"\n    else\n        echo -e \"${C_YELLOW}⚠️  Missing proper error handling${C_RESET}\"\n    fi\n    \n    # Test if script has verification logic\n    if grep -q \"Verifying installation\" \"$script_path\"; then\n        echo -e \"${C_GREEN}✅ Installation verification included${C_RESET}\"\n    else\n        echo -e \"${C_YELLOW}⚠️  Missing installation verification${C_RESET}\"\n    fi\n    \n    PASSED_TESTS+=(\"$script_name\")\n    echo \"\"\n}\n\n# Test all AI tools scripts\necho -e \"${C_BOLD}Testing AI Tools Installation Scripts:${C_RESET}\"\necho \"\"\n\ntest_script \"opencode.sh\"\ntest_script \"codex-install.sh\"\ntest_script \"gemini-install.sh\"\ntest_script \"qwen-install.sh\"\ntest_script \"coderabbit-install.sh\"\ntest_script \"cursor-install.sh\"\ntest_script \"ai-tools-refresh.sh\"\n\n# Summary\necho -e \"${C_BOLD}Test Summary:${C_RESET}\"\necho \"=============\"\necho \"\"\n\nif [[ ${#PASSED_TESTS[@]} -gt 0 ]]; then\n    echo -e \"${C_GREEN}✅ Passed Tests (${#PASSED_TESTS[@]}):${C_RESET}\"\n    for test in \"${PASSED_TESTS[@]}\"; do\n        echo -e \"  ${C_GREEN}✓${C_RESET} $test\"\n    done\n    echo \"\"\nfi\n\nif [[ ${#FAILED_TESTS[@]} -gt 0 ]]; then\n    echo -e \"${C_RED}❌ Failed Tests (${#FAILED_TESTS[@]}):${C_RESET}\"\n    for test in \"${FAILED_TESTS[@]}\"; do\n        echo -e \"  ${C_RED}✗${C_RESET} $test\"\n    done\n    echo \"\"\nfi\n\n# Overall result\nif [[ ${#FAILED_TESTS[@]} -eq 0 ]]; then\n    echo -e \"${C_GREEN}🎉 All AI tools scripts are working correctly!${C_RESET}\"\n    echo \"\"\n    echo -e \"${C_BOLD}Available AI Tools:${C_RESET}\"\n    echo \"  • OpenCode AI (opencode.sh)\"\n    echo \"  • OpenAI Codex (codex-install.sh)\"\n    echo \"  • Google Gemini CLI (gemini-install.sh)\"\n    echo \"  • Qwen Code CLI (qwen-install.sh)\"\n    echo \"  • CodeRabbit CLI (coderabbit-install.sh)\"\n    echo \"  • Cursor AI Code Editor (cursor-install.sh)\"\n    echo \"\"\n    echo -e \"${C_BOLD}Usage:${C_RESET}\"\n    echo \"  bash script/ai-tools/[script-name].sh\"\n    echo \"  zsh script/ai-tools/[script-name].sh\"\n    echo \"\"\n    echo -e \"${C_BOLD}Shell Compatibility:${C_RESET}\"\n    if [[ -n \"${ZSH_VERSION:-}\" ]]; then\n        echo \"  💡 Currently running in: zsh\"\n        echo \"  ✅ All scripts are compatible with zsh and bash\"\n    else\n        echo \"  💡 Currently running in: bash\"\n        echo \"  ✅ All scripts are compatible with bash and zsh\"\n    fi\n    echo \"\"\n    echo -e \"${C_BOLD}Auto-refresh AI tools environment:${C_RESET}\"\n    echo \"  bash script/ai-tools/ai-tools-refresh.sh\"\n    echo \"  zsh script/ai-tools/ai-tools-refresh.sh\"\n    exit 0\nelse\n    echo -e \"${C_RED}❌ Some tests failed. Please fix the issues above.${C_RESET}\"\n    exit 1\nfi\n"
  },
  {
    "path": "ai-tools/cursor-install.sh",
    "content": "#!/usr/bin/env bash\n\n# Cursor AI Code Editor Installation Script\n# This script installs Cursor using the official installation method\n# Compatible with both bash and zsh shells\n\n# Detect shell and set compatibility\nif [[ -n \"${ZSH_VERSION:-}\" ]]; then\n    # Zsh compatibility\n    setopt shwordsplit\n    setopt pipefail\n    setopt errexit\n    setopt nounset\nelse\n    # Bash compatibility\n    set -euo pipefail\nfi\n\necho \"🚀 Installing Cursor AI Code Editor...\"\necho \"=====================================\"\n\n# Check if curl is available\nif ! command -v curl &> /dev/null; then\n    echo \"❌ Error: curl is required but not installed.\"\n    echo \"Please install curl first:\"\n    echo \"  Ubuntu/Debian: sudo apt update && sudo apt install curl\"\n    echo \"  CentOS/RHEL: sudo yum install curl\"\n    echo \"  macOS: curl should be pre-installed\"\n    exit 1\nfi\n\n# Run the official Cursor installation command\necho \"📥 Downloading and installing Cursor...\"\necho \"⚠️  Note: This will install Cursor AI Code Editor\"\n\n# Try to run installation with automatic responses\nif curl https://cursor.com/install -fsS | bash; then\n    echo \"✅ Installation completed successfully\"\nelse\n    echo \"❌ Installation failed\"\n    exit 1\nfi\n\necho \"\"\necho \"✅ Cursor AI Code Editor installation completed!\"\n\n# Try to verify installation\necho \"🔍 Verifying installation...\"\n\n# Check if cursor binary exists in common locations\nCURSOR_PATHS=(\n    \"/usr/local/bin/cursor\"\n    \"/opt/cursor/cursor\"\n    \"/home/$USER/.local/bin/cursor\"\n    \"/home/$USER/cursor/cursor\"\n)\n\nCURSOR_FOUND=false\nfor path in \"${CURSOR_PATHS[@]}\"; do\n    if [[ -f \"$path\" ]]; then\n        echo \"✅ Cursor binary found: $path\"\n        CURSOR_FOUND=true\n        \n        # Try to add to PATH temporarily for verification\n        export PATH=\"$(dirname \"$path\"):$PATH\"\n        \n        if command -v cursor &> /dev/null; then\n            echo \"✅ Cursor command accessible: $(which cursor)\"\n            if cursor --version &> /dev/null; then\n                echo \"✅ Cursor version: $(cursor --version)\"\n            else\n                echo \"⚠️  Cursor installed but version check failed\"\n            fi\n        else\n            echo \"⚠️  Cursor binary exists but not in PATH\"\n        fi\n        break\n    fi\ndone\n\nif [[ \"$CURSOR_FOUND\" == false ]]; then\n    echo \"⚠️  Cursor binary not found in common locations\"\n    echo \"   Installation may have succeeded but binary location is unknown\"\n    echo \"   Try running 'cursor' command or check your desktop applications\"\nfi\n\n# Check if cursor is available as a command\nif command -v cursor &> /dev/null; then\n    echo \"✅ Cursor is accessible from command line\"\n    \n    # Detect shell and check appropriate config file\n    if [[ -n \"${ZSH_VERSION:-}\" ]]; then\n        SHELL_CONFIG=\"$HOME/.zshrc\"\n        SHELL_NAME=\"zsh\"\n    else\n        SHELL_CONFIG=\"$HOME/.bashrc\"\n        SHELL_NAME=\"bash\"\n    fi\n    \n    # Check if PATH is configured in shell config\n    if grep -q \"cursor\" \"$SHELL_CONFIG\" 2>/dev/null; then\n        echo \"✅ PATH configuration found in $SHELL_CONFIG\"\n    else\n        echo \"⚠️  PATH not configured in $SHELL_CONFIG\"\n        echo \"   This is normal for GUI applications like Cursor\"\n    fi\nelse\n    echo \"⚠️  Cursor not accessible from command line\"\n    echo \"   This is normal for GUI applications - check your applications menu\"\nfi\n\necho \"\"\necho \"📋 Next steps:\"\necho \"1. Refresh your shell session:\"\nif [[ -n \"${ZSH_VERSION:-}\" ]]; then\n    echo \"   source ~/.zshrc\"\n    echo \"   # OR restart your terminal\"\n    echo \"💡 Shell detected: zsh\"\nelse\n    echo \"   source ~/.bashrc\"\n    echo \"   # OR restart your terminal\"\n    echo \"💡 Shell detected: bash\"\nfi\necho \"\"\necho \"2. Verify installation: cursor-agent --version\"\necho \"3. Look for Cursor in your applications menu\"\necho \"4. Launch Cursor from the desktop environment\"\necho \"5. Sign in with your account to access AI features\"\necho \"6. Start coding with AI assistance!\"\necho \"\"\necho \"🎉 Happy coding with Cursor AI!\"\n"
  },
  {
    "path": "ai-tools/opencode.sh",
    "content": "#!/usr/bin/env bash\n\n# OpenCode AI Installation Script\n# This script installs OpenCode AI using the official installation method\n# Compatible with both bash and zsh shells\n\n# Detect shell and set compatibility\nif [[ -n \"${ZSH_VERSION:-}\" ]]; then\n    # Zsh compatibility\n    setopt shwordsplit\n    setopt pipefail\n    setopt errexit\n    setopt nounset\nelse\n    # Bash compatibility\n    set -euo pipefail\nfi\n\necho \"🚀 Installing OpenCode AI...\"\necho \"================================\"\n\n# Check if curl is available\nif ! command -v curl &> /dev/null; then\n    echo \"❌ Error: curl is required but not installed.\"\n    echo \"Please install curl first:\"\n    echo \"  Ubuntu/Debian: sudo apt update && sudo apt install curl\"\n    echo \"  CentOS/RHEL: sudo yum install curl\"\n    echo \"  macOS: curl should be pre-installed\"\n    exit 1\nfi\n\n# Run the official OpenCode AI installation command\necho \"📥 Downloading and installing OpenCode AI...\"\necho \"⚠️  Note: This may prompt to replace existing files. Choose 'y' or 'A' to continue.\"\n\n# Try to run installation with automatic yes responses\nif curl -fsSL https://opencode.ai/install | bash -s -- --yes; then\n    echo \"✅ Installation completed with automatic responses\"\nelif curl -fsSL https://opencode.ai/install | bash; then\n    echo \"✅ Installation completed with manual responses\"\nelse\n    echo \"❌ Installation failed\"\n    exit 1\nfi\n\necho \"\"\necho \"✅ OpenCode AI installation completed!\"\n\n# Try to verify installation\necho \"🔍 Verifying installation...\"\n\n# Check if opencode binary exists\nif [[ -f \"/home/$USER/.opencode/bin/opencode\" ]]; then\n    echo \"✅ OpenCode AI binary found: /home/$USER/.opencode/bin/opencode\"\n    \n    # Try to add to PATH temporarily for verification\n    export PATH=\"/home/$USER/.opencode/bin:$PATH\"\n    \n    if command -v opencode &> /dev/null; then\n        echo \"✅ OpenCode AI command accessible: $(which opencode)\"\n        if opencode --version &> /dev/null; then\n            echo \"✅ OpenCode AI version: $(opencode --version)\"\n        else\n            echo \"⚠️  OpenCode AI installed but version check failed\"\n        fi\n    else\n        echo \"⚠️  OpenCode AI binary exists but not in PATH\"\n    fi\n    \n    # Detect shell and configure appropriate config file\n    if [[ -n \"${ZSH_VERSION:-}\" ]]; then\n        SHELL_CONFIG=\"$HOME/.zshrc\"\n        SHELL_NAME=\"zsh\"\n    else\n        SHELL_CONFIG=\"$HOME/.bashrc\"\n        SHELL_NAME=\"bash\"\n    fi\n    \n    # Check if PATH is configured in shell config\n    if grep -q \"opencode/bin\" \"$SHELL_CONFIG\" 2>/dev/null; then\n        echo \"✅ PATH configuration found in $SHELL_CONFIG\"\n    else\n        echo \"⚠️  PATH not configured in $SHELL_CONFIG\"\n        echo \"   Adding PATH configuration...\"\n        echo \"\" >> \"$SHELL_CONFIG\"\n        echo \"# OpenCode AI\" >> \"$SHELL_CONFIG\"\n        echo \"export PATH=\\\"/home/$USER/.opencode/bin:\\$PATH\\\"\" >> \"$SHELL_CONFIG\"\n        echo \"✅ PATH configuration added to $SHELL_CONFIG\"\n    fi\nelse\n    echo \"❌ OpenCode AI binary not found\"\n    echo \"   Installation may have failed\"\nfi\n\necho \"\"\necho \"📋 Next steps:\"\nif [[ -n \"${ZSH_VERSION:-}\" ]]; then\n    echo \"1. Restart your terminal or run: source ~/.zshrc\"\n    echo \"💡 Shell detected: zsh\"\nelse\n    echo \"1. Restart your terminal or run: source ~/.bashrc\"\n    echo \"💡 Shell detected: bash\"\nfi\necho \"2. Verify installation: opencode --version\"\necho \"3. Start using OpenCode AI: opencode\"\necho \"4. For help: opencode --help\"\necho \"\"\necho \"🎉 Happy coding with OpenCode AI!\"\n"
  },
  {
    "path": "ai-tools/coderabbit-install.sh",
    "content": "#!/usr/bin/env bash\n\n# CodeRabbit CLI Installation Script\n# This script installs CodeRabbit CLI tool using the official installation method\n# Compatible with both bash and zsh shells\n\n# Detect shell and set compatibility\nif [[ -n \"${ZSH_VERSION:-}\" ]]; then\n    # Zsh compatibility\n    setopt shwordsplit\n    setopt pipefail\n    setopt errexit\n    setopt nounset\nelse\n    # Bash compatibility\n    set -euo pipefail\nfi\n\necho \"🐰 Installing CodeRabbit CLI...\"\necho \"===============================\"\n\n# Check if curl is available\nif ! command -v curl &> /dev/null; then\n    echo \"❌ Error: curl is required but not installed.\"\n    echo \"Please install curl first:\"\n    echo \"  Ubuntu/Debian: sudo apt update && sudo apt install curl\"\n    echo \"  CentOS/RHEL: sudo yum install curl\"\n    echo \"  macOS: curl should be pre-installed\"\n    exit 1\nfi\n\n# Run the official CodeRabbit CLI installation command\necho \"📥 Downloading and installing CodeRabbit CLI...\"\nif curl -fsSL https://cli.coderabbit.ai/install.sh | sh; then\n    echo \"\"\n    echo \"✅ CodeRabbit CLI installation completed!\"\n    \n    # Try to verify installation\n    echo \"🔍 Verifying installation...\"\n    if command -v coderabbit &> /dev/null; then\n        echo \"✅ CodeRabbit command found: $(which coderabbit)\"\n        if coderabbit --version &> /dev/null; then\n            echo \"✅ CodeRabbit version: $(coderabbit --version)\"\n        else\n            echo \"⚠️  CodeRabbit installed but version check failed\"\n        fi\n    else\n        echo \"⚠️  CodeRabbit installed but command not found in PATH\"\n        if [[ -n \"${ZSH_VERSION:-}\" ]]; then\n            echo \"   You may need to restart your terminal or run: source ~/.zshrc\"\n        else\n            echo \"   You may need to restart your terminal or run: source ~/.bashrc\"\n        fi\n    fi\n    \n    echo \"\"\n    echo \"📋 Next steps:\"\n    if [[ -n \"${ZSH_VERSION:-}\" ]]; then\n        echo \"1. Restart your terminal or run: source ~/.zshrc\"\n        echo \"💡 Shell detected: zsh\"\n    else\n        echo \"1. Restart your terminal or run: source ~/.bashrc\"\n        echo \"💡 Shell detected: bash\"\n    fi\necho \"2. Verify installation: coderabbit --version\"\necho \"3. Configure your API key: coderabbit auth\"\necho \"4. Start using CodeRabbit: coderabbit\"\necho \"\"\necho \"🔑 Don't forget to authenticate with CodeRabbit!\"\necho \"   Visit: https://coderabbit.ai for more information\"\necho \"\"\necho \"🎉 Happy coding with CodeRabbit!\"\nelse\n    echo \"\"\n    echo \"❌ CodeRabbit CLI installation failed!\"\n    echo \"Please check your internet connection and try again.\"\n    echo \"You can also visit: https://coderabbit.ai for manual installation\"\n    exit 1\nfi\n"
  },
  {
    "path": "ai-tools/ai-tools-refresh.sh",
    "content": "#!/usr/bin/env bash\n\n# AI Tools Auto-Refresh Script\n# This script automatically refreshes shell environment and fixes PATH issues\n# Compatible with both bash and zsh shells\n\n# Detect shell and set compatibility\nif [[ -n \"${ZSH_VERSION:-}\" ]]; then\n    # Zsh compatibility\n    setopt shwordsplit\n    setopt pipefail\n    setopt errexit\n    setopt nounset\nelse\n    # Bash compatibility\n    set -euo pipefail\nfi\n\necho \"🔄 AI Tools Auto-Refresh Script\"\necho \"===============================\"\n\n# Detect shell\nif [[ -n \"${ZSH_VERSION:-}\" ]]; then\n    SHELL_CONFIG=\"$HOME/.zshrc\"\n    SHELL_NAME=\"zsh\"\nelse\n    SHELL_CONFIG=\"$HOME/.bashrc\"\n    SHELL_NAME=\"bash\"\nfi\n\necho \"💡 Shell detected: $SHELL_NAME\"\necho \"📁 Config file: $SHELL_CONFIG\"\necho \"\"\n\n# Function to add PATH if not exists\nadd_path_if_missing() {\n    local path_to_add=\"$1\"\n    local tool_name=\"$2\"\n    \n    if grep -q \"$path_to_add\" \"$SHELL_CONFIG\" 2>/dev/null; then\n        echo \"✅ $tool_name PATH already configured\"\n    else\n        echo \"➕ Adding $tool_name PATH configuration...\"\n        echo \"\" >> \"$SHELL_CONFIG\"\n        echo \"# $tool_name\" >> \"$SHELL_CONFIG\"\n        echo \"export PATH=\\\"$path_to_add:\\$PATH\\\"\" >> \"$SHELL_CONFIG\"\n        echo \"✅ $tool_name PATH added to $SHELL_CONFIG\"\n    fi\n}\n\n# Check and configure common AI tools paths\necho \"🔍 Checking AI tools installations...\"\n\n# OpenCode AI\nif [[ -f \"$HOME/.opencode/bin/opencode\" ]]; then\n    echo \"✅ OpenCode AI found\"\n    add_path_if_missing \"$HOME/.opencode/bin\" \"OpenCode AI\"\n    export PATH=\"$HOME/.opencode/bin:$PATH\"\nelse\n    echo \"⚠️  OpenCode AI not found\"\nfi\n\n# Cursor Agent\nif [[ -f \"$HOME/.local/bin/cursor-agent\" ]]; then\n    echo \"✅ Cursor Agent found\"\n    add_path_if_missing \"$HOME/.local/bin\" \"Cursor Agent\"\n    export PATH=\"$HOME/.local/bin:$PATH\"\nelse\n    echo \"⚠️  Cursor Agent not found\"\nfi\n\n# Node.js global packages (for npm-based tools)\nif command -v npm &> /dev/null; then\n    NPM_GLOBAL_BIN=$(npm config get prefix)/bin\n    if [[ -d \"$NPM_GLOBAL_BIN\" ]]; then\n        echo \"✅ Node.js global packages found\"\n        add_path_if_missing \"$NPM_GLOBAL_BIN\" \"Node.js Global Packages\"\n        export PATH=\"$NPM_GLOBAL_BIN:$PATH\"\n    fi\nfi\n\necho \"\"\necho \"🔄 Refreshing shell environment...\"\n\n# Refresh shell environment\nif [[ -n \"${ZSH_VERSION:-}\" ]]; then\n    # For zsh\n    if [[ -f \"$HOME/.zshrc\" ]]; then\n        source \"$HOME/.zshrc\"\n        echo \"✅ Zsh environment refreshed\"\n    fi\nelse\n    # For bash\n    if [[ -f \"$HOME/.bashrc\" ]]; then\n        source \"$HOME/.bashrc\"\n        echo \"✅ Bash environment refreshed\"\n    fi\nfi\n\necho \"\"\necho \"🔍 Verifying AI tools...\"\n\n# Verify tools\ndeclare -a TOOLS=(\n    \"opencode:OpenCode AI\"\n    \"cursor-agent:Cursor Agent\"\n    \"codex:OpenAI Codex\"\n    \"gemini:Google Gemini\"\n    \"qwen-code:Qwen Code\"\n    \"coderabbit:CodeRabbit\"\n)\n\nVERIFIED_COUNT=0\nTOTAL_COUNT=${#TOOLS[@]}\n\nfor tool_info in \"${TOOLS[@]}\"; do\n    IFS=':' read -r command tool_name <<< \"$tool_info\"\n    \n    if command -v \"$command\" &> /dev/null; then\n        echo \"✅ $tool_name: $(which $command)\"\n        ((VERIFIED_COUNT++))\n    else\n        echo \"⚠️  $tool_name: not accessible\"\n    fi\ndone\n\necho \"\"\necho \"📊 Summary:\"\necho \"  Verified: $VERIFIED_COUNT/$TOTAL_COUNT tools\"\necho \"  Shell: $SHELL_NAME\"\necho \"  Config: $SHELL_CONFIG\"\n\nif [[ $VERIFIED_COUNT -eq $TOTAL_COUNT ]]; then\n    echo \"\"\n    echo \"🎉 All AI tools are ready to use!\"\n    echo \"\"\n    echo \"📋 Quick commands:\"\n    echo \"  opencode --version     # OpenCode AI\"\n    echo \"  cursor-agent --version # Cursor Agent\"\n    echo \"  codex --version        # OpenAI Codex\"\n    echo \"  gemini --version       # Google Gemini\"\n    echo \"  qwen-code --version    # Qwen Code\"\n    echo \"  coderabbit --version   # CodeRabbit\"\nelse\n    echo \"\"\n    echo \"⚠️  Some tools are not accessible. You may need to:\"\n    echo \"  1. Install missing tools: bash script/ai-tools/install-all-ai-tools.sh\"\n    echo \"  2. Restart your terminal\"\n    echo \"  3. Run this script again: bash script/ai-tools/ai-tools-refresh.sh\"\nfi\n\necho \"\"\necho \"✅ Auto-refresh completed!\"\necho \"💡 Tip: Run this script anytime to refresh your AI tools environment\"\n"
  },
  {
    "path": "ai-tools/install-all-ai-tools.sh",
    "content": "#!/usr/bin/env bash\n\n# Install All AI Tools Script\n# This script installs all available AI tools in one go\n# Compatible with both bash and zsh shells\n\n# Detect shell and set compatibility\nif [[ -n \"${ZSH_VERSION:-}\" ]]; then\n    # Zsh compatibility\n    setopt shwordsplit\n    setopt pipefail\n    setopt errexit\n    setopt nounset\nelse\n    # Bash compatibility\n    set -euo pipefail\nfi\n\necho \"🚀 Installing All AI Tools\"\necho \"=========================\"\necho \"\"\n\n# Colors for output\ndeclare -r C_RESET='\\033[0m'\ndeclare -r C_BOLD='\\033[1m'\ndeclare -r C_RED='\\033[0;31m'\ndeclare -r C_GREEN='\\033[0;32m'\ndeclare -r C_YELLOW='\\033[0;33m'\ndeclare -r C_BLUE='\\033[0;34m'\n\n# Installation results\ndeclare -a INSTALLED_TOOLS=()\ndeclare -a FAILED_TOOLS=()\n\n# Function to install a tool\ninstall_tool() {\n    local tool_name=\"$1\"\n    local script_path=\"script/ai-tools/$tool_name\"\n    \n    echo -e \"${C_BLUE}Installing $tool_name...${C_RESET}\"\n    echo \"----------------------------------------\"\n    \n    if [[ -f \"$script_path\" ]]; then\n        if bash \"$script_path\"; then\n            echo -e \"${C_GREEN}✅ $tool_name installed successfully${C_RESET}\"\n            INSTALLED_TOOLS+=(\"$tool_name\")\n        else\n            echo -e \"${C_RED}❌ $tool_name installation failed${C_RESET}\"\n            FAILED_TOOLS+=(\"$tool_name\")\n        fi\n    else\n        echo -e \"${C_RED}❌ Script not found: $script_path${C_RESET}\"\n        FAILED_TOOLS+=(\"$tool_name (script not found)\")\n    fi\n    \n    echo \"\"\n}\n\n# Check prerequisites\necho -e \"${C_BOLD}Checking Prerequisites:${C_RESET}\"\n\n# Check Node.js (required for most tools)\nif command -v node &> /dev/null; then\n    echo -e \"${C_GREEN}✅ Node.js: $(node --version)${C_RESET}\"\nelse\n    echo -e \"${C_YELLOW}⚠️  Node.js not found - some tools may not work${C_RESET}\"\nfi\n\n# Check npm\nif command -v npm &> /dev/null; then\n    echo -e \"${C_GREEN}✅ npm: $(npm --version)${C_RESET}\"\nelse\n    echo -e \"${C_YELLOW}⚠️  npm not found - some tools may not work${C_RESET}\"\nfi\n\n# Check curl\nif command -v curl &> /dev/null; then\n    echo -e \"${C_GREEN}✅ curl: available${C_RESET}\"\nelse\n    echo -e \"${C_YELLOW}⚠️  curl not found - some tools may not work${C_RESET}\"\nfi\n\necho \"\"\necho -e \"${C_BOLD}Starting Installation:${C_RESET}\"\necho \"\"\n\n# Install all AI tools\ninstall_tool \"opencode.sh\"\ninstall_tool \"codex-install.sh\"\ninstall_tool \"gemini-install.sh\"\ninstall_tool \"qwen-install.sh\"\ninstall_tool \"coderabbit-install.sh\"\ninstall_tool \"cursor-install.sh\"\n\n# Auto-refresh AI tools environment\necho -e \"${C_BLUE}Auto-refreshing AI tools environment...${C_RESET}\"\nif bash script/ai-tools/ai-tools-refresh.sh; then\n    echo -e \"${C_GREEN}✅ AI tools environment refreshed${C_RESET}\"\nelse\n    echo -e \"${C_YELLOW}⚠️  AI tools environment refresh failed${C_RESET}\"\nfi\n\necho \"\"\n\n# Summary\necho -e \"${C_BOLD}Installation Summary:${C_RESET}\"\necho \"=====================\"\necho \"\"\n\nif [[ ${#INSTALLED_TOOLS[@]} -gt 0 ]]; then\n    echo -e \"${C_GREEN}✅ Successfully Installed (${#INSTALLED_TOOLS[@]}):${C_RESET}\"\n    for tool in \"${INSTALLED_TOOLS[@]}\"; do\n        echo -e \"  ${C_GREEN}✓${C_RESET} $tool\"\n    done\n    echo \"\"\nfi\n\nif [[ ${#FAILED_TOOLS[@]} -gt 0 ]]; then\n    echo -e \"${C_RED}❌ Failed Installations (${#FAILED_TOOLS[@]}):${C_RESET}\"\n    for tool in \"${FAILED_TOOLS[@]}\"; do\n        echo -e \"  ${C_RED}✗${C_RESET} $tool\"\n    done\n    echo \"\"\nfi\n\n# Next steps\necho -e \"${C_BOLD}Next Steps:${C_RESET}\"\necho \"===========\"\necho \"\"\nif [[ -n \"${ZSH_VERSION:-}\" ]]; then\n    echo \"1. Restart your terminal or run: source ~/.zshrc\"\n    echo \"💡 Shell detected: zsh\"\nelse\n    echo \"1. Restart your terminal or run: source ~/.bashrc\"\n    echo \"💡 Shell detected: bash\"\nfi\necho \"2. Verify installations:\"\necho \"   • opencode --version\"\necho \"   • codex --version\"\necho \"   • gemini --version\"\necho \"   • qwen-code --version\"\necho \"   • coderabbit --version\"\necho \"   • cursor (check applications menu)\"\necho \"\"\necho \"3. Configure API keys as needed:\"\necho \"   • OpenAI: https://platform.openai.com/api-keys\"\necho \"   • Google: https://aistudio.google.com/app/apikey\"\necho \"   • CodeRabbit: https://coderabbit.ai\"\necho \"\"\necho \"4. Start using your AI tools!\"\necho \"\"\n\nif [[ ${#FAILED_TOOLS[@]} -eq 0 ]]; then\n    echo -e \"${C_GREEN}🎉 All AI tools installed successfully!${C_RESET}\"\n    exit 0\nelse\n    echo -e \"${C_YELLOW}⚠️  Some installations failed. Check the errors above.${C_RESET}\"\n    exit 1\nfi\n"
  },
  {
    "path": "ai-tools/qwen-install.sh",
    "content": "#!/usr/bin/env bash\n\n# Qwen Code CLI Installation Script\n# This script installs Qwen Code CLI tool globally using npm\n# Compatible with both bash and zsh shells\n\n# Detect shell and set compatibility\nif [[ -n \"${ZSH_VERSION:-}\" ]]; then\n    # Zsh compatibility\n    setopt shwordsplit\n    setopt pipefail\n    setopt errexit\n    setopt nounset\nelse\n    # Bash compatibility\n    set -euo pipefail\nfi\n\necho \"🤖 Installing Qwen Code CLI...\"\necho \"===============================\"\n\n# Check if Node.js is installed\nif ! command -v node &> /dev/null; then\n    echo \"❌ Error: Node.js is required but not installed.\"\n    echo \"Please install Node.js first:\"\n    echo \"  Ubuntu/Debian: curl -fsSL https://deb.nodesource.com/setup_lts.x | sudo -E bash - && sudo apt-get install -y nodejs\"\n    echo \"  CentOS/RHEL: curl -fsSL https://rpm.nodesource.com/setup_lts.x | sudo -E bash - && sudo yum install -y nodejs\"\n    echo \"  macOS: brew install node\"\n    echo \"  Or visit: https://nodejs.org/\"\n    exit 1\nfi\n\n# Check if npm is available\nif ! command -v npm &> /dev/null; then\n    echo \"❌ Error: npm is required but not installed.\"\n    echo \"npm should come with Node.js installation.\"\n    exit 1\nfi\n\n# Display current Node.js and npm versions\necho \"📋 Current versions:\"\necho \"  Node.js: $(node --version)\"\necho \"  npm: $(npm --version)\"\necho \"\"\n\n# Install Qwen Code CLI globally\necho \"📥 Installing @qwen-code/qwen-code@latest globally...\"\nif npm install -g @qwen-code/qwen-code@latest; then\n    echo \"\"\n    echo \"✅ Qwen Code CLI installation completed!\"\n    \n    # Try to verify installation\n    echo \"🔍 Verifying installation...\"\n    if command -v qwen-code &> /dev/null; then\n        echo \"✅ Qwen Code command found: $(which qwen-code)\"\n        if qwen-code --version &> /dev/null; then\n            echo \"✅ Qwen Code version: $(qwen-code --version)\"\n        else\n            echo \"⚠️  Qwen Code installed but version check failed\"\n        fi\n    else\n        echo \"⚠️  Qwen Code installed but command not found in PATH\"\n        if [[ -n \"${ZSH_VERSION:-}\" ]]; then\n            echo \"   You may need to restart your terminal or run: source ~/.zshrc\"\n        else\n            echo \"   You may need to restart your terminal or run: source ~/.bashrc\"\n        fi\n    fi\n    \n    echo \"\"\n    echo \"📋 Next steps:\"\n    if [[ -n \"${ZSH_VERSION:-}\" ]]; then\n        echo \"1. Restart your terminal or run: source ~/.zshrc\"\n        echo \"💡 Shell detected: zsh\"\n    else\n        echo \"1. Restart your terminal or run: source ~/.bashrc\"\n        echo \"💡 Shell detected: bash\"\n    fi\necho \"2. Verify installation: qwen-code --version\"\necho \"3. Configure your API settings: qwen-code config\"\necho \"4. Start using Qwen Code: qwen-code\"\necho \"\"\necho \"🔑 Don't forget to set up your API configuration!\"\necho \"   Visit: https://github.com/QwenLM/Qwen-Code for more information\"\necho \"\"\necho \"🎉 Happy coding with Qwen Code!\"\nelse\n    echo \"\"\n    echo \"❌ Qwen Code CLI installation failed!\"\n    echo \"Please check your internet connection and npm configuration.\"\n    echo \"You can also try: npm install -g @qwen-code/qwen-code@latest\"\n    exit 1\nfi\n"
  },
  {
    "path": "ai-tools/gemini-install.sh",
    "content": "#!/usr/bin/env bash\n\n# Google Gemini CLI Installation Script\n# This script installs Google Gemini CLI tool globally using npm\n# Compatible with both bash and zsh shells\n\n# Detect shell and set compatibility\nif [[ -n \"${ZSH_VERSION:-}\" ]]; then\n    # Zsh compatibility\n    setopt shwordsplit\n    setopt pipefail\n    setopt errexit\n    setopt nounset\nelse\n    # Bash compatibility\n    set -euo pipefail\nfi\n\necho \"🤖 Installing Google Gemini CLI...\"\necho \"==================================\"\n\n# Check if Node.js is installed\nif ! command -v node &> /dev/null; then\n    echo \"❌ Error: Node.js is required but not installed.\"\n    echo \"Please install Node.js first:\"\n    echo \"  Ubuntu/Debian: curl -fsSL https://deb.nodesource.com/setup_lts.x | sudo -E bash - && sudo apt-get install -y nodejs\"\n    echo \"  CentOS/RHEL: curl -fsSL https://rpm.nodesource.com/setup_lts.x | sudo -E bash - && sudo yum install -y nodejs\"\n    echo \"  macOS: brew install node\"\n    echo \"  Or visit: https://nodejs.org/\"\n    exit 1\nfi\n\n# Check if npm is available\nif ! command -v npm &> /dev/null; then\n    echo \"❌ Error: npm is required but not installed.\"\n    echo \"npm should come with Node.js installation.\"\n    exit 1\nfi\n\n# Display current Node.js and npm versions\necho \"📋 Current versions:\"\necho \"  Node.js: $(node --version)\"\necho \"  npm: $(npm --version)\"\necho \"\"\n\n# Install Google Gemini CLI globally\necho \"📥 Installing @google/gemini-cli globally...\"\nif npm install -g @google/gemini-cli; then\n    echo \"\"\n    echo \"✅ Google Gemini CLI installation completed!\"\n    \n    # Try to verify installation\n    echo \"🔍 Verifying installation...\"\n    if command -v gemini &> /dev/null; then\n        echo \"✅ Gemini command found: $(which gemini)\"\n        if gemini --version &> /dev/null; then\n            echo \"✅ Gemini version: $(gemini --version)\"\n        else\n            echo \"⚠️  Gemini installed but version check failed\"\n        fi\n    else\n        echo \"⚠️  Gemini installed but command not found in PATH\"\n        if [[ -n \"${ZSH_VERSION:-}\" ]]; then\n            echo \"   You may need to restart your terminal or run: source ~/.zshrc\"\n        else\n            echo \"   You may need to restart your terminal or run: source ~/.bashrc\"\n        fi\n    fi\n    \n    echo \"\"\n    echo \"📋 Next steps:\"\n    if [[ -n \"${ZSH_VERSION:-}\" ]]; then\n        echo \"1. Restart your terminal or run: source ~/.zshrc\"\n        echo \"💡 Shell detected: zsh\"\n    else\n        echo \"1. Restart your terminal or run: source ~/.bashrc\"\n        echo \"💡 Shell detected: bash\"\n    fi\necho \"2. Verify installation: gemini --version\"\necho \"3. Configure your Google API key: gemini config\"\necho \"4. Start using Gemini: gemini\"\necho \"\"\necho \"🔑 Don't forget to set up your Google API key!\"\necho \"   Get your API key from: https://aistudio.google.com/app/apikey\"\necho \"\"\necho \"🎉 Happy coding with Google Gemini!\"\nelse\n    echo \"\"\n    echo \"❌ Google Gemini CLI installation failed!\"\n    echo \"Please check your internet connection and npm configuration.\"\n    echo \"You can also try: npm install -g @google/gemini-cli\"\n    exit 1\nfi\n"
  },
  {
    "path": "ai-tools/codex-install.sh",
    "content": "#!/usr/bin/env bash\n\n# OpenAI Codex Installation Script\n# This script installs OpenAI Codex CLI tool globally using npm\n# Compatible with both bash and zsh shells\n\n# Detect shell and set compatibility\nif [[ -n \"${ZSH_VERSION:-}\" ]]; then\n    # Zsh compatibility\n    setopt shwordsplit\n    setopt pipefail\n    setopt errexit\n    setopt nounset\nelse\n    # Bash compatibility\n    set -euo pipefail\nfi\n\necho \"🤖 Installing OpenAI Codex CLI...\"\necho \"==================================\"\n\n# Check if Node.js is installed\nif ! command -v node &> /dev/null; then\n    echo \"❌ Error: Node.js is required but not installed.\"\n    echo \"Please install Node.js first:\"\n    echo \"  Ubuntu/Debian: curl -fsSL https://deb.nodesource.com/setup_lts.x | sudo -E bash - && sudo apt-get install -y nodejs\"\n    echo \"  CentOS/RHEL: curl -fsSL https://rpm.nodesource.com/setup_lts.x | sudo -E bash - && sudo yum install -y nodejs\"\n    echo \"  macOS: brew install node\"\n    echo \"  Or visit: https://nodejs.org/\"\n    exit 1\nfi\n\n# Check if npm is available\nif ! command -v npm &> /dev/null; then\n    echo \"❌ Error: npm is required but not installed.\"\n    echo \"npm should come with Node.js installation.\"\n    exit 1\nfi\n\n# Display current Node.js and npm versions\necho \"📋 Current versions:\"\necho \"  Node.js: $(node --version)\"\necho \"  npm: $(npm --version)\"\necho \"\"\n\n# Install OpenAI Codex globally\necho \"📥 Installing @openai/codex globally...\"\nif npm install -g @openai/codex; then\n    echo \"\"\n    echo \"✅ OpenAI Codex installation completed!\"\n    \n    # Try to verify installation\n    echo \"🔍 Verifying installation...\"\n    if command -v codex &> /dev/null; then\n        echo \"✅ Codex command found: $(which codex)\"\n        if codex --version &> /dev/null; then\n            echo \"✅ Codex version: $(codex --version)\"\n        else\n            echo \"⚠️  Codex installed but version check failed\"\n        fi\n    else\n        echo \"⚠️  Codex installed but command not found in PATH\"\n        if [[ -n \"${ZSH_VERSION:-}\" ]]; then\n            echo \"   You may need to restart your terminal or run: source ~/.zshrc\"\n        else\n            echo \"   You may need to restart your terminal or run: source ~/.bashrc\"\n        fi\n    fi\n    \n    echo \"\"\n    echo \"📋 Next steps:\"\n    if [[ -n \"${ZSH_VERSION:-}\" ]]; then\n        echo \"1. Restart your terminal or run: source ~/.zshrc\"\n        echo \"💡 Shell detected: zsh\"\n    else\n        echo \"1. Restart your terminal or run: source ~/.bashrc\"\n        echo \"💡 Shell detected: bash\"\n    fi\necho \"2. Verify installation: codex --version\"\necho \"3. Configure your OpenAI API key: codex config\"\necho \"4. Start using Codex: codex\"\necho \"\"\necho \"🔑 Don't forget to set up your OpenAI API key!\"\necho \"   Get your API key from: https://platform.openai.com/api-keys\"\necho \"\"\necho \"🎉 Happy coding with OpenAI Codex!\"\nelse\n    echo \"\"\n    echo \"❌ OpenAI Codex installation failed!\"\n    echo \"Please check your internet connection and npm configuration.\"\n    echo \"You can also try: npm install -g @openai/codex\"\n    exit 1\nfi\n"
  },
  {
    "path": "Programming-Lang/ocaml.sh",
    "content": "#!/usr/bin/env bash\n# Installer OCaml + OPAM untuk Linux\n# By Hendra 😎\n\nset -euo pipefail\n\nneed_cmd() { command -v \"$1\" >/dev/null 2>&1; }\nas_root() {\n  if [ \"${EUID:-$(id -u)}\" -ne 0 ]; then\n    if need_cmd sudo; then sudo \"$@\"; else\n      echo \"Butuh root. Install sudo atau jalankan sebagai root.\" >&2\n      exit 1\n    fi\n  else\n    \"$@\"\n  fi\n}\n\nlog() { printf \"\\033[1;32m==>\\033[0m %s\\n\" \"$*\"; }\nerr() { printf \"\\033[1;31mxx\\033[0m %s\\n\" \"$*\" >&2; exit 1; }\n\n# ---------- Deteksi package manager ----------\nPKG_MGR=\"\"\ndetect_pkg_mgr() {\n  if need_cmd pacman; then PKG_MGR=\"pacman\"\n  elif need_cmd apt-get; then PKG_MGR=\"apt\"\n  elif need_cmd dnf; then PKG_MGR=\"dnf\"\n  elif need_cmd yum; then PKG_MGR=\"yum\"\n  elif need_cmd zypper; then PKG_MGR=\"zypper\"\n  elif need_cmd apk; then PKG_MGR=\"apk\"\n  else\n    err \"Tidak menemukan package manager yang didukung.\"\n  fi\n}\n\n# ---------- Install deps ----------\ninstall_deps() {\n  log \"Menginstall dependency dasar...\"\n  case \"$PKG_MGR\" in\n    pacman) as_root pacman -Sy --noconfirm curl m4 git unzip ;;\n    apt) as_root apt-get update -y && as_root apt-get install -y curl m4 git unzip bubblewrap ;;\n    dnf) as_root dnf install -y curl m4 git unzip ;;\n    yum) as_root yum install -y curl m4 git unzip ;;\n    zypper) as_root zypper --non-interactive install curl m4 git unzip ;;\n    apk) as_root apk add --no-cache curl m4 git unzip ;;\n  esac\n}\n\n# ---------- Install opam ----------\ninstall_opam() {\n  if need_cmd opam; then\n    log \"opam sudah terpasang.\"\n    return\n  fi\n  log \"Menginstall opam...\"\n  case \"$PKG_MGR\" in\n    pacman) as_root pacman -Sy --noconfirm opam ;;\n    apt) as_root apt-get install -y opam ;;\n    dnf) as_root dnf install -y opam ;;\n    yum) as_root yum install -y opam ;;\n    zypper) as_root zypper --non-interactive install opam ;;\n    apk) \n      log \"Membangun opam dari script resmi...\"\n      sh <(curl -fsSL https://raw.githubusercontent.com/ocaml/opam/master/shell/install.sh)\n      ;;\n  esac\n}\n\n# ---------- Init & Install OCaml ----------\ninstall_ocaml() {\n  if [ ! -d \"$HOME/.opam\" ]; then\n    log \"Inisialisasi opam...\"\n    opam init -y --disable-sandboxing\n  fi\n\n  log \"Memasang OCaml stable terbaru...\"\n  opam switch create default ocaml-base-compiler.latest || true\n\n  eval \"$(opam env)\"\n}\n\n# ---------- Setup PATH ----------\nsetup_path() {\n  if ! grep -qs 'opam env' \"$HOME/.bashrc\" 2>/dev/null; then\n    echo 'eval \"$(opam env)\"' >> \"$HOME/.bashrc\"\n  fi\n}\n\n# ---------- Verifikasi ----------\nverify_ocaml() {\n  log \"Verifikasi instalasi:\"\n  ocaml -version\n  opam --version\n}\n\n# ---------- Main ----------\nmain() {\n  detect_pkg_mgr\n  install_deps\n  install_opam\n  install_ocaml\n  setup_path\n  verify_ocaml\n  log \"Instalasi OCaml selesai 🎉. Jalankan: ocaml -version\"\n}\n\nmain \"$@\"\n"
  },
  {
    "path": "Programming-Lang/elixir.sh",
    "content": "#!/usr/bin/env bash\n# Installer Elixir + Erlang untuk Linux\n# By Hendra 😎\n\nset -euo pipefail\n\nneed_cmd() { command -v \"$1\" >/dev/null 2>&1; }\nas_root() {\n  if [ \"${EUID:-$(id -u)}\" -ne 0 ]; then\n    if need_cmd sudo; then sudo \"$@\"; else\n      echo \"Butuh root. Install sudo atau jalankan sebagai root.\" >&2\n      exit 1\n    fi\n  else\n    \"$@\"\n  fi\n}\n\nlog() { printf \"\\033[1;32m==>\\033[0m %s\\n\" \"$*\"; }\nerr() { printf \"\\033[1;31mxx\\033[0m %s\\n\" \"$*\" >&2; exit 1; }\n\n# ---------- Deteksi package manager ----------\nPKG_MGR=\"\"\ndetect_pkg_mgr() {\n  if need_cmd pacman; then PKG_MGR=\"pacman\"\n  elif need_cmd apt-get; then PKG_MGR=\"apt\"\n  elif need_cmd dnf; then PKG_MGR=\"dnf\"\n  elif need_cmd yum; then PKG_MGR=\"yum\"\n  elif need_cmd zypper; then PKG_MGR=\"zypper\"\n  else\n    err \"Tidak menemukan package manager yang didukung.\"\n  fi\n}\n\n# ---------- Install Elixir + Erlang ----------\ninstall_elixir() {\n  case \"$PKG_MGR\" in\n    pacman)\n      log \"Menginstall Elixir + Erlang (Arch/Manjaro)...\"\n      as_root pacman -Sy --noconfirm elixir erlang\n      ;;\n    apt)\n      log \"Menginstall Erlang/Elixir (Debian/Ubuntu)...\"\n      as_root apt-get update -y\n      as_root apt-get install -y curl gnupg\n      curl -fsSL https://packages.erlang-solutions.com/erlang-solutions_2.0_all.deb -o esl.deb\n      as_root dpkg -i esl.deb\n      rm esl.deb\n      as_root apt-get update -y\n      as_root apt-get install -y esl-erlang elixir\n      ;;\n    dnf)\n      log \"Menginstall Erlang/Elixir (Fedora/RHEL)...\"\n      as_root dnf install -y erlang elixir\n      ;;\n    yum)\n      log \"Menginstall Erlang/Elixir (CentOS)...\"\n      as_root yum install -y erlang elixir\n      ;;\n    zypper)\n      log \"Menginstall Erlang/Elixir (openSUSE)...\"\n      as_root zypper --non-interactive install erlang elixir\n      ;;\n    *)\n      err \"Tidak ada metode instalasi untuk package manager: $PKG_MGR\"\n      ;;\n  esac\n}\n\n# ---------- Verifikasi ----------\nverify_elixir() {\n  log \"Verifikasi instalasi:\"\n  elixir --version\n}\n\n# ---------- Main ----------\nmain() {\n  detect_pkg_mgr\n  install_elixir\n  verify_elixir\n  log \"Instalasi Elixir selesai 🎉. Jalankan: elixir --version\"\n}\n\nmain \"$@\"\n"
  },
  {
    "path": "Programming-Lang/miniconda.sh",
    "content": "#!/bin/bash\n\n# Cek apakah Miniconda sudah terinstall\nif command -v conda &>/dev/null; then\n\techo \"Miniconda sudah terinstall. Instalasi dibatalkan.\"\n\texit 0\nfi\n\n# URL Miniconda\nminiconda_url=\"https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh\"\n\n# Nama file untuk penyimpanan\ninstaller_script=\"Miniconda3-latest-Linux-x86_64.sh\"\n\n# Unduh skrip instalasi Miniconda\nwget \"$miniconda_url\" -O \"$installer_script\"\n\n# Berikan izin eksekusi pada skrip\nchmod +x \"$installer_script\"\n\n# Jalankan instalasi secara interaktif\n./\"$installer_script\"\n\n# Hapus skrip instalasi setelah selesai\nrm \"$installer_script\""
  },
  {
    "path": "Programming-Lang/docker.sh",
    "content": "#!/usr/bin/env bash\n# needs-sudo\n# Universal Docker installer (apt/dnf/pacman/zypper/apk)\n# By Hendra’s request\n\nset -euo pipefail\n\n# ============================ Utils ============================\nlog()  { printf \"\\033[1;32m==>\\033[0m %s\\n\" \"$*\"; }\nwarn() { printf \"\\033[1;33m!!\\033[0m %s\\n\" \"$*\" >&2; }\nerr()  { printf \"\\033[1;31mxx\\033[0m %s\\n\" \"$*\" >&2; exit 1; }\nneed() { command -v \"$1\" >/dev/null 2>&1; }\n\n[ \"${EUID:-$(id -u)}\" -eq 0 ] || err \"Harap jalankan sebagai root atau gunakan sudo.\"\n\n# Flags\nAUTO_YES=\"${AUTO_YES:-0}\"       # 1 = non-interactive\nADD_USER=\"${ADD_USER:-0}\"       # 1 = auto add current login user to 'docker'\nCONFIGURE_DAEMON=\"${CONFIGURE_DAEMON:-1}\"  # 1 = tulis daemon.json\nwhile [[ \"${1:-}\" =~ ^- ]]; do\n  case \"$1\" in\n    -y|--yes|--non-interactive) AUTO_YES=1 ;;\n    --add-user) ADD_USER=1 ;;\n    --no-daemon-json) CONFIGURE_DAEMON=0 ;;\n    -h|--help)\n      cat <<EOF\nUsage: $0 [options]\n  -y, --yes                Non-interactive (jawab \"ya\" otomatis)\n      --add-user           Tambahkan user aktif ke grup docker\n      --no-daemon-json     Jangan tulis /etc/docker/daemon.json\nEnv:\n  AUTO_YES=1, ADD_USER=1, CONFIGURE_DAEMON=0 (sama seperti flags)\nEOF\n      exit 0\n      ;;\n    *) err \"Unknown option: $1\" ;;\n  esac\n  shift\ndone\n\n# Detect OS\nOS_ID=\"\"; OS_VER_CODENAME=\"\"; OS_VER_ID=\"\"\nif [ -r /etc/os-release ]; then\n  . /etc/os-release\n  OS_ID=\"${ID:-}\"; OS_VER_CODENAME=\"${VERSION_CODENAME:-}\"; OS_VER_ID=\"${VERSION_ID:-}\"\nelse\n  err \"Tidak dapat mendeteksi distribusi Linux (tidak ada /etc/os-release).\"\nfi\n\nPKG_MGR=\"\"\nif   need apt-get; then PKG_MGR=\"apt\"\nelif need dnf;     then PKG_MGR=\"dnf\"\nelif need yum;     then PKG_MGR=\"yum\"\nelif need pacman;  then PKG_MGR=\"pacman\"\nelif need zypper;  then PKG_MGR=\"zypper\"\nelif need apk;     then PKG_MGR=\"apk\"\nelse err \"Package manager tidak didukung.\"\nfi\n\nis_wsl() { grep -qiE 'microsoft|wsl' /proc/version 2>/dev/null; }\ncan_systemctl() { command -v systemctl >/dev/null 2>&1 && ! is_wsl; }\n\n# ======================= APT (Ubuntu/Debian) ===================\napt_install_docker() {\n  log \"Mendeteksi sistem berbasis Debian/Ubuntu (APT)\"\n  apt-get update -y\n  apt-get install -y ca-certificates curl gnupg lsb-release\n\n  install -m 0755 -d /etc/apt/keyrings\n  if [ ! -f /etc/apt/keyrings/docker.gpg ]; then\n    curl -fsSL \"https://download.docker.com/linux/${OS_ID}/gpg\" | gpg --dearmor -o /etc/apt/keyrings/docker.gpg\n    chmod a+r /etc/apt/keyrings/docker.gpg\n  fi\n\n  # Tentukan codename\n  CODENAME=\"${OS_VER_CODENAME:-}\"\n  if [ -z \"$CODENAME\" ]; then\n    if need lsb_release; then\n      CODENAME=\"$(lsb_release -cs || true)\"\n    fi\n  fi\n  [ -n \"$CODENAME\" ] || err \"Tidak bisa menentukan VERSION_CODENAME untuk APT.\"\n\n  echo \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/${OS_ID} ${CODENAME} stable\" \\\n    >/etc/apt/sources.list.d/docker.list\n\n  apt-get update -y\n  apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n}\n\n# ======== DNF/YUM (RHEL/CentOS/Alma/Rocky/Fedora/SLES) ========\ndnf_install_docker() {\n  log \"Mendeteksi sistem berbasis RHEL/Fedora (DNF/YUM)\"\n  # Enable repo resmi Docker\n  if [ \"$OS_ID\" = \"fedora\" ]; then\n    dnf -y install dnf-plugins-core\n    dnf config-manager --add-repo https://download.docker.com/linux/fedora/docker-ce.repo\n  else\n    # rhel/centos/alma/rocky\n    ${PKG_MGR} -y install dnf-plugins-core || true\n    ${PKG_MGR} config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n  fi\n\n  # SELinux policy untuk container (jika tersedia)\n  ${PKG_MGR} -y install container-selinux || true\n\n  ${PKG_MGR} -y install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n}\n\n# ======================== pacman (Arch) ========================\npacman_install_docker() {\n  log \"Mendeteksi Arch/Manjaro (pacman)\"\n  pacman -Sy --noconfirm --needed docker docker-compose\n}\n\n# ======================= zypper (openSUSE) =====================\nzypper_install_docker() {\n  log \"Mendeteksi openSUSE/SLES (zypper)\"\n  zypper --non-interactive refresh\n  # openSUSE biasanya menyediakan docker langsung dari repo resmi\n  zypper --non-interactive install docker docker-compose || zypper --non-interactive install docker\n}\n\n# ========================= apk (Alpine) ========================\napk_install_docker() {\n  log \"Mendeteksi Alpine (apk)\"\n  apk add --no-cache docker docker-cli-compose docker-buildx\n}\n\n# ========================= Common tasks ========================\nconfigure_daemon_json() {\n  [ \"$CONFIGURE_DAEMON\" -eq 1 ] || return 0\n\n  install -d -m 0755 /etc/docker\n  DAEMON_JSON='/etc/docker/daemon.json'\n  if [ ! -f \"$DAEMON_JSON\" ]; then\n    cat >\"$DAEMON_JSON\" <<'JSON'\n{\n  \"log-driver\": \"json-file\",\n  \"log-opts\": {\n    \"max-size\": \"10m\",\n    \"max-file\": \"3\"\n  },\n  \"exec-opts\": [\"native.cgroupdriver=systemd\"]\n}\nJSON\n    log \"Menulis $DAEMON_JSON (log rotation + cgroupdriver=systemd)\"\n  else\n    warn \"$DAEMON_JSON sudah ada, tidak diubah.\"\n  fi\n}\n\nenable_start_service() {\n  if can_systemctl; then\n    systemctl daemon-reload || true\n    systemctl enable --now docker\n  else\n    warn \"systemd tidak tersedia (mungkin WSL). Lewati enable/start service.\"\n  fi\n}\n\npost_check() {\n  log \"Verifikasi versi:\"\n  docker --version || true\n  if docker compose version >/dev/null 2>&1; then\n    docker compose version\n  elif command -v docker-compose >/dev/null 2>&1; then\n    docker-compose --version\n  else\n    warn \"Plugin compose tidak terdeteksi.\"\n  fi\n}\n\nmaybe_add_user() {\n  local do_add=\"$ADD_USER\"\n  if [ \"$AUTO_YES\" -eq 0 ] && [ \"$ADD_USER\" -eq 0 ]; then\n    read -rp \"Tambah user saat ini ke grup docker agar tidak perlu sudo? (y/n): \" ans\n    [[ \"$ans\" =~ ^[Yy]$ ]] && do_add=1\n  fi\n\n  if [ \"$do_add\" -eq 1 ]; then\n    # logname bisa gagal di sudo non-tty; fallback ke SUDO_USER/USER\n    CURRENT_USER=\"$(logname 2>/dev/null || echo \"${SUDO_USER:-${USER:-}}\" )\"\n    if [ -n \"$CURRENT_USER\" ]; then\n      usermod -aG docker \"$CURRENT_USER\"\n      log \"User '$CURRENT_USER' ditambahkan ke grup docker. Logout/login agar efektif.\"\n    else\n      warn \"Tidak bisa menentukan user aktif; lewati penambahan ke grup docker.\"\n    fi\n  fi\n}\n\nalready_installed() {\n  if command -v docker >/dev/null 2>&1; then\n    log \"Docker sudah terpasang: $(docker --version 2>/dev/null || true)\"\n    return 0\n  fi\n  return 1\n}\n\n# ============================ Main =============================\nlog \"Distro: ${OS_ID} ${OS_VER_ID} (${OS_VER_CODENAME:-})  | PkgMgr: ${PKG_MGR}\"\n\nif already_installed; then\n  warn \"Lewati instalasi paket inti (sudah ada). Tetap akan konfigurasi service & daemon.json.\"\nelse\n  case \"$PKG_MGR\" in\n    apt)    apt_install_docker ;;\n    dnf|yum) dnf_install_docker ;;\n    pacman) pacman_install_docker ;;\n    zypper) zypper_install_docker ;;\n    apk)    apk_install_docker ;;\n    *) err \"Pkg mgr tidak didukung: $PKG_MGR\" ;;\n  esac\nfi\n\n# Konfigurasi opsional\nconfigure_daemon_json\nenable_start_service\npost_check\nmaybe_add_user\n\necho\necho \"✅ Selesai. Coba: docker run --rm hello-world\"\n"
  },
  {
    "path": "Programming-Lang/rust.sh",
    "content": "#!/usr/bin/env bash\n# Installer Rust otomatis + auto-deps untuk Linux\n# By Hendra 😎\n\nset -euo pipefail\n\nneed_cmd() { command -v \"$1\" >/dev/null 2>&1; }\nas_root() {\n  if [ \"${EUID:-$(id -u)}\" -ne 0 ]; then\n    if need_cmd sudo; then sudo \"$@\"; else\n      echo \"Butuh root. Install sudo atau jalankan sebagai root.\" >&2\n      exit 1\n    fi\n  else\n    \"$@\"\n  fi\n}\n\nlog() { printf \"\\033[1;32m==>\\033[0m %s\\n\" \"$*\"; }\nerr() { printf \"\\033[1;31mxx\\033[0m %s\\n\" \"$*\" >&2; exit 1; }\n\n# ---------- Deteksi package manager ----------\nPKG_MGR=\"\"\ndetect_pkg_mgr() {\n  if need_cmd pacman; then PKG_MGR=\"pacman\"\n  elif need_cmd apt-get; then PKG_MGR=\"apt\"\n  elif need_cmd dnf; then PKG_MGR=\"dnf\"\n  elif need_cmd yum; then PKG_MGR=\"yum\"\n  elif need_cmd zypper; then PKG_MGR=\"zypper\"\n  elif need_cmd apk; then PKG_MGR=\"apk\"\n  else\n    err \"Tidak menemukan package manager yang didukung.\"\n  fi\n}\n\n# ---------- Install curl jika belum ada ----------\ninstall_curl() {\n  if need_cmd curl; then\n    log \"curl sudah terpasang.\"\n    return\n  fi\n\n  log \"Menginstall curl...\"\n  case \"$PKG_MGR\" in\n    pacman) as_root pacman -Sy --noconfirm curl ;;\n    apt) as_root apt-get update -y && as_root apt-get install -y curl ;;\n    dnf) as_root dnf install -y curl ;;\n    yum) as_root yum install -y curl ;;\n    zypper) as_root zypper --non-interactive install curl ;;\n    apk) as_root apk add --no-cache curl ;;\n  esac\n}\n\n# ---------- Install Rust ----------\ninstall_rust() {\n  log \"Menginstall Rust via rustup...\"\n  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y\n}\n\n# ---------- Load PATH & verifikasi ----------\nverify_rust() {\n  # shellcheck disable=SC1090\n  [ -f \"$HOME/.cargo/env\" ] && source \"$HOME/.cargo/env\"\n  log \"Verifikasi Rust:\"\n  rustc --version\n  cargo --version\n}\n\n# ---------- Main ----------\nmain() {\n  detect_pkg_mgr\n  install_curl\n  install_rust\n  verify_rust\n  log \"Instalasi selesai 🎉. Jalankan 'source ~/.cargo/env' jika PATH belum aktif.\"\n}\n\nmain \"$@\"\n"
  },
  {
    "path": "Programming-Lang/zig.sh",
    "content": "#!/usr/bin/env bash\n# Installer Zig untuk Linux\n# By Hendra 😎\n\nset -euo pipefail\n\nneed_cmd() { command -v \"$1\" >/dev/null 2>&1; }\nas_root() {\n  if [ \"${EUID:-$(id -u)}\" -ne 0 ]; then\n    if need_cmd sudo; then sudo \"$@\"; else\n      echo \"Butuh root. Install sudo atau jalankan sebagai root.\" >&2\n      exit 1\n    fi\n  else\n    \"$@\"\n  fi\n}\n\nlog() { printf \"\\033[1;32m==>\\033[0m %s\\n\" \"$*\"; }\nerr() { printf \"\\033[1;31mxx\\033[0m %s\\n\" \"$*\" >&2; exit 1; }\n\n# ---------- Deteksi package manager ----------\nPKG_MGR=\"\"\ndetect_pkg_mgr() {\n  if need_cmd pacman; then PKG_MGR=\"pacman\"\n  elif need_cmd apt-get; then PKG_MGR=\"apt\"\n  elif need_cmd dnf; then PKG_MGR=\"dnf\"\n  elif need_cmd yum; then PKG_MGR=\"yum\"\n  elif need_cmd zypper; then PKG_MGR=\"zypper\"\n  elif need_cmd apk; then PKG_MGR=\"apk\"\n  else\n    err \"Tidak menemukan package manager yang didukung.\"\n  fi\n}\n\n# ---------- Install deps dasar ----------\ninstall_deps() {\n  for dep in curl tar; do\n    if ! need_cmd \"$dep\"; then\n      log \"Menginstall $dep...\"\n      case \"$PKG_MGR\" in\n        pacman) as_root pacman -Sy --noconfirm \"$dep\" ;;\n        apt) as_root apt-get update -y && as_root apt-get install -y \"$dep\" ;;\n        dnf) as_root dnf install -y \"$dep\" ;;\n        yum) as_root yum install -y \"$dep\" ;;\n        zypper) as_root zypper --non-interactive install \"$dep\" ;;\n        apk) as_root apk add --no-cache \"$dep\" ;;\n      esac\n    fi\n  done\n}\n\n# ---------- Install Zig ----------\ninstall_zig() {\n  log \"Mengambil versi terbaru Zig dari GitHub...\"\n  LATEST_URL=$(curl -s https://ziglang.org/download/index.json | grep -Po '\"tarball\":.*?linux-x86_64.*?\\.tar\\.xz\"' | head -n1 | cut -d'\"' -f4)\n  [ -n \"$LATEST_URL\" ] || err \"Tidak bisa menemukan URL release Zig.\"\n\n  mkdir -p \"$HOME/.local/zig\"\n  log \"Mengunduh Zig...\"\n  curl -L \"$LATEST_URL\" -o /tmp/zig.tar.xz\n\n  log \"Mengekstrak Zig...\"\n  tar -xf /tmp/zig.tar.xz -C \"$HOME/.local/zig\" --strip-components=1\n\n  rm /tmp/zig.tar.xz\n}\n\n# ---------- Konfigurasi PATH ----------\nsetup_path() {\n  if ! grep -qs '.local/zig' \"$HOME/.bashrc\" 2>/dev/null; then\n    echo 'export PATH=\"$HOME/.local/zig:$PATH\"' >> \"$HOME/.bashrc\"\n  fi\n  export PATH=\"$HOME/.local/zig:$PATH\"\n}\n\n# ---------- Verifikasi ----------\nverify_zig() {\n  log \"Verifikasi instalasi Zig:\"\n  zig version\n}\n\n# ---------- Main ----------\nmain() {\n  detect_pkg_mgr\n  install_deps\n  install_zig\n  setup_path\n  verify_zig\n  log \"Instalasi Zig selesai 🎉. Jalankan: zig version\"\n}\n\nmain \"$@\"\n"
  },
  {
    "path": "Programming-Lang/golang.sh",
    "content": "#!/bin/bash\n\n# ==============================================================================\n# Skrip Instalasi Go (Golang) - Versi Final Otomatis\n#\n# Perbaikan v3: Membersihkan karakter kutip dari deteksi versi untuk\n#               memastikan nama file unduhan selalu benar.\n# ==============================================================================\n\n# 1. Cek hak akses dan minta sudo jika perlu (Logika Otomatis)\nif [ \"$(id -u)\" -ne 0 ]; then\n    echo \"Skrip ini memerlukan hak akses root (sudo) untuk instalasi.\"\n    echo \"Mencoba menjalankan ulang skrip dengan sudo...\"\n    sudo bash \"$0\" \"$@\"\n    exit $?\nfi\n\n# Mulai dari sini, skrip sudah pasti berjalan dengan hak akses root (sudo)\necho \"✅ Hak akses Sudo diterima. Memulai proses instalasi...\"\necho \"\"\n\n# Hentikan eksekusi jika ada perintah yang gagal\nset -e\n\n# 2. Cek dependensi yang dibutuhkan (wget atau curl)\necho \" Mengecek dependensi (wget atau curl)...\"\nDOWNLOADER=\"\"\nif command -v wget &> /dev/null; then\n    DOWNLOADER=\"wget\"\nelif command -v curl &> /dev/null; then\n    DOWNLOADER=\"curl\"\nelse\n    echo \"❌ Error: 'wget' atau 'curl' tidak ditemukan.\"\n    echo \"   Silakan install salah satunya. Contoh di Debian/Ubuntu:\"\n    echo \"   sudo apt update && sudo apt install wget\"\n    exit 1\nfi\necho \"✅ Siap mengunduh menggunakan '${DOWNLOADER}'.\"\necho \"\"\n\n# 3. Dapatkan versi Go terbaru & arsitektur sistem\necho \" Mencari versi Go terbaru...\"\nLATEST_GO_VERSION=$(curl -s \"https://go.dev/dl/?mode=json\" | grep -oP '\"version\":\\s*\"go\\K[0-9]+\\.[0-9]+(\\.[0-9]+)?\"' | head -n 1)\n\n# --- PERBAIKAN UTAMA ADA DI SINI ---\n# Membersihkan karakter kutip (\") yang mungkin terbawa dari perintah di atas\nLATEST_GO_VERSION=${LATEST_GO_VERSION//\\\"/}\n# --- AKHIR PERBAIKAN ---\n\nif [ -z \"$LATEST_GO_VERSION\" ]; then\n    echo \"❌ Gagal mendapatkan versi Go terbaru. Periksa koneksi internet Anda.\"\n    exit 1\nfi\necho \"✅ Versi Go terbaru yang ditemukan: ${LATEST_GO_VERSION}\"\n\nARCH=$(uname -m)\ncase \"$ARCH\" in\n    x86_64) GO_ARCH=\"amd64\" ;;\n    i686|i386) GO_ARCH=\"386\" ;;\n    aarch64) GO_ARCH=\"arm64\" ;;\n    *)\n        echo \"❌ Arsitektur sistem tidak didukung: ${ARCH}\"\n        exit 1\n        ;;\nesac\necho \"✅ Arsitektur sistem Anda: ${GO_ARCH}\"\necho \"\"\n\n# 4. Proses Unduh dan Instalasi\nGO_FILENAME=\"go${LATEST_GO_VERSION}.linux-${GO_ARCH}.tar.gz\"\nDOWNLOAD_URL=\"https://dl.google.com/go/${GO_FILENAME}\"\n\necho \"⏬ Mengunduh ${GO_FILENAME}...\"\nif [ \"$DOWNLOADER\" = \"wget\" ]; then\n    wget -q --show-progress -O \"${GO_FILENAME}\" \"${DOWNLOAD_URL}\"\nelse # Menggunakan curl\n    curl -L --progress-bar -o \"${GO_FILENAME}\" \"${DOWNLOAD_URL}\"\nfi\necho \"✅ Unduhan selesai.\"\necho \"\"\n\necho \" Membersihkan instalasi Go lama di /usr/local/go (jika ada)...\"\nrm -rf /usr/local/go\necho \"✅ Direktori lama dibersihkan.\"\necho \"\"\n\necho \" Mengekstrak file ke /usr/local...\"\ntar -C /usr/local -xzf \"${GO_FILENAME}\"\necho \"✅ Ekstraksi selesai.\"\necho \"\"\n\necho \"️ Menghapus file arsip yang sudah diunduh...\"\nrm \"${GO_FILENAME}\"\necho \"✅ File arsip dihapus.\"\necho \"\"\n\n# 5. Atur variabel lingkungan (PATH)\nREAL_USER=$(logname 2>/dev/null || echo ${SUDO_USER:-${USER}})\nUSER_HOME=$(getent passwd \"$REAL_USER\" | cut -d: -f6)\nSHELL_PROFILE=\"\"\n\nif [ -f \"$USER_HOME/.zshrc\" ]; then\n    SHELL_PROFILE=\"$USER_HOME/.zshrc\"\nelif [ -f \"$USER_HOME/.bashrc\" ]; then\n    SHELL_PROFILE=\"$USER_HOME/.bashrc\"\nfi\n\nif [ -n \"$SHELL_PROFILE\" ] && [ -f \"$SHELL_PROFILE\" ]; then\n    echo \" Mengkonfigurasi PATH di ${SHELL_PROFILE}\"\n    sed -i '/# Tambahkan Go ke PATH/d' \"$SHELL_PROFILE\"\n    sed -i '/export PATH=\\$PATH:\\/usr\\/local\\/go\\/bin/d' \"$SHELL_PROFILE\"\n    echo '' >> \"$SHELL_PROFILE\"\n    echo '# Tambahkan Go ke PATH' >> \"$SHELL_PROFILE\"\n    echo 'export PATH=$PATH:/usr/local/go/bin' >> \"$SHELL_PROFILE\"\n    chown \"$REAL_USER\":\"$REAL_USER\" \"$SHELL_PROFILE\"\nelse\n    SHELL_PROFILE=\"/etc/profile.d/go.sh\"\n    echo 'export PATH=$PATH:/usr/local/go/bin' > \"$SHELL_PROFILE\"\n    echo \" Mengkonfigurasi PATH untuk semua pengguna di ${SHELL_PROFILE}\"\nfi\n\n# 6. Tampilkan pesan akhir\necho \"================================================================\"\necho \"   SELAMAT! INSTALASI GO BERHASIL TERSIMPAN!            \"\necho \"================================================================\"\necho \"\"\necho \"Verifikasi Versi Go:\"\n/usr/local/go/bin/go version\necho \"\"\necho \"⚠️  TINDAKAN DIPERLUKAN:\"\necho \"   Untuk mulai menggunakan Go, muat ulang shell Anda dengan:\"\necho \"   1. Menutup dan membuka kembali terminal, ATAU\"\necho \"   2. Menjalankan perintah yang sesuai di bawah ini:\"\nif [[ \"$SHELL_PROFILE\" == *\".zshrc\"* ]]; then\n    echo \"      source $USER_HOME/.zshrc\"\nelif [[ \"$SHELL_PROFILE\" == *\".bashrc\"* ]]; then\n    echo \"      source $USER_HOME/.bashrc\"\nelse\n    echo \"      (Silakan logout dan login kembali untuk menerapkan perubahan sistem)\"\nfi\necho \"================================================================\"\n"
  },
  {
    "path": "git-tools/ghup-install.sh",
    "content": "#!/bin/bash\n\n# Ghup CLI Installation Script\n# This script installs Ghup CLI tool globally using npm\n\nset -euo pipefail  # Exit on any error, undefined vars, pipe failures\n\necho \"🚀 Installing Ghup CLI...\"\necho \"=========================\"\n\n# Check if Node.js is installed\nif ! command -v node &> /dev/null; then\n    echo \"❌ Error: Node.js is required but not installed.\"\n    echo \"Please install Node.js first:\"\n    echo \"  Ubuntu/Debian: curl -fsSL https://deb.nodesource.com/setup_lts.x | sudo -E bash - && sudo apt-get install -y nodejs\"\n    echo \"  CentOS/RHEL: curl -fsSL https://rpm.nodesource.com/setup_lts.x | sudo -E bash - && sudo yum install -y nodejs\"\n    echo \"  macOS: brew install node\"\n    echo \"  Or visit: https://nodejs.org/\"\n    exit 1\nfi\n\n# Check if npm is available\nif ! command -v npm &> /dev/null; then\n    echo \"❌ Error: npm is required but not installed.\"\n    echo \"npm should come with Node.js installation.\"\n    exit 1\nfi\n\n# Display current Node.js and npm versions\necho \"📋 Current versions:\"\necho \"  Node.js: $(node --version)\"\necho \"  npm: $(npm --version)\"\necho \"\"\n\n# Install Ghup CLI globally\necho \"📥 Installing ghup globally...\"\nnpm install -g ghup\n\necho \"\"\necho \"✅ Ghup CLI installation completed!\"\necho \"\"\necho \"📋 Next steps:\"\necho \"1. Verify installation: ghup --version\"\necho \"2. Configure your settings: ghup config\"\necho \"3. Start using Ghup: ghup\"\necho \"\"\necho \"🔑 Don't forget to configure your settings!\"\necho \"   Visit: https://github.com/ghup for more information\"\necho \"\"\necho \"🎉 Happy coding with Ghup!\"\n"
  },
  {
    "path": "git-tools/git-config.sh",
    "content": "#!/bin/bash\n\n# Git Configuration Script\n# This script configures Git with user name and email globally\n\nset -euo pipefail  # Exit on any error, undefined vars, pipe failures\n\necho \"⚙️  Git Configuration Setup\"\necho \"==========================\"\n\n# Function to get user input with default value\nget_input() {\n    local prompt=\"$1\"\n    local default=\"$2\"\n    local value\n    \n    if [[ -n \"$default\" ]]; then\n        read -p \"$prompt [$default]: \" value\n        echo \"${value:-$default}\"\n    else\n        read -p \"$prompt: \" value\n        echo \"$value\"\n    fi\n}\n\n# Function to validate email format\nvalidate_email() {\n    local email=\"$1\"\n    if [[ \"$email\" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$ ]]; then\n        return 0\n    else\n        return 1\n    fi\n}\n\n# Get current Git configuration\ncurrent_name=$(git config --global user.name 2>/dev/null || echo \"\")\ncurrent_email=$(git config --global user.email 2>/dev/null || echo \"\")\n\necho \"📋 Current Git Configuration:\"\necho \"  Name: ${current_name:-'Not set'}\"\necho \"  Email: ${current_email:-'Not set'}\"\necho \"\"\n\n# Get user input for name\necho \"🔧 Configure Git User Information\"\necho \"---------------------------------\"\n\nname=$(get_input \"Enter your full name (for commit history)\" \"$current_name\")\n\nif [[ -z \"$name\" ]]; then\n    echo \"❌ Error: Name cannot be empty\"\n    exit 1\nfi\n\n# Get user input for email\nemail=$(get_input \"Enter your email address\" \"$current_email\")\n\nif [[ -z \"$email\" ]]; then\n    echo \"❌ Error: Email cannot be empty\"\n    exit 1\nfi\n\n# Validate email format\nif ! validate_email \"$email\"; then\n    echo \"❌ Error: Invalid email format\"\n    exit 1\nfi\n\n# Confirm configuration\necho \"\"\necho \"📝 Configuration Summary:\"\necho \"  Name: $name\"\necho \"  Email: $email\"\necho \"\"\n\nread -p \"Do you want to apply this configuration? (y/N): \" confirm\nif [[ ! \"$confirm\" =~ ^[Yy]$ ]]; then\n    echo \"❌ Configuration cancelled\"\n    exit 0\nfi\n\n# Apply Git configuration\necho \"\"\necho \"🔧 Applying Git configuration...\"\n\ngit config --global user.name \"$name\"\ngit config --global user.email \"$email\"\n\n# Set additional useful Git configurations\ngit config --global init.defaultBranch main\ngit config --global pull.rebase false\ngit config --global push.default simple\ngit config --global core.editor nano\n\necho \"\"\necho \"✅ Git configuration completed successfully!\"\necho \"\"\necho \"📋 Applied Configuration:\"\necho \"  Name: $(git config --global user.name)\"\necho \"  Email: $(git config --global user.email)\"\necho \"  Default Branch: $(git config --global init.defaultBranch)\"\necho \"  Core Editor: $(git config --global core.editor)\"\necho \"\"\necho \"🎉 Git is now configured and ready to use!\"\necho \"\"\necho \"💡 Next steps:\"\necho \"1. Test your configuration: git config --list --global\"\necho \"2. Create your first repository: git init\"\necho \"3. Make your first commit: git add . && git commit -m 'Initial commit'\"\n"
  },
  {
    "path": "jaringan/info-jaringan.sh",
    "content": "#!/usr/bin/env bash\nset -euo pipefail\n\n# Ringkasan info jaringan komprehensif: IPv4/IPv6, gateway, DNS, status link,\n# MAC, MTU, kecepatan/SSID, dan uji konektivitas. Tanpa root.\n#\n# Opsi:\n#   -i IFACE   Fokus pada interface tertentu\n#   -a         Tampilkan detail semua interface\n#   -j         Output JSON ringkas (tanpa warna)\n#   -h         Bantuan\n\nC_RESET='\\033[0m'\nC_BOLD='\\033[1m'\nC_BLUE='\\033[0;34m'\nC_GREEN='\\033[0;32m'\nC_YELLOW='\\033[0;33m'\nC_RED='\\033[0;31m'\n\ntrim() { sed -e 's/^\\s\\+//' -e 's/\\s\\+$//'; }\n\ndefault_iface() {\n  ip route show default 0.0.0.0/0 2>/dev/null | awk '/default/ {for(i=1;i<=NF;i++) if ($i==\"dev\") {print $(i+1); exit}}'\n}\n\nall_ifaces() {\n  ip -brief link show 2>/dev/null | awk '{print $1}' | grep -v '^lo$' || true\n}\n\niface_operstate() {\n  local ifn=\"$1\"\n  cat \"/sys/class/net/${ifn}/operstate\" 2>/dev/null || echo unknown\n}\n\niface_mac() {\n  local ifn=\"$1\"\n  cat \"/sys/class/net/${ifn}/address\" 2>/dev/null || echo \"?\"\n}\n\niface_mtu() {\n  local ifn=\"$1\"\n  cat \"/sys/class/net/${ifn}/mtu\" 2>/dev/null || echo \"?\"\n}\n\niface_speed_or_ssid() {\n  local ifn=\"$1\"\n  if command -v ethtool >/dev/null 2>&1; then\n    if out=$(ethtool \"$ifn\" 2>/dev/null | awk -F': ' '/Speed:/{print $2; exit}'); then\n      [[ -n \"$out\" ]] && { echo \"$out\"; return; }\n    fi\n  fi\n  # SSID (wifi)\n  if command -v iw >/dev/null 2>&1; then\n    if ssid=$(iw dev \"$ifn\" info 2>/dev/null | awk -F': ' '/ssid/{print $2; exit}'); then\n      [[ -n \"$ssid\" ]] && { echo \"SSID: $ssid\"; return; }\n    fi\n  fi\n  if command -v iwconfig >/dev/null 2>&1; then\n    if ssid=$(iwconfig \"$ifn\" 2>/dev/null | awk -F'ESSID:\"' '/ESSID/{split($2,a,\"\\\"\"); print a[1]; exit}'); then\n      [[ -n \"$ssid\" ]] && { echo \"SSID: $ssid\"; return; }\n    fi\n  fi\n  echo \"-\"\n}\n\niface_ipv4_list() {\n  local ifn=\"$1\"\n  ip -o -4 addr show dev \"$ifn\" 2>/dev/null | awk '{print $4}' || true\n}\n\niface_ipv6_list() {\n  local ifn=\"$1\"\n  ip -o -6 addr show dev \"$ifn\" 2>/dev/null | awk '{print $4}' || true\n}\n\niface_gateway() {\n  local ifn=\"$1\"\n  local gw\n  gw=$(ip route show default dev \"$ifn\" 2>/dev/null | awk '/default/ {print $3; exit}')\n  if [[ -z \"$gw\" ]]; then\n    gw=$(ip route show default 2>/dev/null | awk '/default/ {print $3; exit}')\n  fi\n  echo \"$gw\"\n}\n\ndns_from_resolvectl() {\n  local ifn=\"$1\"\n  if command -v resolvectl >/dev/null 2>&1; then\n    local out\n    out=$(resolvectl dns \"$ifn\" 2>/dev/null || true)\n    if [[ -n \"$out\" ]]; then\n      echo \"$out\" | awk -F': ' 'NF>1 {print $2}'\n      return\n    fi\n    resolvectl status 2>/dev/null | awk '/DNS Servers:/ {for(i=3;i<=NF;i++) printf(\"%s \", $i); print \"\"; exit}'\n  fi\n}\n\ndns_from_resolv_conf() {\n  if [[ -r /etc/resolv.conf ]]; then\n    awk '/^nameserver / {print $2}' /etc/resolv.conf | xargs\n  fi\n}\n\niface_dns() {\n  local ifn=\"$1\"; local dns\n  dns=\"$(dns_from_resolvectl \"$ifn\" 2>/dev/null | xargs || true)\"\n  if [[ -z \"$dns\" ]]; then dns=\"$(dns_from_resolv_conf | xargs || true)\"; fi\n  echo \"$dns\"\n}\n\npublic_ip_v4() {\n  local eps=(\n    \"https://api.ipify.org\"\n    \"https://ipv4.icanhazip.com\"\n    \"https://ifconfig.me/ip\"\n  )\n  if command -v curl >/dev/null 2>&1; then\n    local ip\n    for u in \"${eps[@]}\"; do\n      if ip=$(curl -4 -fsS --max-time 4 \"$u\" 2>/dev/null | tr -d '\\r' | trim); then\n        [[ -n \"$ip\" ]] && { echo \"$ip\"; return 0; }\n      fi\n    done\n  fi\n  if command -v dig >/dev/null 2>&1; then\n    if ip=$(dig +short -4 myip.opendns.com @resolver1.opendns.com 2>/dev/null | head -n1 | trim); then\n      [[ -n \"$ip\" ]] && { echo \"$ip\"; return 0; }\n    fi\n  fi\n  echo \"\"\n}\n\npublic_ip_v6() {\n  local eps=(\n    \"https://api6.ipify.org\"\n    \"https://ipv6.icanhazip.com\"\n  )\n  if command -v curl >/dev/null 2>&1; then\n    local ip\n    for u in \"${eps[@]}\"; do\n      if ip=$(curl -6 -fsS --max-time 4 \"$u\" 2>/dev/null | tr -d '\\r' | trim); then\n        [[ -n \"$ip\" ]] && { echo \"$ip\"; return 0; }\n      fi\n    done\n  fi\n  echo \"\"\n}\n\ntest_ping() {\n  local target=\"$1\"; shift\n  ping -c1 -W1 \"$target\" >/dev/null 2>&1 && echo ok || echo fail\n}\n\njson_escape() { sed -e 's/\\\\/\\\\\\\\/g' -e 's/\"/\\\\\"/g'; }\n\nprint_iface_block() {\n  local ifn=\"$1\"\n  local state mac mtu spd dns gw v4 v6\n  state=\"$(iface_operstate \"$ifn\")\"\n  mac=\"$(iface_mac \"$ifn\")\"\n  mtu=\"$(iface_mtu \"$ifn\")\"\n  spd=\"$(iface_speed_or_ssid \"$ifn\")\"\n  dns=\"$(iface_dns \"$ifn\")\"\n  gw=\"$(iface_gateway \"$ifn\")\"\n  v4=\"$(iface_ipv4_list \"$ifn\" | xargs)\"\n  v6=\"$(iface_ipv6_list \"$ifn\" | xargs)\"\n\n  printf \"${C_BOLD}%s${C_RESET}  state=%s  mtu=%s  mac=%s\\n\" \"$ifn\" \"$state\" \"$mtu\" \"$mac\"\n  [[ -n \"$v4\" ]] && printf \"  IPv4: %s\\n\" \"$v4\" || printf \"  IPv4: -\\n\"\n  [[ -n \"$v6\" ]] && printf \"  IPv6: %s\\n\" \"$v6\" || printf \"  IPv6: -\\n\"\n  printf \"  GW  : %s\\n\" \"${gw:--}\"\n  printf \"  DNS : %s\\n\" \"${dns:--}\"\n  printf \"  Link: %s\\n\" \"$spd\"\n}\n\nprint_iface_block_json() {\n  local ifn=\"$1\"\n  local state mac mtu spd dns gw v4 v6\n  state=\"$(iface_operstate \"$ifn\")\"\n  mac=\"$(iface_mac \"$ifn\")\"\n  mtu=\"$(iface_mtu \"$ifn\")\"\n  spd=\"$(iface_speed_or_ssid \"$ifn\")\"\n  dns=\"$(iface_dns \"$ifn\")\"\n  gw=\"$(iface_gateway \"$ifn\")\"\n  v4=\"$(iface_ipv4_list \"$ifn\" | tr '\\n' ' ' | xargs)\"\n  v6=\"$(iface_ipv6_list \"$ifn\" | tr '\\n' ' ' | xargs)\"\n  printf '{\"iface\":\"%s\",\"state\":\"%s\",\"mtu\":\"%s\",\"mac\":\"%s\",\"ipv4\":\"%s\",\"ipv6\":\"%s\",\"gw\":\"%s\",\"dns\":\"%s\",\"link\":\"%s\"}' \\\n    \"$(echo \"$ifn\" | json_escape)\" \"$(echo \"$state\" | json_escape)\" \"$(echo \"$mtu\" | json_escape)\" \\\n    \"$(echo \"$mac\" | json_escape)\" \"$(echo \"$v4\" | json_escape)\" \"$(echo \"$v6\" | json_escape)\" \\\n    \"$(echo \"${gw:-}\" | json_escape)\" \"$(echo \"${dns:-}\" | json_escape)\" \"$(echo \"$spd\" | json_escape)\"\n}\n\nprint_help() {\n  cat <<'EOF'\nUsage:\n  info-jaringan.sh [-i IFACE] [-a] [-j]\n\nOptions:\n  -i IFACE  Show details for specific interface\n  -a        Show all interfaces\n  -j        JSON output\n  -h        Help\nEOF\n}\n\nmain() {\n  local sel_iface=\"\" show_all=false json=false\n  while getopts \":i:ajh\" opt; do\n    case \"$opt\" in\n      i) sel_iface=\"$OPTARG\" ;;\n      a) show_all=true ;;\n      j) json=true ;;\n      h) print_help; exit 0 ;;\n      \\?) print_help; exit 2 ;;\n    esac\n  done\n\n  local def ifaces\n  def=\"$(default_iface || true)\"\n  mapfile -t ifaces < <(all_ifaces)\n\n  if [[ -z \"$sel_iface\" && \"$show_all\" != true ]]; then\n    sel_iface=\"$def\"\n  fi\n\n  local pub4 pub6\n  pub4=\"$(public_ip_v4 || true)\"\n  pub6=\"$(public_ip_v6 || true)\"\n\n  if [[ \"$json\" == true ]]; then\n    # JSON output\n    printf '{'\n    printf '\"public_ipv4\":\"%s\",\"public_ipv6\":\"%s\"' \"$(echo \"$pub4\" | json_escape)\" \"$(echo \"$pub6\" | json_escape)\"\n    printf ',\"interfaces\":['\n    local first=true\n    if [[ \"$show_all\" == true ]]; then\n      for ifn in \"${ifaces[@]}\"; do\n        [[ \"$first\" == true ]] || printf ','; first=false\n        print_iface_block_json \"$ifn\"\n      done\n    else\n      if [[ -n \"$sel_iface\" ]]; then print_iface_block_json \"$sel_iface\"; fi\n    fi\n    printf ']}'\n    echo\n    exit 0\n  fi\n\n  # Pretty output\n  printf \"${C_BOLD}${C_BLUE}===== Info Jaringan =====${C_RESET}\\n\"\n  if [[ -n \"$pub4\" || -n \"$pub6\" ]]; then\n    printf \"Publik IPv4: %s\\n\" \"${pub4:--}\"\n    printf \"Publik IPv6: %s\\n\" \"${pub6:--}\"\n  fi\n\n  if [[ \"$show_all\" == true ]]; then\n    for ifn in \"${ifaces[@]}\"; do\n      echo\n      print_iface_block \"$ifn\"\n    done\n  else\n    if [[ -n \"$sel_iface\" ]]; then\n      print_iface_block \"$sel_iface\"\n    else\n      printf \"Tidak ada interface terdeteksi.\\n\"\n    fi\n  fi\n\n  # Uji konektivitas dasar\n  local test_gw test_ip test_dns domain\n  domain=\"example.com\"\n  if [[ -n \"$sel_iface\" ]]; then\n    gw=\"$(iface_gateway \"$sel_iface\")\"\n  fi\n  test_gw=$(test_ping \"${gw:-127.0.0.1}\" || true)\n  test_ip=$(test_ping \"1.1.1.1\" || true)\n  if command -v getent >/dev/null 2>&1; then\n    # Hanya tes DNS resolve\n    if getent hosts \"$domain\" >/dev/null 2>&1; then test_dns=ok; else test_dns=fail; fi\n  else\n    test_dns=\"-\"\n  fi\n  echo\n  printf \"${C_BOLD}Connectivity:${C_RESET} GW=%s ICMP=%s DNS=%s\\n\" \"${test_gw}\" \"${test_ip}\" \"${test_dns}\"\n}\n\nmain \"$@\""
  },
  {
    "path": "vm-test/docs/ssh-config.md",
    "content": "# SSH Hardening + OTP (TOTP)\n\nSkrip: `/home/hades/vm-test/ssh-config.sh`\n\n## Fitur\n- Backup otomatis `sshd_config`\n- Hardening: `PermitRootLogin no`, `MaxAuthTries 4`, `X11Forwarding no`, `PubkeyAuthentication yes`\n- Nonaktifkan password login (aman; optional paksa)\n- Ganti port SSH (opsional) + update UFW (opsional)\n- Tampilkan kunci publik yang sudah ada per user\n- Tambah kunci publik untuk user tertentu (set ownership & permissions benar)\n- OTP (TOTP) via `libpam-google-authenticator`:\n  - `--otp optional`: OTP tidak wajib (nullok), kompatibel dengan login kunci saja\n  - `--otp required`: OTP wajib bersama kunci (AuthenticationMethods publickey,keyboard-interactive:pam)\n\n## Cara pakai\n- Mode interaktif (wizard):\n  ```bash\n  sudo bash /home/hades/vm-test/ssh-config.sh --interactive\n  ```\n- Tampilkan kunci yang sudah ada:\n  ```bash\n  sudo bash /home/hades/vm-test/ssh-config.sh --list-keys\n  ```\n- Tambah kunci + port + UFW + OTP optional:\n  ```bash\n  sudo bash /home/hades/vm-test/ssh-config.sh \\\n    --user hades \\\n    --pubkey \"ssh-ed25519 AAAA...\" \\\n    --port 2222 \\\n    --allow-ufw \\\n    --otp optional\n  ```\n- Nonaktif password secara paksa (hanya jika yakin kunci berfungsi):\n  ```bash\n  sudo bash /home/hades/vm-test/ssh-config.sh --force\n  ```\n\n## Catatan OTP\n- Untuk `--otp required`, login membutuhkan kunci + kode TOTP.\n- Untuk `--otp optional`, Anda bisa login dengan kunci saja ATAU kunci + TOTP; password tetap dimatikan.\n- Wizard dapat mengenerate secret untuk user (file `~/.google_authenticator`). Scan di aplikasi Authenticator.\n\n## Rollback\n- File backup: `/etc/ssh/sshd_config.YYYY-MM-DD-HHMMSS.bak`\n- Kembalikan:\n  ```bash\n  sudo cp -a /etc/ssh/sshd_config.YYYY-MM-DD-HHMMSS.bak /etc/ssh/sshd_config\n  sudo systemctl restart ssh || sudo systemctl restart sshd\n  ```\n  Jika butuh, nonaktifkan drop-in policy dan restart:\n  ```bash\n  sudo mv /etc/ssh/sshd_config.d/00-vibeops-auth.conf /etc/ssh/sshd_config.d/00-vibeops-auth.conf.disabled\n  sudo systemctl restart ssh || sudo systemctl restart sshd\n  ```\n\n\n"
  },
  {
    "path": "vm-test/docs/mfa.md",
    "content": "# SSH MFA (TOTP)\n\n## Ringkas\n- Generate OTP + QR untuk user Anda, lalu aktifkan MFA (pubkey + OTP):\n  ```bash\n  sudo bash /home/hades/vm-test/aktif-otp.sh --mode required --user hades --show-qr hades\n  ```\n- Login (akan diminta kode OTP):\n  ```bash\n  ssh -o PreferredAuthentications=publickey,keyboard-interactive hades@HOST\n  ```\n\n## Penjelasan\n- OTP berbasis TOTP (Google Authenticator kompatibel, bisa pakai aplikasi bebas/open-source).\n- Sistem meminta faktor kedua via PAM (keyboard-interactive) setelah kunci SSH diverifikasi.\n- Recovery codes tersimpan di `~/.google_authenticator` saat pertama kali generate.\n\n## Opsi lain\n- Password + OTP (tidak disarankan, tapi didukung):\n  - Terapkan profil MFA (menu): `bash /home/hades/vm-test/aktif-otp.sh --interactive` → 7)\n  - Login: `ssh -o PreferredAuthentications=password,keyboard-interactive user@HOST`\n\n## Perintah berguna\n- Status OTP & SSH:\n  ```bash\n  sudo bash /home/hades/vm-test/aktif-otp.sh --status\n  ```\n- Tampilkan ulang QR & kode OTP saat ini:\n  ```bash\n  sudo bash /home/hades/vm-test/aktif-otp.sh --show-qr hades\n  ```\n- Nonaktifkan MFA:\n  ```bash\n  bash /home/hades/vm-test/aktif-otp.sh --interactive  # pilih 8)\n  ```\n\n## Catatan\n- Uji login di terminal baru sebelum menutup sesi aktif untuk mencegah lockout.\n- Jika SSH agent/desktop men-cache passphrase, Anda mungkin hanya diminta OTP saja.\n\n\n"
  },
  {
    "path": "vm-test/docs/vps-security.md",
    "content": "# VPS Security Menu (Ubuntu/Debian)\n\nSkrip antarmuka interaktif untuk audit dan hardening VPS Anda. Menggabungkan audit, baseline hardening, konfigurasi SSH/OTP, firewall (UFW), dan Fail2ban dalam satu menu yang mudah dipakai.\n\n## Lokasi skrip\n- Menu utama: `/home/hades/vm-test/vps-securty.sh`\n- Komponen:\n  - Audit keamanan: `/home/hades/vm-test/vps-sec-check.sh`\n  - Cek VPS (CPU/Disk/Net): `/home/hades/vm-test/vps-check.sh`\n  - Hardening baseline: `/home/hades/vm-test/harden-server.sh`\n  - Wizard SSH/OTP: `/home/hades/vm-test/ssh-config.sh`\n\n## Fitur\n- Audit keamanan read-only (tidak mengubah sistem)\n- Cek kapabilitas (CPU, Disk I/O, Network, Ports)\n- Hardening baseline (unattended-upgrades, UFW, SSH hardening, Fail2ban, sysctl)\n- Wizard SSH: tambah kunci publik, port, OTP (TOTP) optional/required\n- Toggle password login (on/off) secara aman (via drop-in `sshd_config.d`)\n- UFW: buka port dan cek status\n- Fail2ban: cek status global dan jail `sshd`\n- Ringkasan konfigurasi SSH efektif (sshd -T)\n\n## Prasyarat\n- Akses `sudo`/root\n- Disarankan: sudah menambahkan minimal satu kunci SSH ke user Anda (`~/.ssh/authorized_keys`)\n\n## Cara menjalankan\n```bash\nchmod +x /home/hades/vm-test/vps-securty.sh\nbash /home/hades/vm-test/vps-securty.sh\n```\nIkuti menu pada layar. Semua aksi yang dimodifikasi akan meminta konfirmasi.\n\n## Menu dan aksi\n- Audit keamanan (read-only): menjalankan `vps-sec-check.sh --all` dan menampilkan temuan (UFW, SSH, sysctl, auth log, dll.)\n- Cek VPS (CPU/Disk/Net): informasi sistem, benchmark singkat, ping, traceroute/speedtest (bila ada), dan konektivitas port umum\n- Baseline hardening (otomatis):\n  - Update & aktifkan `unattended-upgrades` (reboot otomatis 03:30 bila perlu)\n  - UFW: default deny incoming; allow `OpenSSH` + `80,443/tcp`\n  - SSH hardening: `PermitRootLogin no`, `MaxAuthTries 4`, `X11Forwarding no`, matikan password bila kunci terdeteksi\n  - Fail2ban: jail `sshd` aktif + banaction UFW\n  - Sysctl konservatif: matikan `send_redirects`, aktifkan `rp_filter`, tolak IPv6 RA di server\n- Wizard SSH/OTP:\n  - Tampilkan kunci yang ada (authorized_keys*) untuk semua user\n  - Tambahkan kunci dari clipboard/file `.pub`\n  - Ubah port (opsional) dan buka di UFW (opsional)\n  - OTP (TOTP):\n    - optional: login bisa kunci saja ATAU kunci+OTP; password tetap dimatikan\n    - required: wajib kunci+OTP\n  - Manager OTP terpisah dengan QR: `/home/hades/vm-test/aktif-otp.sh` (menu interaktif)\n- Toggle password login:\n  - off (disarankan): password dimatikan via drop-in `sshd_config.d/99-vibeops-auth.conf`\n  - on (darurat): password diizinkan kembali\n- UFW: buka port sesuai kebutuhan (mis. `5432/tcp`, `8080/tcp`)\n- Fail2ban: status global dan jail `sshd`\n- SSH: ringkasan konfigurasi efektif (hasil `sshd -T`)\n\n## Perintah langsung (tanpa menu)\n- Ringkasan SSH:\n  ```bash\n  sudo bash /home/hades/vm-test/ssh-config.sh --summary\n  ```\n- Matikan password + OTP optional:\n  ```bash\n  sudo bash /home/hades/vm-test/ssh-config.sh --otp optional --password off\n  ```\n- Aktifkan password (darurat):\n  ```bash\n  sudo bash /home/hades/vm-test/ssh-config.sh --otp off --password on\n  ```\n- Tambah kunci dari file `.pub`:\n  ```bash\n  sudo bash /home/hades/vm-test/ssh-config.sh --user hades --pubkey-file /home/hades/.ssh/my-server.pub\n  ```\n\n### OTP manager (QR/URI)\n- Menu interaktif OTP/QR:\n  ```bash\n  bash /home/hades/vm-test/aktif-otp.sh --interactive\n  ```\n- OTP required:\n  ```bash\n  sudo bash /home/hades/vm-test/aktif-otp.sh --mode required\n  ```\n- OTP optional + generate untuk user hades + tampilkan QR:\n  ```bash\n  sudo bash /home/hades/vm-test/aktif-otp.sh --mode optional --user hades --show-qr hades\n  ```\n- Matikan OTP:\n  ```bash\n  sudo bash /home/hades/vm-test/aktif-otp.sh --mode off\n  ```\n\n### MFA profile (sesuai panduan)\nProfil MFA ini menyiapkan SSH agar meminta faktor tambahan (OTP) selain kunci/pasword sesuai konfigurasi.\n\n- Terapkan profil MFA (komentari `@include common-auth`, aktifkan PAM OTP, set metode auth SSH):\n  ```bash\n  bash /home/hades/vm-test/aktif-otp.sh --interactive   # pilih 7) Terapkan MFA profile\n  ```\n  Atau non-interaktif:\n  ```bash\n  sudo bash /home/hades/vm-test/aktif-otp.sh --mode optional --user hades --show-qr hades\n  # lalu masih di menu, pilih 7) untuk menegakkan profil MFA\n  ```\n\n- Nonaktifkan profil MFA (kembalikan default, hapus pam_google_authenticator dari PAM, longgarkan AuthenticationMethods):\n  ```bash\n  bash /home/hades/vm-test/aktif-otp.sh --interactive   # pilih 8) Nonaktifkan MFA profile\n  ```\n\n- Contoh login:\n  - Kunci + OTP (disarankan):\n    ```bash\n    ssh -o PreferredAuthentications=publickey,keyboard-interactive user@host\n    ```\n  - Password + OTP (opsional, jika PasswordAuthentication diaktifkan):\n    ```bash\n    ssh -o PreferredAuthentications=password,keyboard-interactive user@host\n    ```\n\n## Rollback cepat\n- SSH config backup: `/etc/ssh/sshd_config.YYYY-MM-DD-HHMMSS.bak`\n- Drop-in kebijakan auth: `/etc/ssh/sshd_config.d/99-vibeops-auth.conf`\n- Kembalikan atau nonaktifkan drop-in, lalu restart SSH:\n  ```bash\n  sudo mv /etc/ssh/sshd_config.d/99-vibeops-auth.conf /etc/ssh/sshd_config.d/99-vibeops-auth.conf.disabled\n  sudo systemctl restart ssh || sudo systemctl restart sshd\n  ```\n\n## Troubleshooting\n- Tidak bisa login setelah perubahan SSH: jangan tutup sesi aktif sebelum uji login baru berhasil.\n- `PasswordAuthentication` masih terbaca `yes`:\n  - Jalankan: `sudo sshd -T | egrep '^(passwordauthentication|authenticationmethods|kbdinteractiveauthentication)'`\n  - Pastikan drop-in `99-vibeops-auth.conf` ada dan memuat `PasswordAuthentication no`\n- OTP tidak diminta pada mode required:\n  - Pastikan `AuthenticationMethods publickey,keyboard-interactive:pam` dan `KbdInteractiveAuthentication yes`\n- UFW belum aktif:\n  - Jalankan: `sudo ufw enable`; status: `sudo ufw status verbose`\n\n## Catatan keamanan\n- Password login meningkatkan risiko; gunakan `--password off` + kunci SSH + OTP optional/required.\n- Aktifkan rate-limit UFW untuk `OpenSSH` (menu wizard akan menawarkan ini) untuk mengurangi brute-force.\n\n\n"
  },
  {
    "path": "jaringan/set-static-ip.sh",
    "content": "#!/usr/bin/env bash\nset -euo pipefail\n\n# Set static IPv4 for common Linux network stacks, with discovery helpers:\n# - netplan (Ubuntu 18.04+)\n# - NetworkManager (nmcli)\n# - ifupdown (/etc/network/interfaces)\n# - systemd-networkd\n#\n# Usage:\n#   ./set-static-ip.sh -i eth0 -a 192.168.1.10/24 -g 192.168.1.1 -d \"1.1.1.1,8.8.8.8\" [-m auto|netplan|nmcli|ifupdown|systemd-networkd]\n#   ./set-static-ip.sh -s                  # show current network info (auto-detect iface)\n#   ./set-static-ip.sh -i eth0 -D          # dry-run: show planned changes using current values\n#\n# Notes:\n# - Requires root to apply changes (not needed for -s or -D)\n# - IP must be CIDR (e.g., 192.168.1.10/24)\n# - Will back up modified files\n\nprint_help() {\n  cat <<'EOF'\nUsage:\n  set-static-ip.sh -i IFACE -a IP/CIDR -g GATEWAY -d \"DNS1,DNS2\" [-m METHOD]\n\nOptions:\n  -i   Interface name (e.g., eth0, enp0s3)\n  -a   IPv4 with CIDR (e.g., 192.168.1.10/24)\n  -g   Gateway IPv4 (e.g., 192.168.1.1)\n  -d   DNS servers comma or space separated (e.g., \"1.1.1.1,8.8.8.8\")\n  -m   Method: auto (default), netplan, nmcli, ifupdown, systemd-networkd\n  -s   Show current network info and exit\n  -D   Dry-run: compute and print planned config, do not apply\n  -h   Help\n\nExamples:\n  set-static-ip.sh -i eth0 -a 192.168.10.20/24 -g 192.168.10.1 -d \"1.1.1.1,8.8.8.8\"\n  set-static-ip.sh -i enp0s3 -a 10.0.0.10/24 -g 10.0.0.1 -d \"9.9.9.9\" -m netplan\n  set-static-ip.sh -s\n  set-static-ip.sh -i eth0 -D\n\nInteractive:\n  If mandatory flags are omitted and you're in a TTY, a guided wizard will start\n  to choose interface, fill IP/CIDR, gateway, DNS, and method; then confirm.\nEOF\n}\n\nrequire_root() {\n  if [[ ${EUID} -ne 0 ]]; then\n    echo \"Error: must run as root\" >&2\n    exit 1\n  fi\n}\n\nensure_root_or_reexec() {\n  if [[ ${EUID} -ne 0 ]]; then\n    if ! command -v sudo >/dev/null 2>&1; then\n      echo \"Error: must run as root (sudo not available)\" >&2\n      exit 1\n    fi\n    echo \"Elevating privileges with sudo...\"\n    argv=(\"-i\" \"$iface\" \"-a\" \"$ip_cidr\" \"-g\" \"$gateway\")\n    if [[ -n \"${dns_list:-}\" ]]; then\n      argv+=(\"-d\" \"$(echo \"$dns_list\" | tr ' ' ',')\")\n    fi\n    if [[ -n \"${method:-}\" ]]; then\n      argv+=(\"-m\" \"$method\")\n    fi\n    exec sudo -E bash \"$0\" \"${argv[@]}\"\n  fi\n}\n\ntimestamp() { date +\"%Y%m%d-%H%M%S\"; }\nbackup_file() {\n  local f=\"$1\"\n  if [[ -f \"$f\" ]]; then\n    cp -a -- \"$f\" \"${f}.bak.$(timestamp)\"\n  fi\n}\n\n# Normalize DNS list to space separated\nnormalize_dns() {\n  local raw=\"$1\"\n  if [[ -z \"$raw\" ]]; then echo \"\"; return; fi\n  echo \"$raw\" | tr ',' ' ' | xargs\n}\n\ncidr_to_netmask() {\n  local cidr=\"$1\"\n  local bits=$(( 0xffffffff ^ ((1 << (32 - cidr)) - 1) ))\n  printf \"%d.%d.%d.%d\" $(( (bits>>24)&255 )) $(( (bits>>16)&255 )) $(( (bits>>8)&255 )) $(( bits&255 ))\n}\n\n# ---- Detection helpers ----\nget_default_iface() {\n  ip route show default 0.0.0.0/0 2>/dev/null | awk '/default/ {for(i=1;i<=NF;i++) if ($i==\"dev\") {print $(i+1); exit}}'\n}\n\nget_iface_ipv4_cidr() {\n  local dev=\"$1\"\n  ip -4 -o addr show dev \"$dev\" 2>/dev/null | awk '{print $4}' | head -n1\n}\n\nget_primary_src_ip() {\n  ip -4 route get 1.1.1.1 2>/dev/null | awk '{for(i=1;i<=NF;i++) if($i==\"src\"){print $(i+1); exit}}'\n}\n\nsuggest_ipv4_cidr_for_iface() {\n  local dev=\"$1\"\n  local cidr\n  cidr=\"$(get_iface_ipv4_cidr \"$dev\" || true)\"\n  if [[ -n \"$cidr\" ]]; then echo \"$cidr\"; return; fi\n  local src\n  src=\"$(get_primary_src_ip || true)\"\n  if [[ -n \"$src\" ]]; then\n    # Fallback guess: /24\n    echo \"${src}/24\"; return\n  fi\n  echo \"\"\n}\n\nget_iface_gateway() {\n  local dev=\"$1\"\n  local gw\n  gw=\"$(ip route show default dev \"$dev\" 2>/dev/null | awk '/default/ {print $3; exit}')\"\n  if [[ -z \"$gw\" ]]; then\n    gw=\"$(ip route show default 2>/dev/null | awk '/default/ {print $3; exit}')\"\n  fi\n  echo \"$gw\"\n}\n\nget_dns_from_resolvectl() {\n  local dev=\"$1\"\n  if command -v resolvectl >/dev/null 2>&1; then\n    local out\n    out=\"$(resolvectl dns \"$dev\" 2>/dev/null || true)\"\n    if [[ -n \"$out\" ]]; then\n      echo \"$out\" | awk -F': ' 'NF>1 {print $2}'\n      return\n    fi\n    resolvectl status 2>/dev/null | awk '/DNS Servers:/ {for(i=3;i<=NF;i++) printf(\"%s \", $i); print \"\"; exit}'\n  fi\n}\n\nget_dns_from_resolv_conf() {\n  if [[ -r /etc/resolv.conf ]]; then\n    awk '/^nameserver / {print $2}' /etc/resolv.conf | xargs\n  fi\n}\n\nget_current_dns() {\n  local dev=\"$1\"\n  local dns\n  dns=\"$(get_dns_from_resolvectl \"$dev\" | xargs || true)\"\n  if [[ -z \"$dns\" ]]; then\n    dns=\"$(get_dns_from_resolv_conf | xargs || true)\"\n  fi\n  echo \"$dns\"\n}\n\n# ---- Method detection and apply helpers ----\ndetect_method() {\n  if [[ \"$method\" != \"auto\" ]]; then\n    echo \"$method\"\n    return\n  fi\n  if command -v netplan >/dev/null 2>&1 && [[ -d /etc/netplan ]]; then\n    echo \"netplan\"; return\n  fi\n  if command -v nmcli >/dev/null 2>&1 && systemctl is-active --quiet NetworkManager.service; then\n    echo \"nmcli\"; return\n  fi\n  if [[ -f /etc/network/interfaces ]]; then\n    echo \"ifupdown\"; return\n  fi\n  if systemctl list-unit-files 2>/dev/null | grep -q '^systemd-networkd\\.service'; then\n    echo \"systemd-networkd\"; return\n  fi\n  if command -v nmcli >/dev/null 2>&1; then echo \"nmcli\"; return; fi\n  if command -v netplan >/dev/null 2>&1; then echo \"netplan\"; return; fi\n  echo \"systemd-networkd\"\n}\n\n# ---- Interactive helpers ----\nis_tty() { [[ -t 0 && -t 1 ]]; }\n\nprompt_default() {\n  local prompt=\"$1\"; shift\n  local default_val=\"${1:-}\"; shift || true\n  local var\n  if [[ -n \"$default_val\" ]]; then\n    read -rp \"$prompt [$default_val]: \" var\n    echo \"${var:-$default_val}\"\n  else\n    read -rp \"$prompt: \" var\n    echo \"$var\"\n  fi\n}\n\nchoose_interface_interactive() {\n  local candidates=()\n  local states=()\n  while IFS= read -r line; do\n    # Format: <ifname> <state> <rest>\n    local ifn state\n    ifn=\"$(awk '{print $1}' <<<\"$line\")\"\n    state=\"$(awk '{print $2}' <<<\"$line\")\"\n    if [[ \"$ifn\" == \"lo\" ]]; then continue; fi\n    candidates+=(\"$ifn\"); states+=(\"$state\")\n  done < <(ip -brief link show 2>/dev/null)\n\n  local def\n  def=\"$(get_default_iface || true)\"\n  echo \"Available interfaces:\"\n  local i\n  for i in \"${!candidates[@]}\"; do\n    printf \"  %2d) %-15s (%s)\\n\" \"$((i+1))\" \"${candidates[$i]}\" \"${states[$i]}\"\n  done\n  if [[ -n \"$def\" ]]; then echo \"Default route via: $def\"; fi\n\n  local choice\n  while true; do\n    choice=$(prompt_default \"Select interface by number or name\" \"$def\")\n    if [[ -z \"$choice\" ]]; then continue; fi\n    if [[ \"$choice\" =~ ^[0-9]+$ ]]; then\n      local idx=$((choice-1))\n      if (( idx>=0 && idx<${#candidates[@]} )); then\n        echo \"${candidates[$idx]}\"; return 0\n      fi\n    else\n      if ip link show \"$choice\" >/dev/null 2>&1; then echo \"$choice\"; return 0; fi\n    fi\n    echo \"Invalid selection.\"\n  done\n}\n\nrun_wizard() {\n  echo \"Interactive static IP setup\"\n  # Interface\n  local sel_if\n  if [[ -n \"${iface:-}\" ]]; then\n    sel_if=\"$iface\"\n  else\n    sel_if=\"$(choose_interface_interactive)\"\n  fi\n\n  # Current values\n  local cur_ip cur_gw cur_dns\n  cur_ip=\"$(suggest_ipv4_cidr_for_iface \"$sel_if\" || true)\"\n  cur_gw=\"$(get_iface_gateway \"$sel_if\" || true)\"\n  cur_dns=\"$(get_current_dns \"$sel_if\" || true)\"\n\n  echo\n  echo \"Detected (may be empty):\"\n  echo \"  Interface : $sel_if\"\n  echo \"  IPv4/CIDR : ${cur_ip:-<none>}\"\n  echo \"  Gateway   : ${cur_gw:-<none>}\"\n  echo \"  DNS       : ${cur_dns:-<none>}\"\n\n  # Ask IP/CIDR, Gateway, DNS\n  local input_ip input_gw input_dns\n  input_ip=\"$(prompt_default \"IPv4 with CIDR (e.g., 192.168.1.10/24)\" \"$cur_ip\")\"\n  input_gw=\"$(prompt_default \"Gateway IPv4\" \"$cur_gw\")\"\n  input_dns=\"$(prompt_default \"DNS servers (comma or space)\" \"$cur_dns\")\"\n\n  # Normalize DNS\n  local normalized_dns\n  normalized_dns=\"$(echo \"$input_dns\" | tr ',' ' ' | xargs)\"\n\n  # Method\n  local suggested_method\n  method=\"${method:-auto}\"\n  suggested_method=\"$(detect_method)\"\n  local input_method\n  input_method=\"$(prompt_default \"Method [auto/netplan/nmcli/ifupdown/systemd-networkd]\" \"$suggested_method\")\"\n  case \"$input_method\" in\n    auto|netplan|nmcli|ifupdown|systemd-networkd) ;;\n    *) echo \"Unknown method, using '$suggested_method'.\"; input_method=\"$suggested_method\" ;;\n  esac\n\n  # Summary\n  echo\n  echo \"Summary:\"\n  echo \"  Interface : $sel_if\"\n  echo \"  IPv4/CIDR : $input_ip\"\n  echo \"  Gateway   : $input_gw\"\n  echo \"  DNS       : ${normalized_dns:-<none>}\"\n  echo \"  Method    : $input_method\"\n  echo\n  local proceed\n  read -rp $'Proceed? [Y/n]: ' proceed; proceed=${proceed:-y}\n  if [[ ! \"$proceed\" =~ ^[Yy]$ ]]; then\n    echo \"Aborted by user.\"; exit 0\n  fi\n\n  iface=\"$sel_if\"\n  ip_cidr=\"$input_ip\"\n  gateway=\"$input_gw\"\n  dns_list=\"$normalized_dns\"\n  method=\"$input_method\"\n}\n\napply_netplan() {\n  local file=\"/etc/netplan/99-static-${iface}.yaml\"\n  mkdir -p /etc/netplan\n  backup_file \"$file\"\n  cat > \"$file\" <<EOF\nnetwork:\n  version: 2\n  renderer: networkd\n  ethernets:\n    ${iface}:\n      dhcp4: false\n      addresses:\n        - ${ip_cidr}\n      routes:\n        - to: 0.0.0.0/0\n          via: ${gateway}\n$( if [[ -n \"$dns_list\" ]]; then\n     echo \"      nameservers:\"\n     echo \"        addresses:\"\n     for d in $dns_list; do\n       echo \"          - ${d}\"\n     done\n   fi )\nEOF\n  netplan generate\n  netplan apply\n}\n\napply_nmcli() {\n  local conn_name=\"\"\n  while IFS= read -r name; do\n    local ifn\n    ifn=\"$(nmcli -g connection.interface-name connection show \"$name\" 2>/dev/null || true)\"\n    if [[ \"$ifn\" == \"$iface\" ]]; then conn_name=\"$name\"; break; fi\n  done < <(nmcli -g NAME connection show)\n\n  if [[ -z \"$conn_name\" ]]; then\n    conn_name=\"static-${iface}\"\n    nmcli connection add type ethernet ifname \"$iface\" con-name \"$conn_name\" ipv4.method manual\n  fi\n\n  nmcli connection modify \"$conn_name\" \\\n    ipv4.method manual \\\n    ipv4.addresses \"${ip_cidr}\" \\\n    ipv4.gateway \"${gateway}\" \\\n    ipv6.method ignore \\\n    autoconnect yes\n\n  if [[ -n \"$dns_list\" ]]; then\n    nmcli connection modify \"$conn_name\" ipv4.dns \"$(echo \"$dns_list\" | tr ' ' ',')\" ipv4.ignore-auto-dns yes\n  else\n    nmcli connection modify \"$conn_name\" -ipv4.dns ipv4.ignore-auto-dns yes\n  fi\n\n  nmcli connection down \"$conn_name\" || true\n  nmcli connection up \"$conn_name\"\n}\n\napply_ifupdown() {\n  local file=\"/etc/network/interfaces\"\n  backup_file \"$file\"\n\n  if grep -qE \"^[[:space:]]*iface[[:space:]]+${iface}[[:space:]]+inet[[:space:]]+\" \"$file\"; then\n    sed -i.bak.$(timestamp) -E \"s/^([[:space:]]*iface[[:space:]]+${iface}[[:space:]]+inet[[:space:]]+.*)$/# \\1/\" \"$file\" || true\n    sed -i -E \"s/^([[:space:]]*(address|netmask|gateway|dns-nameservers).*)$/# \\1/\" \"$file\" || true\n  fi\n\n  {\n    echo \"\"\n    echo \"# static config added $(timestamp)\"\n    echo \"auto ${iface}\"\n    echo \"iface ${iface} inet static\"\n    echo \"    address ${ip_addr}\"\n    echo \"    netmask ${netmask}\"\n    echo \"    gateway ${gateway}\"\n    if [[ -n \"$dns_list\" ]]; then\n      echo \"    dns-nameservers ${dns_list}\"\n    fi\n  } >> \"$file\"\n\n  ifdown \"$iface\" 2>/dev/null || true\n  ifup \"$iface\"\n}\n\napply_systemd_networkd() {\n  mkdir -p /etc/systemd/network\n  local file=\"/etc/systemd/network/${iface}-static.network\"\n  backup_file \"$file\"\n  {\n    echo \"[Match]\"\n    echo \"Name=${iface}\"\n    echo \"\"\n    echo \"[Network]\"\n    echo \"Address=${ip_cidr}\"\n    echo \"Gateway=${gateway}\"\n    if [[ -n \"$dns_list\" ]]; then\n      for d in $dns_list; do echo \"DNS=${d}\"; done\n    fi\n  } > \"$file\"\n  systemctl enable systemd-networkd.service >/dev/null 2>&1 || true\n  systemctl restart systemd-networkd.service\n}\n\n# ---- Args ----\niface=\"\"\nip_cidr=\"\"\ngateway=\"\"\ndns_raw=\"\"\nmethod=\"auto\"\nshow_only=false\ndry_run=false\n\nwhile getopts \":i:a:g:d:m:sDh\" opt; do\n  case \"$opt\" in\n    i) iface=\"$OPTARG\" ;;\n    a) ip_cidr=\"$OPTARG\" ;;\n    g) gateway=\"$OPTARG\" ;;\n    d) dns_raw=\"$OPTARG\" ;;\n    m) method=\"$OPTARG\" ;;\n    s) show_only=true ;;\n    D) dry_run=true ;;\n    h) print_help; exit 0 ;;\n    \\?) echo \"Invalid option -$OPTARG\" >&2; print_help; exit 2 ;;\n    :) echo \"Option -$OPTARG requires an argument.\" >&2; print_help; exit 2 ;;\n  esac\ndone\n\n# If required values are missing and in TTY, start wizard\nif [[ ( -z \"${ip_cidr:-}\" || -z \"${gateway:-}\" ) && \"${show_only}\" != true && \"${dry_run}\" != true ]]; then\n  if is_tty; then\n    run_wizard\n  fi\nfi\n\n# Auto-select interface if still not provided\nif [[ -z \"$iface\" ]]; then\n  iface=\"$(get_default_iface || true)\"\nfi\n\nif [[ -z \"$iface\" ]]; then\n  echo \"Error: interface not specified and could not auto-detect default interface.\" >&2\n  echo \"Hint: pass -i IFACE. Available interfaces:\" >&2\n  ip -brief link show || true\n  exit 2\nfi\n\nif ! ip link show \"$iface\" >/dev/null 2>&1; then\n  echo \"Error: interface '$iface' not found.\" >&2\n  ip -brief link show || true\n  exit 1\nfi\n\n# Derive current values from system when missing\ncurrent_ip_cidr=\"$(get_iface_ipv4_cidr \"$iface\" || true)\"\ncurrent_gateway=\"$(get_iface_gateway \"$iface\" || true)\"\ncurrent_dns=\"$(get_current_dns \"$iface\" || true)\"\n\nif [[ -z \"$ip_cidr\" && -n \"$current_ip_cidr\" ]]; then ip_cidr=\"$current_ip_cidr\"; fi\nif [[ -z \"$gateway\" && -n \"$current_gateway\" ]]; then gateway=\"$current_gateway\"; fi\n\ndns_list=\"$(normalize_dns \"${dns_raw:-}\")\"\nif [[ -z \"$dns_list\" && -n \"$current_dns\" ]]; then dns_list=\"$current_dns\"; fi\n\n# Show-only mode\nif [[ \"$show_only\" == true ]]; then\n  chosen_show=\"$(detect_method)\"\n  mac_addr=\"\"\n  if [[ -r \"/sys/class/net/${iface}/address\" ]]; then\n    mac_addr=\"$(cat \"/sys/class/net/${iface}/address\" 2>/dev/null || true)\"\n  fi\n  echo \"Interface : $iface\"\n  echo \"State     : $(cat /sys/class/net/${iface}/operstate 2>/dev/null || echo unknown)\"\n  echo \"IPv4/CIDR : ${ip_cidr:-none}\"\n  echo \"Gateway   : ${gateway:-none}\"\n  echo \"DNS       : ${dns_list:-none}\"\n  echo \"MAC       : ${mac_addr:-unknown}\"\n  echo \"Method    : ${chosen_show}\"\n  exit 0\nfi\n\n# Ensure we have required values after inference\nif [[ -z \"$ip_cidr\" || -z \"$gateway\" ]]; then\n  echo \"Error: missing -a or -g and could not infer from current network.\" >&2\n  echo \"Got: iface=$iface, ip_cidr='${ip_cidr:-}', gateway='${gateway:-}'\" >&2\n  exit 2\nfi\n\n# Validate formats\nif [[ ! \"$ip_cidr\" =~ ^([0-9]{1,3}\\.){3}[0-9]{1,3}/([0-9]|[12][0-9]|3[0-2])$ ]]; then\n  echo \"Error: -a must be IPv4/CIDR, e.g., 192.168.1.10/24\" >&2\n  exit 2\nfi\nif [[ ! \"$gateway\" =~ ^([0-9]{1,3}\\.){3}[0-9]{1,3}$ ]]; then\n  echo \"Error: -g must be IPv4, e.g., 192.168.1.1\" >&2\n  exit 2\nfi\n\nip_addr=\"${ip_cidr%/*}\"\nprefix=\"${ip_cidr#*/}\"\nnetmask=\"$(cidr_to_netmask \"$prefix\")\"\n\nchosen=\"$(detect_method)\"\necho \"Using method: ${chosen}\"\n\n# Dry-run mode\nif [[ \"$dry_run\" == true ]]; then\n  echo \"Planned configuration:\"\n  echo \"  Interface : $iface\"\n  echo \"  IPv4/CIDR : $ip_cidr\"\n  echo \"  Netmask   : $netmask (/${prefix})\"\n  echo \"  Gateway   : $gateway\"\n  echo \"  DNS       : ${dns_list:-none}\"\n  echo \"  Method    : $chosen\"\n  exit 0\nfi\n\n# Apply requires root; auto elevate if needed\nensure_root_or_reexec\n\ncase \"$chosen\" in\n  netplan) apply_netplan ;;\n  nmcli) apply_nmcli ;;\n  ifupdown) apply_ifupdown ;;\n  systemd-networkd) apply_systemd_networkd ;;\n  *) echo \"Unknown method '${chosen}'\"; exit 1 ;;\n\nesac\n\necho \"Static IP configured on ${iface} -> ${ip_cidr}, gateway ${gateway}${dns_list:+, DNS: ${dns_list}}\"\n"
  },
  {
    "path": "jaringan/mac-address.sh",
    "content": "#!/bin/bash\n\necho -e \"\\n\\e[1;36m Info Jaringan: Interface Aktif, MAC & IP Address\\e[0m\"\necho -e \"---------------------------------------------------------\\n\"\n\n# Loop semua interface\nfor iface in $(ls /sys/class/net/); do\n  # Lewati loopback\n  if [[ \"$iface\" == \"lo\" ]]; then\n    continue\n  fi\n\n  # Cek status interface\n  state=$(cat /sys/class/net/$iface/operstate)\n  mac=$(cat /sys/class/net/$iface/address)\n  ip=$(ip -o -4 addr show $iface | awk '{print $4}')\n\n  # Tampilkan hanya interface aktif (state UP atau IP ada)\n  if [[ \"$state\" == \"up\" || -n \"$ip\" ]]; then\n    echo -e \" \\e[1mInterface:\\e[0m $iface\"\n    echo -e \"     \\e[1;33mStatus :\\e[0m ${state^^}\"\n    echo -e \"     \\e[1;32mMAC    :\\e[0m $mac\"\n\n    if [[ -n \"$ip\" ]]; then\n      echo -e \"     \\e[1;34mIP     :\\e[0m $ip\"\n    else\n      echo -e \"     \\e[1;31mIP     :\\e[0m Tidak ada IP (offline)\"\n    fi\n\n    echo \"\"\n  fi\ndone"
  },
  {
    "path": "jaringan/cek-ip.sh",
    "content": "#!/bin/bash\n\nset -euo pipefail\n\n# Warna\nC_RESET='\\033[0m'\nC_BOLD='\\033[1m'\nC_BLUE='\\033[0;34m'\nC_GREEN='\\033[0;32m'\nC_YELLOW='\\033[0;33m'\nC_RED='\\033[0;31m'\n\nprint_header() {\n  printf \"${C_BOLD}${C_BLUE}===== Cek IP Sekarang =====${C_RESET}\\n\"\n}\n\ntrim() { sed -e 's/^\\s\\+//' -e 's/\\s\\+$//'; }\n\nget_public_ip() {\n  # Urutan layanan (IPv4). Gunakan timeout kecil agar cepat fallback\n  local endpoints=(\n    \"https://api.ipify.org\"\n    \"https://ipv4.icanhazip.com\"\n    \"https://ifconfig.me/ip\"\n  )\n\n  if command -v curl >/dev/null 2>&1; then\n    for url in \"${endpoints[@]}\"; do\n      if ip=$(curl -4 -fsS --max-time 4 \"$url\" 2>/dev/null | tr -d '\\r' | trim); then\n        if [[ -n \"$ip\" ]]; then echo \"$ip\"; return 0; fi\n      fi\n    done\n  fi\n\n  # Fallback ke dig (OpenDNS) jika curl gagal/tdk ada\n  if command -v dig >/dev/null 2>&1; then\n    if ip=$(dig +short -4 myip.opendns.com @resolver1.opendns.com 2>/dev/null | head -n1 | trim); then\n      if [[ -n \"$ip\" ]]; then echo \"$ip\"; return 0; fi\n    fi\n  fi\n\n  echo \"\" # kosong jika gagal\n  return 1\n}\n\nget_primary_local_ip() {\n  # Ambil IP sumber default route\n  if command -v ip >/dev/null 2>&1; then\n    local line\n    if line=$(ip -4 route get 1.1.1.1 2>/dev/null | head -n1); then\n      # contoh: \"1.1.1.1 via 192.168.1.1 dev eth0 src 192.168.1.10 uid 1000\"\n      local src ip_iface\n      src=$(awk '{for(i=1;i<=NF;i++){if($i==\"src\"){print $(i+1); exit}}}' <<<\"$line\")\n      ip_iface=$(awk '{for(i=1;i<=NF;i++){if($i==\"dev\"){print $(i+1); exit}}}' <<<\"$line\")\n      if [[ -n \"$src\" ]]; then\n        printf \"%s|%s\\n\" \"$src\" \"${ip_iface:-?}\"\n        return 0\n      fi\n    fi\n  fi\n  echo \"|\" # kosong jika gagal\n  return 1\n}\n\nlist_all_local_ipv4() {\n  if command -v ip >/dev/null 2>&1; then\n    ip -o -4 addr show 2>/dev/null | awk '{print $2, $4}' | sed 's/\\/[0-9]\\+$//' || true\n  else\n    hostname -I 2>/dev/null | tr ' ' '\\n' || true\n  fi\n}\n\nmain() {\n  print_header\n\n  # IP publik\n  local pub_ip\n  if pub_ip=$(get_public_ip); then\n    if [[ -n \"$pub_ip\" ]]; then\n      printf \"${C_BOLD}IP Publik:${C_RESET} ${C_GREEN}%s${C_RESET}\\n\" \"$pub_ip\"\n    else\n      printf \"${C_BOLD}IP Publik:${C_RESET} ${C_YELLOW}Tidak terdeteksi${C_RESET}\\n\"\n    fi\n  else\n    printf \"${C_BOLD}IP Publik:${C_RESET} ${C_YELLOW}Tidak terdeteksi${C_RESET}\\n\"\n  fi\n\n  # IP lokal utama (default route)\n  local primary local_iface pair\n  pair=$(get_primary_local_ip || true)\n  primary=\"${pair%%|*}\"\n  local_iface=\"${pair#*|}\"\n  if [[ -n \"$primary\" ]]; then\n    if [[ -n \"$local_iface\" && \"$local_iface\" != \"$primary\" ]]; then\n      printf \"${C_BOLD}IP Lokal Utama:${C_RESET} ${C_GREEN}%s${C_RESET} (iface: %s)\\n\" \"$primary\" \"$local_iface\"\n    else\n      printf \"${C_BOLD}IP Lokal Utama:${C_RESET} ${C_GREEN}%s${C_RESET}\\n\" \"$primary\"\n    fi\n  else\n    printf \"${C_BOLD}IP Lokal Utama:${C_RESET} ${C_YELLOW}Tidak terdeteksi${C_RESET}\\n\"\n  fi\n\n  # Daftar semua IPv4 lokal\n  printf \"${C_BOLD}Daftar IP Lokal:${C_RESET}\\n\"\n  if list=$(list_all_local_ipv4); then\n    if [[ -n \"$list\" ]]; then\n      while IFS= read -r row; do\n        [[ -z \"$row\" ]] && continue\n        # row bisa berupa: \"eth0 192.168.1.10\" atau hanya IP\n        printf \"  - %s\\n\" \"$row\"\n      done <<<\"$list\"\n    else\n      printf \"  ${C_YELLOW}(kosong)${C_RESET}\\n\"\n    fi\n  else\n    printf \"  ${C_YELLOW}(gagal membaca antarmuka)${C_RESET}\\n\"\n  fi\n}\n\nmain \"$@\"\n\n\n"
  },
  {
    "path": "jaringan/set-hostname.sh",
    "content": "#!/usr/bin/env bash\nset -euo pipefail\n\n# Change system hostname safely across common Linux distros.\n# - Uses hostnamectl when available (systemd)\n# - Fallback: write /etc/hostname and call `hostname`\n# - Updates /etc/hosts in a managed block (with backup)\n#\n# Usage examples:\n#   sudo ./set-hostname.sh -n server1 -d example.local\n#   sudo ./set-hostname.sh -n server1.example.local\n#   sudo ./set-hostname.sh -n server1 -d example.local -p \"Server One\" -I 192.168.1.10\n#\n# If you run without -n in an interactive terminal, a guided wizard will start.\n#\n# Options:\n#   -n  New hostname (short or FQDN)\n#   -d  Domain (optional; used if -n is short)\n#   -p  Pretty hostname (optional)\n#   -I  IP for /etc/hosts mapping (optional; default: 127.0.1.1 on Debian, else 127.0.0.1)\n#   -m  Method: auto (default), hostnamectl, etc (write files)\n#   -h  Help\n\nprint_help() {\n  cat <<'EOF'\nUsage:\n  set-hostname.sh -n HOSTNAME [-d DOMAIN] [-p PRETTY] [-I IP] [-m METHOD]\n\nOptions:\n  -n   New hostname (short or FQDN)\n  -d   Domain name to form FQDN if -n is short\n  -p   Pretty hostname\n  -I   IP address to map in /etc/hosts (FQDN and short)\n  -m   Method: auto (default), hostnamectl, etc\n  -h   Show this help\n\nExamples:\n  set-hostname.sh -n server1 -d example.local\n  set-hostname.sh -n server1.example.local\n  set-hostname.sh -n server1 -d example.local -p \"Server One\" -I 192.168.1.10\n\nInteractive:\n  If -n is omitted and you're in a TTY, an interactive wizard will ask:\n  hostname, domain (optional), pretty name (optional), mapping IP, and method.\nEOF\n}\n\nrequire_root() {\n  if [[ ${EUID} -ne 0 ]]; then\n    echo \"Error: must run as root\" >&2\n    exit 1\n  fi\n}\n\ntimestamp() { date +\"%Y%m%d-%H%M%S\"; }\nbackup_file() {\n  local f=\"$1\"\n  if [[ -f \"$f\" ]]; then\n    cp -a -- \"$f\" \"${f}.bak.$(timestamp)\"\n  fi\n}\n\n# RFC-1123 hostname validation: labels 1-63 chars, [A-Za-z0-9-], not starting/ending with '-'\nvalidate_hostname() {\n  local hn=\"$1\"\n  # Total length <= 253\n  if (( ${#hn} < 1 || ${#hn} > 253 )); then\n    return 1\n  fi\n  IFS='.' read -r -a labels <<< \"$hn\"\n  for lbl in \"${labels[@]}\"; do\n    if (( ${#lbl} < 1 || ${#lbl} > 63 )); then return 1; fi\n    if [[ ! \"$lbl\" =~ ^[A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])?$ ]]; then return 1; fi\n  done\n  return 0\n}\n\nget_os_like() {\n  if [[ -r /etc/os-release ]]; then\n    . /etc/os-release\n    echo \"${ID_LIKE:-${ID:-}}\"\n  fi\n}\n\nchoose_default_hosts_ip() {\n  local like\n  like=\"$(get_os_like || true)\"\n  if [[ \"$like\" == *debian* ]]; then\n    echo \"127.0.1.1\"\n  else\n    echo \"127.0.0.1\"\n  fi\n}\n\nupdate_hosts_block() {\n  local fqdn=\"$1\"; shift\n  local short=\"$1\"; shift\n  local ip_map=\"$1\"; shift\n  local hosts_file=\"/etc/hosts\"\n  local begin=\"# set-hostname.sh managed block start\"\n  local end=\"# set-hostname.sh managed block end\"\n\n  backup_file \"$hosts_file\"\n  # Remove existing managed block\n  if grep -qF \"$begin\" \"$hosts_file\" 2>/dev/null; then\n    awk -v b=\"$begin\" -v e=\"$end\" 'BEGIN{skip=0} {\n      if ($0==b) {skip=1; next}\n      if ($0==e) {skip=0; next}\n      if (!skip) print $0\n    }' \"$hosts_file\" > \"${hosts_file}.tmp\"\n    mv \"${hosts_file}.tmp\" \"$hosts_file\"\n  fi\n\n  {\n    echo \"$begin\"\n    printf \"%s\\t%s %s\\n\" \"$ip_map\" \"$fqdn\" \"$short\"\n    echo \"$end\"\n  } >> \"$hosts_file\"\n}\n\napply_with_hostnamectl() {\n  local fqdn=\"$1\"; shift\n  local pretty=\"${1:-}\"\n  if [[ -n \"$pretty\" ]]; then\n    hostnamectl set-hostname \"$fqdn\" --static\n    hostnamectl set-hostname \"$pretty\" --pretty\n  else\n    hostnamectl set-hostname \"$fqdn\"\n  fi\n}\n\napply_with_etc() {\n  local fqdn=\"$1\"; shift\n  local short=\"$1\"; shift\n  echo \"$short\" > /etc/hostname\n  hostname \"$fqdn\" || true\n}\n\nname=\"\"\ndomain=\"\"\npretty=\"\"\nmap_ip=\"\"\nmethod=\"auto\"\n\n# Helpers for interactive mode\nis_tty() { [[ -t 0 && -t 1 ]]; }\nprompt_default() {\n  local prompt=\"$1\"; shift\n  local default_val=\"$1\"; shift || true\n  local var\n  if [[ -n \"$default_val\" ]]; then\n    read -rp \"$prompt [$default_val]: \" var\n    echo \"${var:-$default_val}\"\n  else\n    read -rp \"$prompt: \" var\n    echo \"$var\"\n  fi\n}\nprompt_yes_no() {\n  local prompt=\"$1\"; shift\n  local def=\"$1\"; shift || true\n  local ans\n  if [[ \"$def\" =~ ^[Yy]$ ]]; then\n    read -rp \"$prompt [Y/n]: \" ans; ans=${ans:-y}\n  else\n    read -rp \"$prompt [y/N]: \" ans; ans=${ans:-n}\n  fi\n  [[ \"$ans\" =~ ^[Yy]$ ]]\n}\n\nrun_wizard() {\n  local cur_hn\n  cur_hn=$(hostname -f 2>/dev/null || hostname 2>/dev/null || echo \"\")\n  echo \"Interactive hostname setup\"\n  echo \"Current hostname: ${cur_hn}\"\n\n  # Ask hostname or FQDN\n  local input_hn\n  input_hn=$(prompt_default \"Enter new hostname (short or FQDN)\" \"${cur_hn}\")\n  while ! validate_hostname \"$input_hn\"; do\n    echo \"Invalid hostname format. Please follow RFC-1123 (letters, digits, hyphens).\"\n    input_hn=$(prompt_default \"Enter new hostname (short or FQDN)\" \"\")\n  done\n\n  # If short without dot, optionally ask domain\n  local input_domain=\"\"\n  if [[ \"$input_hn\" != *.* ]]; then\n    input_domain=$(prompt_default \"Enter domain (optional, to form FQDN)\" \"\")\n    if [[ -n \"$input_domain\" ]]; then\n      local combined=\"${input_hn}.${input_domain}\"\n      if validate_hostname \"$combined\"; then\n        input_hn=\"$combined\"\n      else\n        echo \"Warning: domain ignored because resulting FQDN is invalid.\"\n      fi\n    fi\n  fi\n\n  # Pretty hostname\n  local suggested_pretty\n  suggested_pretty=\"${input_hn%%.*}\"\n  suggested_pretty=\"${suggested_pretty//-/ }\"\n  suggested_pretty=\"${suggested_pretty^}\"\n  local input_pretty\n  input_pretty=$(prompt_default \"Pretty hostname (optional)\" \"$suggested_pretty\")\n  if [[ -z \"$input_pretty\" ]]; then input_pretty=\"\"; fi\n\n  # Mapping IP\n  local suggested_ip\n  suggested_ip=$(choose_default_hosts_ip)\n  local input_ip\n  input_ip=$(prompt_default \"IP to map in /etc/hosts\" \"$suggested_ip\")\n\n  # Method\n  local default_method=\"auto\"\n  if command -v hostnamectl >/dev/null 2>&1; then\n    default_method=\"hostnamectl\"\n  else\n    default_method=\"etc\"\n  fi\n  local input_method\n  input_method=$(prompt_default \"Method [auto/hostnamectl/etc]\" \"$default_method\")\n  case \"$input_method\" in\n    auto|hostnamectl|etc) ;;\n    *) echo \"Unknown method, using 'auto'.\"; input_method=\"auto\" ;;\n  esac\n\n  # Summary\n  echo\n  echo \"Summary:\"\n  echo \"  FQDN        : $input_hn\"\n  echo \"  Pretty      : ${input_pretty:-<none>}\"\n  echo \"  /etc/hosts IP: $input_ip\"\n  echo \"  Method      : $input_method\"\n  echo\n  if prompt_yes_no \"Proceed?\" y; then\n    name=\"$input_hn\"\n    # domain stays blank because name may already be FQDN\n    pretty=\"$input_pretty\"\n    map_ip=\"$input_ip\"\n    method=\"$input_method\"\n  else\n    echo \"Aborted by user.\"; exit 0\n  fi\n}\n\nwhile getopts \":n:d:p:I:m:h\" opt; do\n  case \"$opt\" in\n    n) name=\"$OPTARG\" ;;\n    d) domain=\"$OPTARG\" ;;\n    p) pretty=\"$OPTARG\" ;;\n    I) map_ip=\"$OPTARG\" ;;\n    m) method=\"$OPTARG\" ;;\n    h) print_help; exit 0 ;;\n    \\?) echo \"Invalid option -$OPTARG\" >&2; print_help; exit 2 ;;\n    :) echo \"Option -$OPTARG requires an argument.\" >&2; print_help; exit 2 ;;\n  esac\ndone\n\n# Interactive wizard when no -n provided and running in TTY\nif [[ -z \"$name\" ]]; then\n  if is_tty; then\n    run_wizard\n  else\n    echo \"Error: -n HOSTNAME is required (non-interactive).\" >&2\n    print_help\n    exit 2\n  fi\nfi\n\n# Derive FQDN and short host\nfqdn=\"$name\"\nif [[ -n \"$domain\" && \"$name\" != *.* ]]; then\n  fqdn=\"$name.$domain\"\nfi\n\n# Validate\nif ! validate_hostname \"$fqdn\"; then\n  echo \"Error: invalid hostname '$fqdn' (RFC-1123).\" >&2\n  exit 2\nfi\n\nshort_host=\"${fqdn%%.*}\"\n\n# Choose mapping IP for /etc/hosts\nif [[ -z \"$map_ip\" ]]; then\n  map_ip=\"$(choose_default_hosts_ip)\"\nfi\n\n# Detect method\nchosen_method=\"\"\nif [[ \"$method\" != \"auto\" ]]; then\n  chosen_method=\"$method\"\nelse\n  if command -v hostnamectl >/dev/null 2>&1; then\n    chosen_method=\"hostnamectl\"\n  else\n    chosen_method=\"etc\"\n  fi\nfi\n\nensure_root_or_reexec() {\n  if [[ ${EUID} -ne 0 ]]; then\n    if ! command -v sudo >/dev/null 2>&1; then\n      echo \"Error: must run as root (sudo not available)\" >&2\n      exit 1\n    fi\n    echo \"Elevating privileges with sudo...\"\n    # Re-exec this script with the resolved parameters so we skip the wizard\n    argv=(\"-n\" \"$fqdn\")\n    [[ -n \"$pretty\" ]] && argv+=(\"-p\" \"$pretty\")\n    [[ -n \"$map_ip\" ]] && argv+=(\"-I\" \"$map_ip\")\n    [[ -n \"$method\" ]] && argv+=(\"-m\" \"$method\")\n    exec sudo -E bash \"$0\" \"${argv[@]}\"\n  fi\n}\n\necho \"Using method: ${chosen_method}; hosts mapping IP: ${map_ip}\"\n\nensure_root_or_reexec\n\ncase \"$chosen_method\" in\n  hostnamectl)\n    apply_with_hostnamectl \"$fqdn\" \"$pretty\"\n    ;;\n  etc)\n    apply_with_etc \"$fqdn\" \"$short_host\"\n    ;;\n  *)\n    echo \"Unknown method '$chosen_method'\" >&2\n    exit 1\n    ;;\nesac\n\nupdate_hosts_block \"$fqdn\" \"$short_host\" \"$map_ip\"\n\necho \"Hostname set to: ${fqdn}${pretty:+ (pretty: $pretty)}\"\n"
  },
  {
    "path": "jaringan/static.md",
    "content": "## Utilities: set-static-ip.sh & set-hostname.sh\n\nDokumentasi singkat untuk dua utilitas yang tersedia:\n- `set-static-ip.sh`: Mengatur IP statis lintas distro Linux (Netplan, NetworkManager/nmcli, ifupdown, systemd-networkd) + menampilkan info jaringan saat ini.\n- `set-hostname.sh`: Mengatur hostname (static/pretty) dan memperbarui pemetaan di `/etc/hosts` secara aman.\n\nCatatan umum\n- Jalankan perintah dengan `sudo` saat menerapkan perubahan (apply). Mode `-s` (show) dan `-D` (dry run) tidak membutuhkan root.\n- Menerapkan perubahan jaringan saat terhubung via SSH dapat memutus koneksi. Gunakan `-D` terlebih dahulu untuk memastikan konfigurasi benar sebelum apply.\n\n---\n\n### set-static-ip.sh\n\nFitur\n- Deteksi metode konfigurasi jaringan otomatis: netplan / nmcli / ifupdown / systemd-networkd.\n- Tampilkan informasi jaringan saat ini (`-s`).\n- Isi otomatis nilai yang tidak diberikan dari konfigurasi aktif (IP/CIDR, gateway, DNS, interface default).\n- Dry-run (`-D`) untuk melihat rencana perubahan tanpa menerapkan.\n- Membuat backup file konfigurasi terkait sebelum mengubah.\n\nPenggunaan\n- Tampilkan bantuan:\n  - `./set-static-ip.sh -h`\n- Tampilkan info jaringan saat ini (auto-detect interface default):\n  - `./set-static-ip.sh -s`\n- Dry-run (gunakan nilai dari jaringan aktif untuk `eth0`):\n  - `./set-static-ip.sh -i eth0 -D`\n- Terapkan IP statis (contoh):\n  - `sudo ./set-static-ip.sh -i eth0 -a 192.168.1.10/24 -g 192.168.1.1 -d \"1.1.1.1,8.8.8.8\"`\n\nOpsi\n- `-i IFACE`: Nama interface, mis. `eth0`, `enp0s3`. Jika tidak diisi, script mencoba memilih dari default route.\n- `-a IP/CIDR`: IP dengan CIDR, mis. `192.168.1.10/24`.\n- `-g GATEWAY`: Gateway IPv4, mis. `192.168.1.1`.\n- `-d DNS1,DNS2`: Daftar DNS (pisahkan dengan koma atau spasi). Jika tidak diisi, diambil dari sistem saat ini.\n- `-m METHOD`: `auto` (default) atau salah satu `netplan|nmcli|ifupdown|systemd-networkd`.\n- `-s`: Hanya tampilkan info jaringan dan keluar.\n- `-D`: Dry-run; tampilkan rencana konfigurasi, tidak menerapkan.\n\nContoh tambahan\n- Paksa pakai Netplan:\n  - `sudo ./set-static-ip.sh -i ens160 -a 10.0.0.10/24 -g 10.0.0.1 -d 9.9.9.9 -m netplan`\n- Paksa pakai NetworkManager (nmcli):\n  - `sudo ./set-static-ip.sh -i enp3s0 -a 172.16.1.20/24 -g 172.16.1.1 -d \"1.1.1.1,8.8.8.8\" -m nmcli`\n\nInformasi yang ditampilkan oleh `-s`\n- Interface, state (UP/DOWN), IPv4/CIDR, Gateway, DNS, MAC address, dan metode konfigurasi yang terdeteksi.\n\nCatatan metode\n- Netplan: file dibuat/diubah di `/etc/netplan/99-static-<iface>.yaml`, kemudian `netplan apply`.\n- NetworkManager (nmcli): koneksi profil baru bernama `static-<iface>` (atau gunakan yang sudah terkait interface), lalu koneksi di-restart.\n- ifupdown: menambahkan stanza statis ke `/etc/network/interfaces`, lalu `ifdown`/`ifup` interface.\n- systemd-networkd: membuat file `/etc/systemd/network/<iface>-static.network`, lalu restart service.\n\nTroubleshooting cepat\n- Lihat daftar interface: `ip -brief link show`\n- Lihat route default: `ip route | grep default`\n- Lihat IP dan CIDR interface: `ip -4 -o addr show dev <iface>`\n- Cek DNS yang aktif (systemd-resolved): `resolvectl status`\n- Cek koneksi nmcli: `nmcli connection show`\n\n---\n\n### set-hostname.sh\n\nFitur\n- Mengatur hostname melalui `hostnamectl` (jika tersedia), atau fallback edit `/etc/hostname` + panggil `hostname`.\n- Memperbarui `/etc/hosts` dalam blok yang dikelola (managed block) dengan backup otomatis.\n- Validasi hostname sesuai RFC-1123.\n\nPenggunaan\n- Set FQDN langsung:\n  - `sudo ./set-hostname.sh -n server1.example.local`\n- Set short hostname + domain, sertakan pretty hostname dan IP mapping khusus:\n  - `sudo ./set-hostname.sh -n server1 -d example.local -p \"Server One\" -I 192.168.1.10`\n\nOpsi\n- `-n HOSTNAME`: Hostname baru (short atau FQDN).\n- `-d DOMAIN`: Domain untuk membentuk FQDN jika `-n` adalah short hostname.\n- `-p PRETTY`: Pretty hostname (bebas spasi, ditampilkan oleh `hostnamectl`).\n- `-I IP`: IP untuk pemetaan di `/etc/hosts` (default: `127.0.1.1` pada Debian-like, selain itu `127.0.0.1`).\n- `-m METHOD`: `auto` (default), `hostnamectl`, atau `etc` (tulis file langsung).\n- `-h`: Tampilkan bantuan.\n\nCatatan\n- Blok yang dikelola di `/etc/hosts` ditandai dengan:\n  - `# set-hostname.sh managed block start` … `# set-hostname.sh managed block end`\n- Jalankan dengan `sudo` untuk menerapkan perubahan.\n"
  },
  {
    "path": "jaringan/cek-port.sh",
    "content": "#!/bin/bash\n\n# ==============================================\n# Cek apakah port sedang digunakan & oleh siapa\n# Support: TCP/UDP | Output proses lengkap\n# ==============================================\n\nPORT=$1\nPROTOCOL=${2:-tcp} # default tcp\n\n# Fungsi untuk menampilkan bantuan\nshow_help() {\n  echo \"Penggunaan: $0 <port> [protocol]\"\n  echo \"Contoh: $0 8080\"\n  echo \"        $0 53 udp\"\n  exit 1\n}\n\n# Validasi input\nif ! [[ \"$PORT\" =~ ^[0-9]+$ ]]; then\n  echo \"❌ Port harus berupa angka.\"\n  show_help\nfi\n\nif [[ \"$PROTOCOL\" != \"tcp\" && \"$PROTOCOL\" != \"udp\" ]]; then\n  echo \"❌ Protocol hanya boleh 'tcp' atau 'udp'.\"\n  show_help\nfi\n\necho \" Mengecek port $PORT ($PROTOCOL)...\"\nfound=0\n\n# Cek menggunakan ss (lebih modern)\nif command -v ss >/dev/null; then\n  OUTPUT=$(ss -lpun | grep -w \":$PORT \")\n  if [[ -n \"$OUTPUT\" ]]; then\n    echo \" Port $PORT sedang digunakan:\"\n    echo \"$OUTPUT\" | awk '{print \"  ➤ \" $0}'\n    found=1\n  fi\nfi\n\n# Jika belum ketemu, cek dengan lsof\nif [[ $found -eq 0 && $(command -v lsof) ]]; then\n  OUTPUT=$(lsof -nP -i$PROTOCOL:$PORT 2>/dev/null)\n  if [[ -n \"$OUTPUT\" ]]; then\n    echo \" Port $PORT sedang digunakan:\"\n    echo \"$OUTPUT\" | awk 'NR==1{print \"  ➤ \" $0} NR>1{print \"  • PID: \"$2\", USER: \"$3\", COMMAND: \"$1}'\n    found=1\n  fi\nfi\n\n# Jika belum ketemu, cek dengan netstat (opsional legacy)\nif [[ $found -eq 0 && $(command -v netstat) ]]; then\n  OUTPUT=$(netstat -tunlp 2>/dev/null | grep -w \":$PORT\")\n  if [[ -n \"$OUTPUT\" ]]; then\n    echo \" Port $PORT sedang digunakan:\"\n    echo \"$OUTPUT\" | awk '{print \"  ➤ \" $0}'\n    found=1\n  fi\nfi\n\nif [[ $found -eq 0 ]]; then\n  echo \"✅ Port $PORT tersedia & tidak sedang digunakan.\"\nfi"
  },
  {
    "path": "jaringan/static-ip-set-cmd.sh",
    "content": "#!/usr/bin/env bash\nset -euo pipefail\n\n# Set static IPv4 for common Linux network stacks, with discovery helpers:\n# - netplan (Ubuntu 18.04+)\n# - NetworkManager (nmcli)\n# - ifupdown (/etc/network/interfaces)\n# - systemd-networkd\n#\n# Usage:\n#   ./set-static-ip.sh -i eth0 -a 192.168.1.10/24 -g 192.168.1.1 -d \"1.1.1.1,8.8.8.8\" [-m auto|netplan|nmcli|ifupdown|systemd-networkd]\n#   ./set-static-ip.sh -s                  # show current network info (auto-detect iface)\n#   ./set-static-ip.sh -i eth0 -D          # dry-run: show planned changes using current values\n#\n# Notes:\n# - Requires root to apply changes (not needed for -s or -D)\n# - IP must be CIDR (e.g., 192.168.1.10/24)\n# - Will back up modified files\n\nprint_help() {\n  cat <<'EOF'\nUsage:\n  set-static-ip.sh -i IFACE -a IP/CIDR -g GATEWAY -d \"DNS1,DNS2\" [-m METHOD]\n\nOptions:\n  -i   Interface name (e.g., eth0, enp0s3)\n  -a   IPv4 with CIDR (e.g., 192.168.1.10/24)\n  -g   Gateway IPv4 (e.g., 192.168.1.1)\n  -d   DNS servers comma or space separated (e.g., \"1.1.1.1,8.8.8.8\")\n  -m   Method: auto (default), netplan, nmcli, ifupdown, systemd-networkd\n  -s   Show current network info and exit\n  -D   Dry-run: compute and print planned config, do not apply\n  -h   Help\n\nExamples:\n  set-static-ip.sh -i eth0 -a 192.168.10.20/24 -g 192.168.10.1 -d \"1.1.1.1,8.8.8.8\"\n  set-static-ip.sh -i enp0s3 -a 10.0.0.10/24 -g 10.0.0.1 -d \"9.9.9.9\" -m netplan\n  set-static-ip.sh -s\n  set-static-ip.sh -i eth0 -D\nEOF\n}\n\nrequire_root() {\n  if [[ ${EUID} -ne 0 ]]; then\n    echo \"Error: must run as root\" >&2\n    exit 1\n  fi\n}\n\ntimestamp() { date +\"%Y%m%d-%H%M%S\"; }\nbackup_file() {\n  local f=\"$1\"\n  if [[ -f \"$f\" ]]; then\n    cp -a -- \"$f\" \"${f}.bak.$(timestamp)\"\n  fi\n}\n\n# Normalize DNS list to space separated\nnormalize_dns() {\n  local raw=\"$1\"\n  if [[ -z \"$raw\" ]]; then echo \"\"; return; fi\n  echo \"$raw\" | tr ',' ' ' | xargs\n}\n\ncidr_to_netmask() {\n  local cidr=\"$1\"\n  local bits=$(( 0xffffffff ^ ((1 << (32 - cidr)) - 1) ))\n  printf \"%d.%d.%d.%d\" $(( (bits>>24)&255 )) $(( (bits>>16)&255 )) $(( (bits>>8)&255 )) $(( bits&255 ))\n}\n\n# ---- Detection helpers ----\nget_default_iface() {\n  ip route show default 0.0.0.0/0 2>/dev/null | awk '/default/ {for(i=1;i<=NF;i++) if ($i==\"dev\") {print $(i+1); exit}}'\n}\n\nget_iface_ipv4_cidr() {\n  local dev=\"$1\"\n  ip -4 -o addr show dev \"$dev\" 2>/dev/null | awk '{print $4}' | head -n1\n}\n\nget_iface_gateway() {\n  local dev=\"$1\"\n  local gw\n  gw=\"$(ip route show default dev \"$dev\" 2>/dev/null | awk '/default/ {print $3; exit}')\"\n  if [[ -z \"$gw\" ]]; then\n    gw=\"$(ip route show default 2>/dev/null | awk '/default/ {print $3; exit}')\"\n  fi\n  echo \"$gw\"\n}\n\nget_dns_from_resolvectl() {\n  local dev=\"$1\"\n  if command -v resolvectl >/dev/null 2>&1; then\n    local out\n    out=\"$(resolvectl dns \"$dev\" 2>/dev/null || true)\"\n    if [[ -n \"$out\" ]]; then\n      echo \"$out\" | awk -F': ' 'NF>1 {print $2}'\n      return\n    fi\n    resolvectl status 2>/dev/null | awk '/DNS Servers:/ {for(i=3;i<=NF;i++) printf(\"%s \", $i); print \"\"; exit}'\n  fi\n}\n\nget_dns_from_resolv_conf() {\n  if [[ -r /etc/resolv.conf ]]; then\n    awk '/^nameserver / {print $2}' /etc/resolv.conf | xargs\n  fi\n}\n\nget_current_dns() {\n  local dev=\"$1\"\n  local dns\n  dns=\"$(get_dns_from_resolvectl \"$dev\" | xargs || true)\"\n  if [[ -z \"$dns\" ]]; then\n    dns=\"$(get_dns_from_resolv_conf | xargs || true)\"\n  fi\n  echo \"$dns\"\n}\n\n# ---- Method detection and apply helpers ----\ndetect_method() {\n  if [[ \"$method\" != \"auto\" ]]; then\n    echo \"$method\"\n    return\n  fi\n  if command -v netplan >/dev/null 2>&1 && [[ -d /etc/netplan ]]; then\n    echo \"netplan\"; return\n  fi\n  if command -v nmcli >/dev/null 2>&1 && systemctl is-active --quiet NetworkManager.service; then\n    echo \"nmcli\"; return\n  fi\n  if [[ -f /etc/network/interfaces ]]; then\n    echo \"ifupdown\"; return\n  fi\n  if systemctl list-unit-files 2>/dev/null | grep -q '^systemd-networkd\\.service'; then\n    echo \"systemd-networkd\"; return\n  fi\n  if command -v nmcli >/dev/null 2>&1; then echo \"nmcli\"; return; fi\n  if command -v netplan >/dev/null 2>&1; then echo \"netplan\"; return; fi\n  echo \"systemd-networkd\"\n}\n\napply_netplan() {\n  local file=\"/etc/netplan/99-static-${iface}.yaml\"\n  mkdir -p /etc/netplan\n  backup_file \"$file\"\n  cat > \"$file\" <<EOF\nnetwork:\n  version: 2\n  renderer: networkd\n  ethernets:\n    ${iface}:\n      dhcp4: false\n      addresses:\n        - ${ip_cidr}\n      routes:\n        - to: 0.0.0.0/0\n          via: ${gateway}\n$( if [[ -n \"$dns_list\" ]]; then\n     echo \"      nameservers:\"\n     echo \"        addresses:\"\n     for d in $dns_list; do\n       echo \"          - ${d}\"\n     done\n   fi )\nEOF\n  netplan generate\n  netplan apply\n}\n\napply_nmcli() {\n  local conn_name=\"\"\n  while IFS= read -r name; do\n    local ifn\n    ifn=\"$(nmcli -g connection.interface-name connection show \"$name\" 2>/dev/null || true)\"\n    if [[ \"$ifn\" == \"$iface\" ]]; then conn_name=\"$name\"; break; fi\n  done < <(nmcli -g NAME connection show)\n\n  if [[ -z \"$conn_name\" ]]; then\n    conn_name=\"static-${iface}\"\n    nmcli connection add type ethernet ifname \"$iface\" con-name \"$conn_name\" ipv4.method manual\n  fi\n\n  nmcli connection modify \"$conn_name\" \\\n    ipv4.method manual \\\n    ipv4.addresses \"${ip_cidr}\" \\\n    ipv4.gateway \"${gateway}\" \\\n    ipv6.method ignore \\\n    autoconnect yes\n\n  if [[ -n \"$dns_list\" ]]; then\n    nmcli connection modify \"$conn_name\" ipv4.dns \"$(echo \"$dns_list\" | tr ' ' ',')\" ipv4.ignore-auto-dns yes\n  else\n    nmcli connection modify \"$conn_name\" -ipv4.dns ipv4.ignore-auto-dns yes\n  fi\n\n  nmcli connection down \"$conn_name\" || true\n  nmcli connection up \"$conn_name\"\n}\n\napply_ifupdown() {\n  local file=\"/etc/network/interfaces\"\n  backup_file \"$file\"\n\n  if grep -qE \"^[[:space:]]*iface[[:space:]]+${iface}[[:space:]]+inet[[:space:]]+\" \"$file\"; then\n    sed -i.bak.$(timestamp) -E \"s/^([[:space:]]*iface[[:space:]]+${iface}[[:space:]]+inet[[:space:]]+.*)$/# \\1/\" \"$file\" || true\n    sed -i -E \"s/^([[:space:]]*(address|netmask|gateway|dns-nameservers).*)$/# \\1/\" \"$file\" || true\n  fi\n\n  {\n    echo \"\"\n    echo \"# static config added $(timestamp)\"\n    echo \"auto ${iface}\"\n    echo \"iface ${iface} inet static\"\n    echo \"    address ${ip_addr}\"\n    echo \"    netmask ${netmask}\"\n    echo \"    gateway ${gateway}\"\n    if [[ -n \"$dns_list\" ]]; then\n      echo \"    dns-nameservers ${dns_list}\"\n    fi\n  } >> \"$file\"\n\n  ifdown \"$iface\" 2>/dev/null || true\n  ifup \"$iface\"\n}\n\napply_systemd_networkd() {\n  mkdir -p /etc/systemd/network\n  local file=\"/etc/systemd/network/${iface}-static.network\"\n  backup_file \"$file\"\n  {\n    echo \"[Match]\"\n    echo \"Name=${iface}\"\n    echo \"\"\n    echo \"[Network]\"\n    echo \"Address=${ip_cidr}\"\n    echo \"Gateway=${gateway}\"\n    if [[ -n \"$dns_list\" ]]; then\n      for d in $dns_list; do echo \"DNS=${d}\"; done\n    fi\n  } > \"$file\"\n  systemctl enable systemd-networkd.service >/dev/null 2>&1 || true\n  systemctl restart systemd-networkd.service\n}\n\n# ---- Args ----\niface=\"\"\nip_cidr=\"\"\ngateway=\"\"\ndns_raw=\"\"\nmethod=\"auto\"\nshow_only=false\ndry_run=false\n\nwhile getopts \":i:a:g:d:m:sDh\" opt; do\n  case \"$opt\" in\n    i) iface=\"$OPTARG\" ;;\n    a) ip_cidr=\"$OPTARG\" ;;\n    g) gateway=\"$OPTARG\" ;;\n    d) dns_raw=\"$OPTARG\" ;;\n    m) method=\"$OPTARG\" ;;\n    s) show_only=true ;;\n    D) dry_run=true ;;\n    h) print_help; exit 0 ;;\n    \\?) echo \"Invalid option -$OPTARG\" >&2; print_help; exit 2 ;;\n    :) echo \"Option -$OPTARG requires an argument.\" >&2; print_help; exit 2 ;;\n  esac\ndone\n\n# Auto-select interface if not provided\nif [[ -z \"$iface\" ]]; then\n  iface=\"$(get_default_iface || true)\"\nfi\n\nif [[ -z \"$iface\" ]]; then\n  echo \"Error: interface not specified and could not auto-detect default interface.\" >&2\n  echo \"Hint: pass -i IFACE. Available interfaces:\" >&2\n  ip -brief link show || true\n  exit 2\nfi\n\nif ! ip link show \"$iface\" >/dev/null 2>&1; then\n  echo \"Error: interface '$iface' not found.\" >&2\n  ip -brief link show || true\n  exit 1\nfi\n\n# Derive current values from system when missing\ncurrent_ip_cidr=\"$(get_iface_ipv4_cidr \"$iface\" || true)\"\ncurrent_gateway=\"$(get_iface_gateway \"$iface\" || true)\"\ncurrent_dns=\"$(get_current_dns \"$iface\" || true)\"\n\nif [[ -z \"$ip_cidr\" && -n \"$current_ip_cidr\" ]]; then ip_cidr=\"$current_ip_cidr\"; fi\nif [[ -z \"$gateway\" && -n \"$current_gateway\" ]]; then gateway=\"$current_gateway\"; fi\n\ndns_list=\"$(normalize_dns \"${dns_raw:-}\")\"\nif [[ -z \"$dns_list\" && -n \"$current_dns\" ]]; then dns_list=\"$current_dns\"; fi\n\n# Show-only mode\nif [[ \"$show_only\" == true ]]; then\n  chosen_show=\"$(detect_method)\"\n  mac_addr=\"\"\n  if [[ -r \"/sys/class/net/${iface}/address\" ]]; then\n    mac_addr=\"$(cat \"/sys/class/net/${iface}/address\" 2>/dev/null || true)\"\n  fi\n  echo \"Interface : $iface\"\n  echo \"State     : $(cat /sys/class/net/${iface}/operstate 2>/dev/null || echo unknown)\"\n  echo \"IPv4/CIDR : ${ip_cidr:-none}\"\n  echo \"Gateway   : ${gateway:-none}\"\n  echo \"DNS       : ${dns_list:-none}\"\n  echo \"MAC       : ${mac_addr:-unknown}\"\n  echo \"Method    : ${chosen_show}\"\n  exit 0\nfi\n\n# Ensure we have required values after inference\nif [[ -z \"$ip_cidr\" || -z \"$gateway\" ]]; then\n  echo \"Error: missing -a or -g and could not infer from current network.\" >&2\n  echo \"Got: iface=$iface, ip_cidr='${ip_cidr:-}', gateway='${gateway:-}'\" >&2\n  exit 2\nfi\n\n# Validate formats\nif [[ ! \"$ip_cidr\" =~ ^([0-9]{1,3}\\.){3}[0-9]{1,3}/([0-9]|[12][0-9]|3[0-2])$ ]]; then\n  echo \"Error: -a must be IPv4/CIDR, e.g., 192.168.1.10/24\" >&2\n  exit 2\nfi\nif [[ ! \"$gateway\" =~ ^([0-9]{1,3}\\.){3}[0-9]{1,3}$ ]]; then\n  echo \"Error: -g must be IPv4, e.g., 192.168.1.1\" >&2\n  exit 2\nfi\n\nip_addr=\"${ip_cidr%/*}\"\nprefix=\"${ip_cidr#*/}\"\nnetmask=\"$(cidr_to_netmask \"$prefix\")\"\n\nchosen=\"$(detect_method)\"\necho \"Using method: ${chosen}\"\n\n# Dry-run mode\nif [[ \"$dry_run\" == true ]]; then\n  echo \"Planned configuration:\"\n  echo \"  Interface : $iface\"\n  echo \"  IPv4/CIDR : $ip_cidr\"\n  echo \"  Netmask   : $netmask (/${prefix})\"\n  echo \"  Gateway   : $gateway\"\n  echo \"  DNS       : ${dns_list:-none}\"\n  echo \"  Method    : $chosen\"\n  exit 0\nfi\n\n# Apply requires root\nrequire_root\n\ncase \"$chosen\" in\n  netplan) apply_netplan ;;\n  nmcli) apply_nmcli ;;\n  ifupdown) apply_ifupdown ;;\n  systemd-networkd) apply_systemd_networkd ;;\n  *) echo \"Unknown method '${chosen}'\"; exit 1 ;;\n\nesac\n\necho \"Static IP configured on ${iface} -> ${ip_cidr}, gateway ${gateway}${dns_list:+, DNS: ${dns_list}}\""
  },
  {
    "path": "jaringan/setup_sudo_nopasswd.sh",
    "content": "#!/bin/bash\n\n# Cek apakah dijalankan sebagai root\nif [[ $EUID -ne 0 ]]; then\n    echo \"❌ Script ini harus dijalankan sebagai root.\"\n    exit 1\nfi\n\n# Deteksi user aktif (non-root)\nactive_user=$(logname 2>/dev/null || echo $SUDO_USER)\ndefault_user=${active_user:-$(whoami)}\n\necho \"🧑  User terdeteksi: $default_user\"\nread -p \"Masukkan username yang ingin diberikan akses sudo tanpa password [$default_user]: \" input_user\nusername=${input_user:-$default_user}\n\n# Cek apakah user valid\nif ! id \"$username\" &>/dev/null; then\n    echo \"❌ User '$username' tidak ditemukan!\"\n    exit 2\nfi\n\n# Lokasi file sudoers\nsudoers_file=\"/etc/sudoers.d/$username\"\n\n# Konfirmasi\necho \"\"\necho \"⚠️  Ini akan memberikan akses sudo penuh tanpa password ke user '$username'\"\nread -p \"Lanjutkan? [y/N]: \" confirm\nconfirm=${confirm,,} # lowercase\n\nif [[ \"$confirm\" != \"y\" ]]; then\n    echo \"❌ Operasi dibatalkan.\"\n    exit 3\nfi\n\n# Tulis file sudoers\necho \"$username ALL=(ALL) NOPASSWD:ALL\" > \"$sudoers_file\"\n\n# Set permission sesuai standar sudoers\nchmod 0440 \"$sudoers_file\"\n\n# Validasi file sudoers\nif visudo -cf \"$sudoers_file\"; then\n    echo \"✅ Sukses: User '$username' sekarang bisa menggunakan sudo tanpa password.\"\n    echo \"🔍 Gunakan 'sudo -l -U $username' untuk memverifikasi.\"\nelse\n    echo \"❌ Gagal validasi sudoers. Menghapus file.\"\n    rm -f \"$sudoers_file\"\n    exit 4\nfi\n"
  },
  {
    "path": "Programming-Lang/Javascript/nodejs.sh",
    "content": "#!/usr/bin/env bash\n# Universal Node.js 22 installer dengan fnm + pnpm\n# By Hendra's request 😁\n\nset -euo pipefail\n\nneed_cmd() { command -v \"$1\" >/dev/null 2>&1; }\nas_root() {\n  if [ \"${EUID:-$(id -u)}\" -ne 0 ]; then\n    if need_cmd sudo; then sudo \"$@\"; else\n      echo \"Butuh root. Install sudo atau jalankan sebagai root.\" >&2\n      exit 1\n    fi\n  else\n    \"$@\"\n  fi\n}\n\nlog() { printf \"\\033[1;32m==>\\033[0m %s\\n\" \"$*\"; }\nerr() { printf \"\\033[1;31mxx\\033[0m %s\\n\" \"$*\" >&2; exit 1; }\n\n# ---------- Deteksi package manager ----------\nPKG_MGR=\"\"\ndetect_pkg_mgr() {\n  if need_cmd pacman; then PKG_MGR=\"pacman\"\n  elif need_cmd apt-get; then PKG_MGR=\"apt\"\n  elif need_cmd dnf; then PKG_MGR=\"dnf\"\n  elif need_cmd yum; then PKG_MGR=\"yum\"\n  elif need_cmd zypper; then PKG_MGR=\"zypper\"\n  elif need_cmd apk; then PKG_MGR=\"apk\"\n  else\n    err \"Tidak menemukan package manager yang didukung.\"\n  fi\n}\n\n# ---------- Install deps dasar ----------\ninstall_deps() {\n  case \"$PKG_MGR\" in\n    pacman)\n      as_root pacman -Sy --noconfirm --needed curl unzip coreutils\n      ;;\n    apt)\n      as_root apt-get update -y\n      as_root apt-get install -y curl unzip ca-certificates\n      ;;\n    dnf)\n      as_root dnf install -y curl unzip\n      ;;\n    yum)\n      as_root yum install -y curl unzip\n      ;;\n    zypper)\n      as_root zypper --non-interactive install curl unzip\n      ;;\n    apk)\n      as_root apk add --no-cache curl unzip\n      ;;\n  esac\n}\n\n# ---------- Install FNM ----------\ninstall_fnm() {\n  if ! need_cmd fnm; then\n    log \"Menginstall fnm (Fast Node Manager)...\"\n    curl -fsSL https://fnm.vercel.app/install | bash\n    # Aktifkan fnm untuk sesi ini\n    export PATH=\"$HOME/.local/share/fnm:$PATH\"\n    eval \"`fnm env`\"\n  else\n    log \"fnm sudah terpasang.\"\n  fi\n}\n\n# ---------- Install Node.js 22 ----------\ninstall_node() {\n  export PATH=\"$HOME/.local/share/fnm:$PATH\"\n  eval \"`fnm env`\"\n  if ! node -v 2>/dev/null | grep -q \"v22\"; then\n    log \"Menginstall Node.js v22...\"\n    fnm install 22\n    fnm default 22\n  else\n    log \"Node.js v22 sudah terpasang.\"\n  fi\n}\n\n# ---------- Install pnpm ----------\ninstall_pnpm() {\n  export PATH=\"$HOME/.local/share/fnm:$PATH\"\n  eval \"`fnm env`\"\n  if ! need_cmd pnpm; then\n    log \"Mengaktifkan pnpm via corepack...\"\n    corepack enable pnpm\n  else\n    log \"pnpm sudah aktif.\"\n  fi\n}\n\n# ---------- Verifikasi ----------\nverify_install() {\n  export PATH=\"$HOME/.local/share/fnm:$PATH\"\n  eval \"`fnm env`\"\n  log \"Versi Node.js:\"\n  node -v\n  log \"Versi pnpm:\"\n  pnpm -v\n}\n\n# ---------- Main ----------\nmain() {\n  detect_pkg_mgr\n  install_deps\n  install_fnm\n  install_node\n  install_pnpm\n  verify_install\n  log \"Instalasi selesai 🎉\"\n}\n\nmain \"$@\"\n"
  },
  {
    "path": "vm-test/.cursor/rules/vibeops.mdc",
    "content": "---\ndescription: \"Alias of VibeOps – see devops.mdc.\"\nglobs:\n- \"**/*\"\nalwaysApply: false\n---\n\nThis rule aliases `@devops.mdc`.\n\nUsage: invoke `@devops.mdc` or `@vibeops.mdc` with your instruction.\n\n"
  },
  {
    "path": "vm-test/.cursor/rules/devops.mdc",
    "content": "---\ndescription: \"VibeOps – Linux VPS security hardening, audits, and stack bootstrapping (Node/Bun, Python, Go, Rust). Uses local scripts for checks and proposes non-interactive, idempotent commands.\"\nglobs:\n- \"**/*\"\nalwaysApply: false\n---\n\nYou are VibeOps: a pragmatic DevOps/SRE assistant for small to large fleets running on bare VPSes. Your job is to audit and harden servers, then bootstrap app stacks (Node/Bun with pnpm, Python, Go, Rust) using safe, reversible edits and non-interactive commands. Prefer minimal dependencies and keep RAM/CPU usage low.\n\nOperating principles\n- Safety first: never run destructive commands without explicit confirmation. Always propose commands first with --yes/--assume-yes and DEBIAN_FRONTEND=noninteractive where applicable.\n- Idempotent by default: write commands and edits so reruns are safe.\n- Backups before edits: for any config you change, create a time-stamped backup next to it.\n- Least privilege: avoid broad sudo; scope to the exact command.\n- Logs and verification: after changes, show how to verify with journalctl/systemctl and the included audit scripts.\n\nLocal helpers available\n- Security audit (read-only): `/home/hades/vm-test/vps-sec-check.sh --all --no-color`\n- VPS capability check: `/home/hades/vm-test/vps-check.sh --all --no-color`\n\nWhen asked to “secure my server” or similar\n1) Run audits (read-only):\n   - Propose: `bash /home/hades/vm-test/vps-sec-check.sh --all --no-color | cat`\n   - Propose: `bash /home/hades/vm-test/vps-check.sh --all --no-color | cat`\n2) Baseline hardening (Ubuntu/Debian, auto-confirmed, non-interactive). Always propose first:\n   - Update and enable unattended upgrades:\n     - `sudo DEBIAN_FRONTEND=noninteractive apt-get update -y`\n     - `sudo DEBIAN_FRONTEND=noninteractive apt-get install -y unattended-upgrades apt-listchanges update-notifier-common`\n     - `sudo dpkg-reconfigure -f noninteractive unattended-upgrades`\n     - Ensure `/etc/apt/apt.conf.d/20auto-upgrades` contains:\n       - `APT::Periodic::Update-Package-Lists \"1\";`\n       - `APT::Periodic::Unattended-Upgrade \"1\";`\n       - `Unattended-Upgrade::Automatic-Reboot \"true\";`\n       - `Unattended-Upgrade::Automatic-Reboot-Time \"03:30\";`\n   - Firewall (UFW) minimal policy:\n     - `sudo DEBIAN_FRONTEND=noninteractive apt-get install -y ufw`\n     - `sudo ufw default deny incoming`\n     - `sudo ufw default allow outgoing`\n     - `sudo ufw allow OpenSSH`\n     - `sudo ufw allow 80,443/tcp`\n     - `echo y | sudo ufw enable`\n   - SSH hardening:\n     - Backup: `sudo cp -a /etc/ssh/sshd_config /etc/ssh/sshd_config.$(date +%F-%H%M%S).bak`\n     - Ensure effective settings: `PermitRootLogin no`, `PasswordAuthentication no` (if keys are present), `MaxAuthTries 4`, `X11Forwarding no`\n     - Test cfg: `sudo sshd -t`\n     - Restart: `sudo systemctl restart sshd || sudo systemctl restart ssh`\n   - Fail2ban:\n     - `sudo DEBIAN_FRONTEND=noninteractive apt-get install -y fail2ban`\n     - Create `/etc/fail2ban/jail.local` with at least:\n       - `[sshd]` `enabled = true` `port = ssh` `filter = sshd` `maxretry = 5` `findtime = 10m` `bantime = 1h`\n     - `sudo systemctl enable --now fail2ban`\n     - Verify: `sudo fail2ban-client status sshd`\n   - Time sync:\n     - `sudo systemctl enable --now systemd-timesyncd || true`\n   - Kernel/sysctl hardening (conservative):\n     - Add to `/etc/sysctl.d/99-vibeops.conf` and apply with `sudo sysctl --system`:\n       - `net.ipv4.ip_forward=0`\n       - `net.ipv4.conf.all.accept_source_route=0`\n       - `net.ipv4.conf.all.send_redirects=0`\n       - `net.ipv4.icmp_echo_ignore_broadcasts=1`\n       - `net.ipv4.tcp_syncookies=1`\n       - `net.ipv4.conf.all.rp_filter=1`\n       - `net.ipv6.conf.all.accept_ra=0` (only on servers)\n3) Verify again:\n   - Propose: `bash /home/hades/vm-test/vps-sec-check.sh --all --no-color | cat`\n\nStacks you can bootstrap\n- Node/Bun (prefer Bun + pnpm if available, else Node LTS):\n  - Prefer Bun runtime and pnpm for package management if present in the project [[memory:3361497]] [[memory:3361494]].\n  - Propose installing: `curl -fsSL https://bun.sh/install | bash` (non-interactive); `corepack enable` for pnpm or `npm -g i pnpm`.\n  - Generate a systemd unit for a Bun/Node app in `/etc/systemd/system/<name>.service` with `User=<svcuser>`, `WorkingDirectory=<path>`, `ExecStart=bun run start` (or `node dist/index.js`), `Restart=always`.\n- Python:\n  - `sudo DEBIAN_FRONTEND=noninteractive apt-get install -y python3 python3-venv python3-pip`\n  - Use venv under the app directory; install deps; create systemd unit executing the venv’s python.\n- Go:\n  - `sudo DEBIAN_FRONTEND=noninteractive apt-get install -y golang`\n  - Build `CGO_ENABLED=0 go build -ldflags \"-s -w\" -o bin/app ./cmd/app` and run via systemd; prefer a dedicated non-login user.\n- Rust:\n  - Install non-interactively: `curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y`\n  - Build with `cargo build --release`; deploy the static binary and wire with systemd.\n\nGeneric systemd service template (fill values when proposing):\n```\n[Unit]\nDescription=%i service\nAfter=network.target\n\n[Service]\nType=simple\nUser=<svcuser>\nGroup=<svcuser>\nWorkingDirectory=<app_path>\nEnvironment=NODE_ENV=production\nExecStart=<start_cmd>\nRestart=always\nRestartSec=2\nNoNewPrivileges=true\nProtectSystem=full\nProtectHome=true\nPrivateTmp=true\n\n[Install]\nWantedBy=multi-user.target\n```\n\nMonitoring and observability (optional, propose on request)\n- Install and enable `node-exporter` or `prometheus-node-exporter`.\n- Ship logs to a small stack (e.g., vector + Loki) if needed.\n\nCloudflare and multi-region (optional)\n- For quick exposure, propose `cloudflared` tunnel setup; otherwise open ports 80/443 via UFW/Nginx.\n- Document DNS/LB steps; do not change Cloudflare config without explicit request.\n\nHow to interact\n- If the user says “secure this server”, present a short plan and the exact commands you propose to run. Ask for approval, then execute.\n- If asked to “make X app live”, pick a sensible minimal stack (Bun/Node, Python, Go, Rust). Scaffold folder, configure systemd, firewall, and a health check.\n- After any change, show verification commands and how to roll back using the backups you created.\n\nVerification commands cheat-sheet (read-only)\n- `ss -tulpen | cat`\n- `sudo systemctl status <svc> | cat`\n- `sudo journalctl -u <svc> -n 100 --no-pager | cat`\n- `sudo fail2ban-client status | cat`\n- `sudo ufw status verbose | cat`\n- `bash /home/hades/vm-test/vps-sec-check.sh --all --no-color | cat`\n\n"
  },
  {
    "path": "Programming-Lang/Javascript/bun.sh",
    "content": "#!/usr/bin/env bash\n# Installer Bun untuk Linux\n# By Hendra 😎\n\nset -euo pipefail\n\nneed_cmd() { command -v \"$1\" >/dev/null 2>&1; }\nas_root() {\n  if [ \"${EUID:-$(id -u)}\" -ne 0 ]; then\n    if need_cmd sudo; then sudo \"$@\"; else\n      echo \"Butuh root. Install sudo atau jalankan sebagai root.\" >&2\n      exit 1\n    fi\n  else\n    \"$@\"\n  fi\n}\n\nlog() { printf \"\\033[1;32m==>\\033[0m %s\\n\" \"$*\"; }\nerr() { printf \"\\033[1;31mxx\\033[0m %s\\n\" \"$*\" >&2; exit 1; }\n\n# ---------- Deteksi package manager ----------\nPKG_MGR=\"\"\ndetect_pkg_mgr() {\n  if need_cmd pacman; then PKG_MGR=\"pacman\"\n  elif need_cmd apt-get; then PKG_MGR=\"apt\"\n  elif need_cmd dnf; then PKG_MGR=\"dnf\"\n  elif need_cmd yum; then PKG_MGR=\"yum\"\n  elif need_cmd zypper; then PKG_MGR=\"zypper\"\n  elif need_cmd apk; then PKG_MGR=\"apk\"\n  else\n    err \"Tidak menemukan package manager yang didukung.\"\n  fi\n}\n\n# ---------- Install curl jika belum ada ----------\ninstall_curl() {\n  if need_cmd curl; then\n    log \"curl sudah terpasang.\"\n    return\n  fi\n  log \"Menginstall curl...\"\n  case \"$PKG_MGR\" in\n    pacman) as_root pacman -Sy --noconfirm curl ;;\n    apt) as_root apt-get update -y && as_root apt-get install -y curl ;;\n    dnf) as_root dnf install -y curl ;;\n    yum) as_root yum install -y curl ;;\n    zypper) as_root zypper --non-interactive install curl ;;\n    apk) as_root apk add --no-cache curl ;;\n  esac\n}\n\n# ---------- Install Bun ----------\ninstall_bun() {\n  log \"Menginstall Bun...\"\n  curl -fsSL https://bun.sh/install | bash\n}\n\n# ---------- Load PATH & verifikasi ----------\nverify_bun() {\n  # PATH bun biasanya disimpan di ~/.bun/bin\n  export PATH=\"$HOME/.bun/bin:$PATH\"\n  if ! grep -qs '.bun/bin' \"$HOME/.bashrc\" 2>/dev/null; then\n    echo 'export PATH=\"$HOME/.bun/bin:$PATH\"' >> \"$HOME/.bashrc\"\n  fi\n  log \"Verifikasi instalasi Bun:\"\n  bun --version\n}\n\n# ---------- Main ----------\nmain() {\n  detect_pkg_mgr\n  install_curl\n  install_bun\n  verify_bun\n  log \"Instalasi Bun selesai 🎉. Jalankan: bun --version\"\n}\n\nmain \"$@\"\n"
  },
  {
    "path": "Programming-Lang/Javascript/deno.sh",
    "content": "#!/usr/bin/env bash\n# Installer Deno untuk Linux\n# By Hendra 😎\n\nset -euo pipefail\n\nneed_cmd() { command -v \"$1\" >/dev/null 2>&1; }\nas_root() {\n  if [ \"${EUID:-$(id -u)}\" -ne 0 ]; then\n    if need_cmd sudo; then sudo \"$@\"; else\n      echo \"Butuh root. Install sudo atau jalankan sebagai root.\" >&2\n      exit 1\n    fi\n  else\n    \"$@\"\n  fi\n}\n\nlog() { printf \"\\033[1;32m==>\\033[0m %s\\n\" \"$*\"; }\nerr() { printf \"\\033[1;31mxx\\033[0m %s\\n\" \"$*\" >&2; exit 1; }\n\n# ---------- Deteksi package manager ----------\nPKG_MGR=\"\"\ndetect_pkg_mgr() {\n  if need_cmd pacman; then PKG_MGR=\"pacman\"\n  elif need_cmd apt-get; then PKG_MGR=\"apt\"\n  elif need_cmd dnf; then PKG_MGR=\"dnf\"\n  elif need_cmd yum; then PKG_MGR=\"yum\"\n  elif need_cmd zypper; then PKG_MGR=\"zypper\"\n  elif need_cmd apk; then PKG_MGR=\"apk\"\n  else\n    err \"Tidak menemukan package manager yang didukung.\"\n  fi\n}\n\n# ---------- Install curl jika belum ada ----------\ninstall_curl() {\n  if need_cmd curl; then\n    log \"curl sudah terpasang.\"\n    return\n  fi\n  log \"Menginstall curl...\"\n  case \"$PKG_MGR\" in\n    pacman) as_root pacman -Sy --noconfirm curl ;;\n    apt) as_root apt-get update -y && as_root apt-get install -y curl ;;\n    dnf) as_root dnf install -y curl ;;\n    yum) as_root yum install -y curl ;;\n    zypper) as_root zypper --non-interactive install curl ;;\n    apk) as_root apk add --no-cache curl ;;\n  esac\n}\n\n# ---------- Install Deno ----------\ninstall_deno() {\n  log \"Menginstall Deno...\"\n  curl -fsSL https://deno.land/install.sh | sh\n}\n\n# ---------- Load PATH & verifikasi ----------\nverify_deno() {\n  export PATH=\"$HOME/.deno/bin:$PATH\"\n  if ! grep -qs '.deno/bin' \"$HOME/.bashrc\" 2>/dev/null; then\n    echo 'export PATH=\"$HOME/.deno/bin:$PATH\"' >> \"$HOME/.bashrc\"\n  fi\n  log \"Verifikasi instalasi Deno:\"\n  deno --version\n}\n\n# ---------- Main ----------\nmain() {\n  detect_pkg_mgr\n  install_curl\n  install_deno\n  verify_deno\n  log \"Instalasi Deno selesai 🎉. Jalankan: deno --version\"\n}\n\nmain \"$@\"\n"
  }
];
